From 046cb03e69d8b02d8c5bb0069e642afa0b433cd1 Mon Sep 17 00:00:00 2001
From: Derek Martin <code@pizzashack.org>
Date: Mon, 9 May 2016 14:06:54 -0700
Subject: [PATCH 30/31] Change M_* symbols to MUTT_*

Changeset 23334e967dd7 created a workaround for a namespace conflict
with Solaris and derivatives.  After some discussion, the team decided
it would be best to move away from using the "M_" prefix for macros.

This patch was automatically generated by running:
  perl -wpi -e 's/\bM_(\w+)\b/MUTT_$1/g' `find . -name '*.[ch]' -print`
with the exception that sys_socket.h was exempted.  (That file will
be backed out subsequent to this commit.)

Thanks to Andras Salamon for supplying the perl script used to make
this change.
---
 account.c           |  80 ++++++-------
 account.h           |  20 ++--
 addrbook.c          |   2 +-
 alias.c             |   8 +-
 attach.c            |  54 ++++-----
 browser.c           |  38 +++---
 buffy.c             |  36 +++---
 buffy.h             |   4 +-
 charset.c           |  10 +-
 charset.h           |   4 +-
 color.c             |   2 +-
 commands.c          |  89 +++++++-------
 compose.c           |  82 ++++++-------
 compress.c          |  26 ++--
 copy.c              |  78 ++++++------
 copy.h              |  26 ++--
 crypt-gpgme.c       |  50 ++++----
 crypt.c             |  22 ++--
 curs_lib.c          |  32 ++---
 curs_main.c         | 164 ++++++++++++-------------
 doc/makedoc.c       |   8 +-
 editmsg.c           |  20 ++--
 enter.c             |  62 +++++-----
 flags.c             |  54 ++++-----
 functions.h         |  14 +--
 group.h             |   4 +-
 handler.c           |  60 +++++-----
 hcache.c            |   4 +-
 hcache.h            |   2 +-
 hdrline.c           |  18 +--
 headers.c           |   4 +-
 help.c              |   2 +-
 hook.c              |  42 +++----
 imap/browse.c       |  10 +-
 imap/command.c      |  32 ++---
 imap/imap.c         | 146 +++++++++++------------
 imap/imap_private.h |   4 +-
 imap/message.c      |  38 +++---
 imap/util.c         |  26 ++--
 init.c              |  86 ++++++-------
 init.h              | 110 ++++++++---------
 keymap.c            |   6 +-
 lib.c               |   4 +-
 lib.h               |   4 +-
 mailbox.h           |  24 ++--
 main.c              |  40 +++----
 mbox.c              |  64 +++++-----
 menu.c              |  46 +++----
 mh.c                |  86 ++++++-------
 mutt.h              | 338 ++++++++++++++++++++++++++--------------------------
 mutt_curses.h       |  12 +-
 mutt_menu.h         |   2 +-
 mutt_notmuch.c      |  28 ++---
 mutt_sasl.c         |  12 +-
 mutt_socket.c       |   2 +-
 mutt_socket.h       |  12 +-
 mutt_ssl.c          |   6 +-
 mutt_ssl_gnutls.c   |   4 +-
 muttlib.c           |  44 +++----
 mx.c                | 242 ++++++++++++++++++-------------------
 mx.h                |  20 ++--
 newsrc.c            |  16 +--
 nntp.c              |  78 ++++++------
 pager.c             | 160 ++++++++++++-------------
 pager.h             |  26 ++--
 parse.c             |  20 ++--
 pattern.c           | 334 +++++++++++++++++++++++++--------------------------
 pgp.c               |  46 +++----
 pgpinvoke.c         |   4 +-
 pgpkey.c            |  10 +-
 pop.c               |  24 ++--
 pop_auth.c          |   2 +-
 pop_lib.c           |  18 +--
 postpone.c          |  16 +--
 protos.h            |  16 +--
 query.c             |   6 +-
 recvattach.c        |  48 ++++----
 recvcmd.c           |  42 +++----
 remailer.c          |   6 +-
 rfc1524.c           |  10 +-
 rfc2047.c           |   4 +-
 rfc2231.c           |   4 +-
 rfc3676.c           |   6 +-
 score.c             |   6 +-
 send.c              |  66 +++++-----
 sendlib.c           |  18 +--
 sidebar.c           |   8 +-
 smime.c             |  18 +--
 smtp.c              |  26 ++--
 sort.c              |   2 +-
 status.c            |   8 +-
 sys_socket.h        |  22 ++--
 system.c            |   6 +-
 thread.c            |  58 ++++-----
 94 files changed, 1853 insertions(+), 1850 deletions(-)

diff --git a/account.c b/account.c
index 57eba36..ca0ee8e 100644
--- a/account.c
+++ b/account.c
@@ -39,7 +39,7 @@ int mutt_account_match (const ACCOUNT* a1, const ACCOUNT* a2)
     return 0;
 
 #ifdef USE_IMAP
-  if (a1->type == M_ACCT_TYPE_IMAP)
+  if (a1->type == MUTT_ACCT_TYPE_IMAP)
   {
     if (ImapUser)
       user = ImapUser;
@@ -47,24 +47,24 @@ int mutt_account_match (const ACCOUNT* a1, const ACCOUNT* a2)
 #endif
 
 #ifdef USE_POP
-  if (a1->type == M_ACCT_TYPE_POP && PopUser)
+  if (a1->type == MUTT_ACCT_TYPE_POP && PopUser)
     user = PopUser;
 #endif
   
 #ifdef USE_NNTP
-  if (a1->type == M_ACCT_TYPE_NNTP && NntpUser)
+  if (a1->type == MUTT_ACCT_TYPE_NNTP && NntpUser)
     user = NntpUser;
 #endif
 
-  if (a1->flags & a2->flags & M_ACCT_USER)
+  if (a1->flags & a2->flags & MUTT_ACCT_USER)
     return (!strcmp (a1->user, a2->user));
 #ifdef USE_NNTP
-  if (a1->type == M_ACCT_TYPE_NNTP)
-    return a1->flags & M_ACCT_USER && a1->user[0] ? 0 : 1;
+  if (a1->type == MUTT_ACCT_TYPE_NNTP)
+    return a1->flags & MUTT_ACCT_USER && a1->user[0] ? 0 : 1;
 #endif
-  if (a1->flags & M_ACCT_USER)
+  if (a1->flags & MUTT_ACCT_USER)
     return (!strcmp (a1->user, user));
-  if (a2->flags & M_ACCT_USER)
+  if (a2->flags & MUTT_ACCT_USER)
     return (!strcmp (a2->user, user));
 
   return 1;
@@ -82,17 +82,17 @@ int mutt_account_fromurl (ACCOUNT* account, ciss_url_t* url)
   if (url->user)
   {
     strfcpy (account->user, url->user, sizeof (account->user));
-    account->flags |= M_ACCT_USER;
+    account->flags |= MUTT_ACCT_USER;
   }
   if (url->pass)
   {
     strfcpy (account->pass, url->pass, sizeof (account->pass));
-    account->flags |= M_ACCT_PASS;
+    account->flags |= MUTT_ACCT_PASS;
   }
   if (url->port)
   {
     account->port = url->port;
-    account->flags |= M_ACCT_PORT;
+    account->flags |= MUTT_ACCT_PORT;
   }
 
   return 0;
@@ -110,9 +110,9 @@ void mutt_account_tourl (ACCOUNT* account, ciss_url_t* url)
   url->port = 0;
 
 #ifdef USE_IMAP
-  if (account->type == M_ACCT_TYPE_IMAP)
+  if (account->type == MUTT_ACCT_TYPE_IMAP)
   {
-    if (account->flags & M_ACCT_SSL)
+    if (account->flags & MUTT_ACCT_SSL)
       url->scheme = U_IMAPS;
     else
       url->scheme = U_IMAP;
@@ -120,9 +120,9 @@ void mutt_account_tourl (ACCOUNT* account, ciss_url_t* url)
 #endif
 
 #ifdef USE_POP
-  if (account->type == M_ACCT_TYPE_POP)
+  if (account->type == MUTT_ACCT_TYPE_POP)
   {
-    if (account->flags & M_ACCT_SSL)
+    if (account->flags & MUTT_ACCT_SSL)
       url->scheme = U_POPS;
     else
       url->scheme = U_POP;
@@ -130,9 +130,9 @@ void mutt_account_tourl (ACCOUNT* account, ciss_url_t* url)
 #endif
 
 #ifdef USE_SMTP
-  if (account->type == M_ACCT_TYPE_SMTP)
+  if (account->type == MUTT_ACCT_TYPE_SMTP)
   {
-    if (account->flags & M_ACCT_SSL)
+    if (account->flags & MUTT_ACCT_SSL)
       url->scheme = U_SMTPS;
     else
       url->scheme = U_SMTP;
@@ -140,9 +140,9 @@ void mutt_account_tourl (ACCOUNT* account, ciss_url_t* url)
 #endif
 
 #ifdef USE_NNTP
-  if (account->type == M_ACCT_TYPE_NNTP)
+  if (account->type == MUTT_ACCT_TYPE_NNTP)
   {
-    if (account->flags & M_ACCT_SSL)
+    if (account->flags & MUTT_ACCT_SSL)
       url->scheme = U_NNTPS;
     else
       url->scheme = U_NNTP;
@@ -150,11 +150,11 @@ void mutt_account_tourl (ACCOUNT* account, ciss_url_t* url)
 #endif
 
   url->host = account->host;
-  if (account->flags & M_ACCT_PORT)
+  if (account->flags & MUTT_ACCT_PORT)
     url->port = account->port;
-  if (account->flags & M_ACCT_USER)
+  if (account->flags & MUTT_ACCT_USER)
     url->user = account->user;
-  if (account->flags & M_ACCT_PASS)
+  if (account->flags & MUTT_ACCT_PASS)
     url->pass = account->pass;
 }
 
@@ -164,18 +164,18 @@ int mutt_account_getuser (ACCOUNT* account)
   char prompt[SHORT_STRING];
 
   /* already set */
-  if (account->flags & M_ACCT_USER)
+  if (account->flags & MUTT_ACCT_USER)
     return 0;
 #ifdef USE_IMAP
-  else if ((account->type == M_ACCT_TYPE_IMAP) && ImapUser)
+  else if ((account->type == MUTT_ACCT_TYPE_IMAP) && ImapUser)
     strfcpy (account->user, ImapUser, sizeof (account->user));
 #endif
 #ifdef USE_POP
-  else if ((account->type == M_ACCT_TYPE_POP) && PopUser)
+  else if ((account->type == MUTT_ACCT_TYPE_POP) && PopUser)
     strfcpy (account->user, PopUser, sizeof (account->user));
 #endif
 #ifdef USE_NNTP
-  else if ((account->type == M_ACCT_TYPE_NNTP) && NntpUser)
+  else if ((account->type == MUTT_ACCT_TYPE_NNTP) && NntpUser)
     strfcpy (account->user, NntpUser, sizeof (account->user));
 #endif
   else if (option (OPTNOCURSES))
@@ -189,7 +189,7 @@ int mutt_account_getuser (ACCOUNT* account)
       return -1;
   }
 
-  account->flags |= M_ACCT_USER;
+  account->flags |= MUTT_ACCT_USER;
 
   return 0;
 }
@@ -197,26 +197,26 @@ int mutt_account_getuser (ACCOUNT* account)
 int mutt_account_getlogin (ACCOUNT* account)
 {
   /* already set */
-  if (account->flags & M_ACCT_LOGIN)
+  if (account->flags & MUTT_ACCT_LOGIN)
     return 0;
 #ifdef USE_IMAP
-  else if (account->type == M_ACCT_TYPE_IMAP)
+  else if (account->type == MUTT_ACCT_TYPE_IMAP)
   {
     if (ImapLogin)
     {
       strfcpy (account->login, ImapLogin, sizeof (account->login));
-      account->flags |= M_ACCT_LOGIN;
+      account->flags |= MUTT_ACCT_LOGIN;
     }
   }
 #endif
 
-  if (!(account->flags & M_ACCT_LOGIN))
+  if (!(account->flags & MUTT_ACCT_LOGIN))
   {
     mutt_account_getuser (account);
     strfcpy (account->login, account->user, sizeof (account->login));
   }
 
-  account->flags |= M_ACCT_LOGIN;
+  account->flags |= MUTT_ACCT_LOGIN;
 
   return 0;
 }
@@ -226,22 +226,22 @@ int mutt_account_getpass (ACCOUNT* account)
 {
   char prompt[SHORT_STRING];
 
-  if (account->flags & M_ACCT_PASS)
+  if (account->flags & MUTT_ACCT_PASS)
     return 0;
 #ifdef USE_IMAP
-  else if ((account->type == M_ACCT_TYPE_IMAP) && ImapPass)
+  else if ((account->type == MUTT_ACCT_TYPE_IMAP) && ImapPass)
     strfcpy (account->pass, ImapPass, sizeof (account->pass));
 #endif
 #ifdef USE_POP
-  else if ((account->type == M_ACCT_TYPE_POP) && PopPass)
+  else if ((account->type == MUTT_ACCT_TYPE_POP) && PopPass)
     strfcpy (account->pass, PopPass, sizeof (account->pass));
 #endif
 #ifdef USE_SMTP
-  else if ((account->type == M_ACCT_TYPE_SMTP) && SmtpPass)
+  else if ((account->type == MUTT_ACCT_TYPE_SMTP) && SmtpPass)
     strfcpy (account->pass, SmtpPass, sizeof (account->pass));
 #endif
 #ifdef USE_NNTP
-  else if ((account->type == M_ACCT_TYPE_NNTP) && NntpPass)
+  else if ((account->type == MUTT_ACCT_TYPE_NNTP) && NntpPass)
     strfcpy (account->pass, NntpPass, sizeof (account->pass));
 #endif
   else if (option (OPTNOCURSES))
@@ -249,19 +249,19 @@ int mutt_account_getpass (ACCOUNT* account)
   else
   {
     snprintf (prompt, sizeof (prompt), _("Password for %s@%s: "),
-              account->flags & M_ACCT_LOGIN ? account->login : account->user,
+              account->flags & MUTT_ACCT_LOGIN ? account->login : account->user,
               account->host);
     account->pass[0] = '\0';
     if (mutt_get_password (prompt, account->pass, sizeof (account->pass)))
       return -1;
   }
 
-  account->flags |= M_ACCT_PASS;
+  account->flags |= MUTT_ACCT_PASS;
 
   return 0;
 }
 
 void mutt_account_unsetpass (ACCOUNT* account)
 {
-  account->flags &= ~M_ACCT_PASS;
+  account->flags &= ~MUTT_ACCT_PASS;
 }
diff --git a/account.h b/account.h
index d968c1c..653b7cc 100644
--- a/account.h
+++ b/account.h
@@ -26,19 +26,19 @@
 /* account types */
 enum
 {
-  M_ACCT_TYPE_NONE = 0,
-  M_ACCT_TYPE_IMAP,
-  M_ACCT_TYPE_POP,
-  M_ACCT_TYPE_SMTP,
-  M_ACCT_TYPE_NNTP
+  MUTT_ACCT_TYPE_NONE = 0,
+  MUTT_ACCT_TYPE_IMAP,
+  MUTT_ACCT_TYPE_POP,
+  MUTT_ACCT_TYPE_SMTP,
+  MUTT_ACCT_TYPE_NNTP
 };
 
 /* account flags */
-#define M_ACCT_PORT  (1<<0)
-#define M_ACCT_USER  (1<<1)
-#define M_ACCT_LOGIN (1<<2)
-#define M_ACCT_PASS  (1<<3)
-#define M_ACCT_SSL   (1<<4)
+#define MUTT_ACCT_PORT  (1<<0)
+#define MUTT_ACCT_USER  (1<<1)
+#define MUTT_ACCT_LOGIN (1<<2)
+#define MUTT_ACCT_PASS  (1<<3)
+#define MUTT_ACCT_SSL   (1<<4)
 
 typedef struct
 {
diff --git a/addrbook.c b/addrbook.c
index aa844f4..a1670e9 100644
--- a/addrbook.c
+++ b/addrbook.c
@@ -80,7 +80,7 @@ alias_format_str (char *dest, size_t destlen, size_t col, int cols, char op, con
 
 static void alias_entry (char *s, size_t slen, MUTTMENU *m, int num)
 {
-  mutt_FormatString (s, slen, 0, MuttIndexWindow->cols, NONULL (AliasFmt), alias_format_str, (unsigned long) ((ALIAS **) m->data)[num], M_FORMAT_ARROWCURSOR);
+  mutt_FormatString (s, slen, 0, MuttIndexWindow->cols, NONULL (AliasFmt), alias_format_str, (unsigned long) ((ALIAS **) m->data)[num], MUTT_FORMAT_ARROWCURSOR);
 }
 
 static int alias_tag (MUTTMENU *menu, int n, int m)
diff --git a/alias.c b/alias.c
index cc941d8..131629a 100644
--- a/alias.c
+++ b/alias.c
@@ -270,9 +270,9 @@ retry_name:
   
   if (mutt_check_alias_name (buf, fixed, sizeof (fixed)))
   {
-    switch (mutt_yesorno (_("Warning: This alias name may not work.  Fix it?"), M_YES))
+    switch (mutt_yesorno (_("Warning: This alias name may not work.  Fix it?"), MUTT_YES))
     {
-      case M_YES:
+      case MUTT_YES:
       	strfcpy (buf, fixed, sizeof (buf));
 	goto retry_name;
       case -1: 
@@ -327,7 +327,7 @@ retry_name:
   buf[0] = 0;
   rfc822_write_address (buf, sizeof (buf), new->addr, 1);
   snprintf (prompt, sizeof (prompt), _("[%s = %s] Accept?"), new->name, buf);
-  if (mutt_yesorno (prompt, M_YES) != M_YES)
+  if (mutt_yesorno (prompt, MUTT_YES) != MUTT_YES)
   {
     mutt_free_alias (&new);
     return;
@@ -345,7 +345,7 @@ retry_name:
     Aliases = new;
 
   strfcpy (buf, NONULL (AliasFile), sizeof (buf));
-  if (mutt_get_field (_("Save to file: "), buf, sizeof (buf), M_FILE) != 0)
+  if (mutt_get_field (_("Save to file: "), buf, sizeof (buf), MUTT_FILE) != 0)
     return;
   mutt_expand_path (buf, sizeof (buf));
   if ((rc = fopen (buf, "a+")))
diff --git a/attach.c b/attach.c
index 7a77a53..f52898f 100644
--- a/attach.c
+++ b/attach.c
@@ -94,7 +94,7 @@ int mutt_compose_attachment (BODY *a)
   int rc = 0;
   
   snprintf (type, sizeof (type), "%s/%s", TYPE (a), a->subtype);
-  if (rfc1524_mailcap_lookup (a, type, entry, M_COMPOSE))
+  if (rfc1524_mailcap_lookup (a, type, entry, MUTT_COMPOSE))
   {
     if (entry->composecommand || entry->composetypecommand)
     {
@@ -110,7 +110,7 @@ int mutt_compose_attachment (BODY *a)
 				  a->filename, newfile));
 	if (safe_symlink (a->filename, newfile) == -1)
 	{
-	  if (mutt_yesorno (_("Can't match nametemplate, continue?"), M_YES) != M_YES)
+	  if (mutt_yesorno (_("Can't match nametemplate, continue?"), MUTT_YES) != MUTT_YES)
 	    goto bailout;
 	}
 	else
@@ -229,7 +229,7 @@ int mutt_edit_attachment (BODY *a)
   int rc = 0;
   
   snprintf (type, sizeof (type), "%s/%s", TYPE (a), a->subtype);
-  if (rfc1524_mailcap_lookup (a, type, entry, M_EDIT))
+  if (rfc1524_mailcap_lookup (a, type, entry, MUTT_EDIT))
   {
     if (entry->editcommand)
     {
@@ -242,7 +242,7 @@ int mutt_edit_attachment (BODY *a)
 				  a->filename, newfile));
 	if (safe_symlink (a->filename, newfile) == -1)
 	{
-	  if (mutt_yesorno (_("Can't match nametemplate, continue?"), M_YES) != M_YES)
+	  if (mutt_yesorno (_("Can't match nametemplate, continue?"), MUTT_YES) != MUTT_YES)
 	    goto bailout;
 	}
 	else
@@ -350,8 +350,8 @@ int mutt_view_attachment (FILE *fp, BODY *a, int flag, HEADER *hdr,
   if (WithCrypto && is_message && a->hdr && (a->hdr->security & ENCRYPT) &&
       !crypt_valid_passphrase(a->hdr->security))
     return (rc);
-  use_mailcap = (flag == M_MAILCAP ||
-		(flag == M_REGULAR && mutt_needs_mailcap (a)));
+  use_mailcap = (flag == MUTT_MAILCAP ||
+		(flag == MUTT_REGULAR && mutt_needs_mailcap (a)));
   snprintf (type, sizeof (type), "%s/%s", TYPE (a), a->subtype);
   
   if (use_mailcap)
@@ -359,12 +359,12 @@ int mutt_view_attachment (FILE *fp, BODY *a, int flag, HEADER *hdr,
     entry = rfc1524_new_entry (); 
     if (!rfc1524_mailcap_lookup (a, type, entry, 0))
     {
-      if (flag == M_REGULAR)
+      if (flag == MUTT_REGULAR)
       {
 	/* fallback to view as text */
 	rfc1524_free_entry (&entry);
 	mutt_error _("No matching mailcap entry found.  Viewing as text.");
-	flag = M_AS_TEXT;
+	flag = MUTT_AS_TEXT;
 	use_mailcap = 0;
       }
       else
@@ -397,7 +397,7 @@ int mutt_view_attachment (FILE *fp, BODY *a, int flag, HEADER *hdr,
 	/* send case: the file is already there */
 	if (safe_symlink (a->filename, tempfile) == -1)
 	{
-	  if (mutt_yesorno (_("Can't match nametemplate, continue?"), M_YES) == M_YES)
+	  if (mutt_yesorno (_("Can't match nametemplate, continue?"), MUTT_YES) == MUTT_YES)
 	    strfcpy (tempfile, a->filename, sizeof (tempfile));
 	  else
 	    goto return_error;
@@ -502,7 +502,7 @@ int mutt_view_attachment (FILE *fp, BODY *a, int flag, HEADER *hdr,
   {
     /* Don't use mailcap; the attachment is viewed in the pager */
 
-    if (flag == M_AS_TEXT)
+    if (flag == MUTT_AS_TEXT)
     {
       /* just let me see the raw data */
       if (fp)
@@ -524,7 +524,7 @@ int mutt_view_attachment (FILE *fp, BODY *a, int flag, HEADER *hdr,
 	  goto return_error;
 	}
 	decode_state.fpin = fp;
-	decode_state.flags = M_CHARCONV;
+	decode_state.flags = MUTT_CHARCONV;
 	mutt_decode_attachment(a, &decode_state);
 	if (fclose(decode_state.fpout) == EOF)
 	  dprint(1, (debugfile, "mutt_view_attachment:%d fclose errno=%d %s\n", __LINE__, pagerfile, errno, strerror(errno)));
@@ -544,7 +544,7 @@ int mutt_view_attachment (FILE *fp, BODY *a, int flag, HEADER *hdr,
       /* Use built-in handler */
       set_option (OPTVIEWATTACH); /* disable the "use 'v' to view this part"
 				   * message in case of error */
-      if (mutt_decode_save_attachment (fp, a, pagerfile, M_DISPLAY, 0))
+      if (mutt_decode_save_attachment (fp, a, pagerfile, MUTT_DISPLAY, 0))
       {
 	unset_option (OPTVIEWATTACH);
 	goto return_error;
@@ -576,7 +576,7 @@ int mutt_view_attachment (FILE *fp, BODY *a, int flag, HEADER *hdr,
     info.hdr = hdr;
 
     rc = mutt_do_pager (descrip, pagerfile,
-			M_PAGER_ATTACHMENT | (is_message ? M_PAGER_MESSAGE : 0), &info);
+			MUTT_PAGER_ATTACHMENT | (is_message ? MUTT_PAGER_MESSAGE : 0), &info);
     *pagerfile = '\0';
   }
   else
@@ -691,9 +691,9 @@ bail:
 static FILE *
 mutt_save_attachment_open (char *path, int flags)
 {
-  if (flags == M_SAVE_APPEND)
+  if (flags == MUTT_SAVE_APPEND)
     return fopen (path, "a");
-  if (flags == M_SAVE_OVERWRITE)
+  if (flags == MUTT_SAVE_OVERWRITE)
     return fopen (path, "w");		/* __FOPEN_CHECKED__ */
   
   return safe_fopen (path, "w");
@@ -729,16 +729,16 @@ int mutt_save_attachment (FILE *fp, BODY *m, char *path, int flags, HEADER *hdr)
       fseeko (fp, m->offset, 0);
       if (fgets (buf, sizeof (buf), fp) == NULL)
 	return -1;
-      if (mx_open_mailbox(path, M_APPEND | M_QUIET, &ctx) == NULL)
+      if (mx_open_mailbox(path, MUTT_APPEND | MUTT_QUIET, &ctx) == NULL)
 	return -1;
-      if ((msg = mx_open_new_message (&ctx, hn, is_from (buf, NULL, 0, NULL) ? 0 : M_ADD_FROM)) == NULL)
+      if ((msg = mx_open_new_message (&ctx, hn, is_from (buf, NULL, 0, NULL) ? 0 : MUTT_ADD_FROM)) == NULL)
       {
 	mx_close_mailbox(&ctx, NULL);
 	return -1;
       }
-      if (ctx.magic == M_MBOX || ctx.magic == M_MMDF)
+      if (ctx.magic == MUTT_MBOX || ctx.magic == MUTT_MMDF)
 	chflags = CH_FROM | CH_UPDATE_LEN;
-      chflags |= (ctx.magic == M_MAILDIR ? CH_NOSTATUS : CH_UPDATE);
+      chflags |= (ctx.magic == MUTT_MAILDIR ? CH_NOSTATUS : CH_UPDATE);
       if (_mutt_copy_message (msg->fp, fp, hn, hn->content, 0, chflags) == 0 
 	  && mx_commit_message (msg, &ctx) == 0)
 	r = 0;
@@ -822,9 +822,9 @@ int mutt_decode_save_attachment (FILE *fp, BODY *m, char *path,
   memset (&s, 0, sizeof (s));
   s.flags = displaying;
 
-  if (flags == M_SAVE_APPEND)
+  if (flags == MUTT_SAVE_APPEND)
     s.fpout = fopen (path, "a");
-  else if (flags == M_SAVE_OVERWRITE)
+  else if (flags == MUTT_SAVE_OVERWRITE)
     s.fpout = fopen (path, "w");	/* __FOPEN_CHECKED__ */
   else
     s.fpout = safe_fopen (path, "w");
@@ -865,12 +865,12 @@ int mutt_decode_save_attachment (FILE *fp, BODY *m, char *path,
     mutt_parse_part (s.fpin, m);
 
     if (m->noconv || is_multipart (m))
-      s.flags |= M_CHARCONV;
+      s.flags |= MUTT_CHARCONV;
   }
   else
   {
     s.fpin = fp;
-    s.flags |= M_CHARCONV;
+    s.flags |= MUTT_CHARCONV;
   }
 
   mutt_body_handler (m, &s);
@@ -912,7 +912,7 @@ int mutt_print_attachment (FILE *fp, BODY *a)
   
   snprintf (type, sizeof (type), "%s/%s", TYPE (a), a->subtype);
 
-  if (rfc1524_mailcap_lookup (a, type, NULL, M_PRINT)) 
+  if (rfc1524_mailcap_lookup (a, type, NULL, MUTT_PRINT)) 
   {
     char command[_POSIX_PATH_MAX+STRING];
     rfc1524_entry *entry;
@@ -921,7 +921,7 @@ int mutt_print_attachment (FILE *fp, BODY *a)
     dprint (2, (debugfile, "Using mailcap...\n"));
     
     entry = rfc1524_new_entry ();
-    rfc1524_mailcap_lookup (a, type, entry, M_PRINT);
+    rfc1524_mailcap_lookup (a, type, entry, MUTT_PRINT);
     if (rfc1524_expand_filename (entry->nametemplate, a->filename,
 						  newfile, sizeof (newfile)))
     {
@@ -929,7 +929,7 @@ int mutt_print_attachment (FILE *fp, BODY *a)
       {
 	if (safe_symlink(a->filename, newfile) == -1)
 	{
-	  if (mutt_yesorno (_("Can't match nametemplate, continue?"), M_YES) != M_YES)
+	  if (mutt_yesorno (_("Can't match nametemplate, continue?"), MUTT_YES) != MUTT_YES)
 	  {
 	    rfc1524_free_entry (&entry);
 	    return 0;
@@ -1003,7 +1003,7 @@ int mutt_print_attachment (FILE *fp, BODY *a)
     fpout = NULL;
     
     mutt_mktemp (newfile, sizeof (newfile));
-    if (mutt_decode_save_attachment (fp, a, newfile, M_PRINTING, 0) == 0)
+    if (mutt_decode_save_attachment (fp, a, newfile, MUTT_PRINTING, 0) == 0)
     {
       
       dprint (2, (debugfile, "successfully decoded %s type attachment to %s\n",
diff --git a/browser.c b/browser.c
index 3185422..c46db6e 100644
--- a/browser.c
+++ b/browser.c
@@ -219,7 +219,7 @@ folder_format_str (char *dest, size_t destlen, size_t col, int cols, char op, co
   FOLDER *folder = (FOLDER *) data;
   struct passwd *pw;
   struct group *gr;
-  int optional = (flags & M_FORMAT_OPTIONAL);
+  int optional = (flags & MUTT_FORMAT_OPTIONAL);
 
   switch (op)
   {
@@ -412,7 +412,7 @@ folder_format_str (char *dest, size_t destlen, size_t col, int cols, char op, co
 
   if (optional)
     mutt_FormatString (dest, destlen, col, cols, ifstring, folder_format_str, data, 0);
-  else if (flags & M_FORMAT_OPTIONAL)
+  else if (flags & MUTT_FORMAT_OPTIONAL)
     mutt_FormatString (dest, destlen, col, cols, elsestring, folder_format_str, data, 0);
 
   return (src);
@@ -457,7 +457,7 @@ newsgroup_format_str (char *dest, size_t destlen, size_t col, int cols, char op,
       break;
 
     case 's':
-      if (flags & M_FORMAT_OPTIONAL)
+      if (flags & MUTT_FORMAT_OPTIONAL)
       {
 	if (folder->ff->nd->unread != 0)
 	  mutt_FormatString (dest, destlen, col, cols, ifstring, newsgroup_format_str,
@@ -503,7 +503,7 @@ newsgroup_format_str (char *dest, size_t destlen, size_t col, int cols, char op,
       {
 	char *buf = safe_strdup (folder->ff->nd->desc);
 	if (NewsgroupsCharset && *NewsgroupsCharset)
-	  mutt_convert_string (&buf, NewsgroupsCharset, Charset, M_ICONV_HOOK_FROM);
+	  mutt_convert_string (&buf, NewsgroupsCharset, Charset, MUTT_ICONV_HOOK_FROM);
 	mutt_filter_unprintable (&buf);
 
 	snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
@@ -815,11 +815,11 @@ static void folder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
 #ifdef USE_NNTP
   if (option (OPTNEWS))
     mutt_FormatString (s, slen, 0, MuttIndexWindow->cols, NONULL(GroupFormat), newsgroup_format_str, 
-      (unsigned long) &folder, M_FORMAT_ARROWCURSOR);
+      (unsigned long) &folder, MUTT_FORMAT_ARROWCURSOR);
   else
 #endif
   mutt_FormatString (s, slen, 0, MuttIndexWindow->cols, NONULL(FolderFormat), folder_format_str, 
-      (unsigned long) &folder, M_FORMAT_ARROWCURSOR);
+      (unsigned long) &folder, MUTT_FORMAT_ARROWCURSOR);
 }
 
 #ifdef USE_NOTMUCH
@@ -831,7 +831,7 @@ static void vfolder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
   folder.num = num;
 
   mutt_FormatString (s, slen, 0, MuttIndexWindow->cols, NONULL(VirtFolderFormat), folder_format_str,
-      (unsigned long) &folder, M_FORMAT_ARROWCURSOR);
+      (unsigned long) &folder, MUTT_FORMAT_ARROWCURSOR);
 }
 #endif
 
@@ -906,9 +906,9 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
   MUTTMENU *menu;
   struct stat st;
   int i, killPrefix = 0;
-  int multiple = (flags & M_SEL_MULTI)  ? 1 : 0;
-  int folder   = (flags & M_SEL_FOLDER) ? 1 : 0;
-  int buffy    = (flags & M_SEL_BUFFY)  ? 1 : 0;
+  int multiple = (flags & MUTT_SEL_MULTI)  ? 1 : 0;
+  int folder   = (flags & MUTT_SEL_FOLDER) ? 1 : 0;
+  int buffy    = (flags & MUTT_SEL_BUFFY)  ? 1 : 0;
 
   buffy = buffy && folder;
 
@@ -990,7 +990,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 #endif
   }
 #ifdef USE_NOTMUCH
-  else if (!(flags & M_SEL_VFOLDER))
+  else if (!(flags & MUTT_SEL_VFOLDER))
 #else
   else
 #endif
@@ -1022,7 +1022,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
   *f = 0;
 
 #ifdef USE_NOTMUCH
-  if (flags & M_SEL_VFOLDER) {
+  if (flags & MUTT_SEL_VFOLDER) {
     if (examine_vfolders (NULL, &state) == -1)
       goto bail;
   } else
@@ -1048,7 +1048,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
     menu->tag = file_tag;
 
 #ifdef USE_NOTMUCH
-  if (flags & M_SEL_VFOLDER) {
+  if (flags & MUTT_SEL_VFOLDER) {
     menu->make_entry = vfolder_entry;
     menu->search = select_vfolder_search;
   } else
@@ -1337,7 +1337,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	  }
 	  snprintf (msg, sizeof (msg), _("Really delete mailbox \"%s\"?"),
             mx.mbox);
-	  if (mutt_yesorno (msg, M_NO) == M_YES)
+	  if (mutt_yesorno (msg, MUTT_NO) == MUTT_YES)
           {
 	    if (!imap_delete_mailbox (Context, mx))
             {
@@ -1379,7 +1379,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	    buf[len]='/';
 	}
 
-	if (mutt_get_field (_("Chdir to: "), buf, sizeof (buf), M_FILE) == 0 &&
+	if (mutt_get_field (_("Chdir to: "), buf, sizeof (buf), MUTT_FILE) == 0 &&
 	    buf[0])
 	{
 	  buffy = 0;	  
@@ -1595,7 +1595,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
       case OP_BROWSER_NEW_FILE:
 
 	snprintf (buf, sizeof (buf), "%s/", LastDir);
-	if (mutt_get_field (_("New file name: "), buf, sizeof (buf), M_FILE) == 0)
+	if (mutt_get_field (_("New file name: "), buf, sizeof (buf), MUTT_FILE) == 0)
 	{
 	  strfcpy (f, buf, flen);
 	  destroy_state (&state);
@@ -1638,7 +1638,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	  b = mutt_make_file_attach (buf);
 	  if (b != NULL)
 	  {
-	    mutt_view_attachment (NULL, b, M_REGULAR, NULL, NULL, 0);
+	    mutt_view_attachment (NULL, b, MUTT_REGULAR, NULL, NULL, 0);
 	    mutt_free_body (&b);
 	    menu->redraw = REDRAW_FULL;
 	  }
@@ -1679,7 +1679,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	    FREE (&f->desc);
 	    mutt_FormatString (buffer, sizeof (buffer), 0, NONULL(GroupFormat),
 		  newsgroup_format_str, (unsigned long) &folder,
-		  M_FORMAT_ARROWCURSOR);
+		  MUTT_FORMAT_ARROWCURSOR);
 	    f->desc = safe_strdup (buffer); */
 	    nntp_newsrc_update (CurrentNewsSrv);
 	    if (menu->current + 1 < menu->max)
@@ -1797,7 +1797,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 		FREE (&f->desc);
 		mutt_FormatString (buffer, sizeof (buffer), 0, NONULL(GroupFormat),
 			newsgroup_format_str, (unsigned long) &folder,
-			M_FORMAT_ARROWCURSOR);
+			MUTT_FORMAT_ARROWCURSOR);
 		f->desc = safe_strdup (buffer);
 	      } */
 	    }
diff --git a/buffy.c b/buffy.c
index 5bec109..9de77dd 100644
--- a/buffy.c
+++ b/buffy.c
@@ -132,7 +132,7 @@ static int test_new_folder (const char *path)
 
   typ = mx_get_magic (path);
 
-  if (typ != M_MBOX && typ != M_MMDF)
+  if (typ != MUTT_MBOX && typ != MUTT_MMDF)
     return 0;
 
   if ((f = fopen (path, "rb")))
@@ -244,7 +244,7 @@ int mutt_parse_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *e
     mutt_extract_token (path, s, 0);
     strfcpy (buf, path->data, sizeof (buf));
 
-    if(data == M_UNMAILBOXES && mutt_strcmp(buf,"*") == 0)
+    if(data == MUTT_UNMAILBOXES && mutt_strcmp(buf,"*") == 0)
     {
       for (tmp = &Incoming; *tmp;)
       {
@@ -280,7 +280,7 @@ int mutt_parse_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *e
       }
     }
 
-    if(data == M_UNMAILBOXES)
+    if(data == MUTT_UNMAILBOXES)
     {
       if(*tmp)
       {
@@ -586,7 +586,7 @@ buffy_mbox_update (BUFFY *mailbox, struct stat *sb)
 	if ((mailbox->sb_last_checked > sb->st_mtime) && (mailbox->msg_count != 0))
 		return; /* no check necessary */
 
-	ctx = mx_open_mailbox (mailbox->path, M_READONLY | M_QUIET | M_NOSORT | M_PEEK, NULL);
+	ctx = mx_open_mailbox (mailbox->path, MUTT_READONLY | MUTT_QUIET | MUTT_NOSORT | MUTT_PEEK, NULL);
 	if (ctx) {
 		mailbox->msg_count       = ctx->msgcount;
 		mailbox->msg_unread      = ctx->unread;
@@ -607,22 +607,22 @@ static void buffy_check(BUFFY *tmp, struct stat *contex_sb)
 
     sb.st_size=0;
 
-    if (tmp->magic != M_IMAP)
+    if (tmp->magic != MUTT_IMAP)
     {
       tmp->new = 0;
 #ifdef USE_POP
       if (mx_is_pop (tmp->path))
-	tmp->magic = M_POP;
+	tmp->magic = MUTT_POP;
       else
 #endif
 #ifdef USE_NOTMUCH
       if (mx_is_notmuch (tmp->path))
-	tmp->magic = M_NOTMUCH;
+	tmp->magic = MUTT_NOTMUCH;
       else
 #endif
 #ifdef USE_NNTP
-      if ((tmp->magic == M_NNTP) || mx_is_nntp (tmp->path))
-	tmp->magic = M_NNTP;
+      if ((tmp->magic == MUTT_NNTP) || mx_is_nntp (tmp->path))
+	tmp->magic = MUTT_NNTP;
       else
 #endif
       if (stat (tmp->path, &sb) != 0 || (S_ISREG(sb.st_mode) && sb.st_size == 0) ||
@@ -641,17 +641,17 @@ static void buffy_check(BUFFY *tmp, struct stat *contex_sb)
      * before polling */
     if (!Context || !Context->path ||
 #ifdef USE_NNTP
-	(( tmp->magic == M_IMAP || tmp->magic == M_POP || tmp->magic == M_NNTP )
+	(( tmp->magic == MUTT_IMAP || tmp->magic == MUTT_POP || tmp->magic == MUTT_NNTP )
 #else
-	(( tmp->magic == M_IMAP || tmp->magic == M_POP || tmp->magic == M_NOTMUCH)
+	(( tmp->magic == MUTT_IMAP || tmp->magic == MUTT_POP || tmp->magic == MUTT_NOTMUCH)
 #endif
 	    ? mutt_strcmp (tmp->path, Context->path) :
 	      (sb.st_dev != contex_sb->st_dev || sb.st_ino != contex_sb->st_ino)))
     {
       switch (tmp->magic)
       {
-      case M_MBOX:
-      case M_MMDF:
+      case MUTT_MBOX:
+      case MUTT_MMDF:
 #ifdef USE_SIDEBAR
 	if (option(OPTSIDEBAR))
 	  buffy_mbox_update (tmp, &sb);
@@ -660,7 +660,7 @@ static void buffy_check(BUFFY *tmp, struct stat *contex_sb)
 	  BuffyCount++;
 	break;
 
-      case M_MAILDIR:
+      case MUTT_MAILDIR:
 #ifdef USE_SIDEBAR
 	if (option(OPTSIDEBAR))
 	  buffy_maildir_update (tmp);
@@ -669,7 +669,7 @@ static void buffy_check(BUFFY *tmp, struct stat *contex_sb)
 	  BuffyCount++;
 	break;
 
-      case M_MH:
+      case MUTT_MH:
 #ifdef USE_SIDEBAR
 	if (option(OPTSIDEBAR))
 	  mh_buffy_update (tmp);
@@ -679,7 +679,7 @@ static void buffy_check(BUFFY *tmp, struct stat *contex_sb)
 	  BuffyCount++;
 	break;
 #ifdef USE_NOTMUCH
-      case M_NOTMUCH:
+      case MUTT_NOTMUCH:
 	tmp->msg_count = 0;
 	tmp->msg_unread = 0;
 	tmp->msg_flagged = 0;
@@ -740,9 +740,9 @@ int mutt_buffy_check (int force)
 #endif
 
   /* check device ID and serial number instead of comparing paths */
-  if (!Context || Context->magic == M_IMAP || Context->magic == M_POP
+  if (!Context || Context->magic == MUTT_IMAP || Context->magic == MUTT_POP
 #ifdef USE_NNTP
-      || Context->magic == M_NNTP
+      || Context->magic == MUTT_NNTP
 #endif
       || stat (Context->path, &contex_sb) != 0)
   {
diff --git a/buffy.h b/buffy.h
index 295a9e9..8b36534 100644
--- a/buffy.h
+++ b/buffy.h
@@ -20,8 +20,8 @@
 #define _BUFFY_H
 
 /*parameter to mutt_parse_mailboxes*/
-#define M_MAILBOXES   1
-#define M_UNMAILBOXES 2 
+#define MUTT_MAILBOXES   1
+#define MUTT_UNMAILBOXES 2 
 
 typedef struct buffy_t
 {
diff --git a/charset.c b/charset.c
index c66e6b2..2411f2c 100644
--- a/charset.c
+++ b/charset.c
@@ -349,15 +349,15 @@ int iconv_close (iconv_t cd)
 /*
  * Like iconv_open, but canonicalises the charsets, applies
  * charset-hooks, recanonicalises, and finally applies iconv-hooks.
- * Parameter flags=0 skips charset-hooks, while M_ICONV_HOOK_FROM
+ * Parameter flags=0 skips charset-hooks, while MUTT_ICONV_HOOK_FROM
  * applies them to fromcode. Callers should use flags=0 when fromcode
  * can safely be considered true, either some constant, or some value
- * provided by the user; M_ICONV_HOOK_FROM should be used only when
+ * provided by the user; MUTT_ICONV_HOOK_FROM should be used only when
  * fromcode is unsure, taken from a possibly wrong incoming MIME label,
- * or such. Misusing M_ICONV_HOOK_FROM leads to unwanted interactions
+ * or such. Misusing MUTT_ICONV_HOOK_FROM leads to unwanted interactions
  * in some setups. Note: By design charset-hooks should never be, and
  * are never, applied to tocode. Highlight note: The top-well-named
- * M_ICONV_HOOK_FROM acts on charset-hooks, not at all on iconv-hooks.
+ * MUTT_ICONV_HOOK_FROM acts on charset-hooks, not at all on iconv-hooks.
  */
 
 iconv_t mutt_iconv_open (const char *tocode, const char *fromcode, int flags)
@@ -376,7 +376,7 @@ iconv_t mutt_iconv_open (const char *tocode, const char *fromcode, int flags)
   /* maybe apply charset-hooks and recanonicalise fromcode,
    * but only when caller asked us to sanitize a potentialy wrong
    * charset name incoming from the wild exterior. */
-  if ((flags & M_ICONV_HOOK_FROM) && (tmp = mutt_charset_hook (fromcode1)))
+  if ((flags & MUTT_ICONV_HOOK_FROM) && (tmp = mutt_charset_hook (fromcode1)))
     mutt_canonical_charset (fromcode1, sizeof (fromcode1), tmp);
 
   /* always apply iconv-hooks to suit system's iconv tastes */
diff --git a/charset.h b/charset.h
index e52ce38..54891f0 100644
--- a/charset.h
+++ b/charset.h
@@ -51,10 +51,10 @@ char *mutt_get_default_charset (void);
 
 /* flags for charset.c:mutt_convert_string(), fgetconv_open(), and
  * mutt_iconv_open(). Note that applying charset-hooks to tocode is
- * never needed, and sometimes hurts: Hence there is no M_ICONV_HOOK_TO
+ * never needed, and sometimes hurts: Hence there is no MUTT_ICONV_HOOK_TO
  * flag.
  */
-#define M_ICONV_HOOK_FROM 1	/* apply charset-hooks to fromcode */
+#define MUTT_ICONV_HOOK_FROM 1	/* apply charset-hooks to fromcode */
 
 /* Check if given character set is valid (either officially assigned or
  * known to local iconv implementation). If strict is non-zero, check
diff --git a/color.c b/color.c
index 54c944f..04d12ca 100644
--- a/color.c
+++ b/color.c
@@ -601,7 +601,7 @@ add_pattern (COLOR_LINE **top, const char *s, int sensitive,
 
       strfcpy(buf, NONULL(s), sizeof(buf));
       mutt_check_simple (buf, sizeof (buf), NONULL(SimpleSearch));
-      if((tmp->color_pattern = mutt_pattern_comp (buf, M_FULL_MSG, err)) == NULL)
+      if((tmp->color_pattern = mutt_pattern_comp (buf, MUTT_FULL_MSG, err)) == NULL)
       {
 	mutt_free_color_line(&tmp, 1);
 	return -1;
diff --git a/commands.c b/commands.c
index 191b4be..39f307d 100644
--- a/commands.c
+++ b/commands.c
@@ -64,7 +64,7 @@ int mutt_display_message (HEADER *cur)
 {
   char tempfile[_POSIX_PATH_MAX], buf[LONG_STRING];
   int rc = 0, builtin = 0;
-  int cmflags = M_CM_DECODE | M_CM_DISPLAY | M_CM_CHARCONV;
+  int cmflags = MUTT_CM_DECODE | MUTT_CM_DISPLAY | MUTT_CM_CHARCONV;
   FILE *fpout = NULL;
   FILE *fpfilterout = NULL;
   pid_t filterpid = -1;
@@ -74,7 +74,7 @@ int mutt_display_message (HEADER *cur)
 	    cur->content->subtype);
 
   mutt_parse_mime_message (Context, cur);
-  mutt_message_hook (Context, cur, M_MESSAGEHOOK);
+  mutt_message_hook (Context, cur, MUTT_MESSAGEHOOK);
 
   /* see if crypto is needed for this message.  if so, we should exit curses */
   if (WithCrypto && cur->security)
@@ -86,19 +86,19 @@ int mutt_display_message (HEADER *cur)
       if(!crypt_valid_passphrase(cur->security))
 	return 0;
 
-      cmflags |= M_CM_VERIFY;
+      cmflags |= MUTT_CM_VERIFY;
     }
     else if (cur->security & SIGN)
     {
       /* find out whether or not the verify signature */
-      if (query_quadoption (OPT_VERIFYSIG, _("Verify PGP signature?")) == M_YES)
+      if (query_quadoption (OPT_VERIFYSIG, _("Verify PGP signature?")) == MUTT_YES)
       {
-	cmflags |= M_CM_VERIFY;
+	cmflags |= MUTT_CM_VERIFY;
       }
     }
   }
   
-  if (cmflags & M_CM_VERIFY || cur->security & ENCRYPT)
+  if (cmflags & MUTT_CM_VERIFY || cur->security & ENCRYPT)
   {
     if (cur->security & APPLICATION_PGP)
     {
@@ -144,7 +144,7 @@ int mutt_display_message (HEADER *cur)
     hfi.ctx = Context;
     hfi.pager_progress = ExtPagerProgress;
     hfi.hdr = cur;
-    mutt_make_string_info (buf, sizeof (buf), NONULL(PagerFmt), &hfi, M_FORMAT_MAKEPRINT);
+    mutt_make_string_info (buf, sizeof (buf), NONULL(PagerFmt), &hfi, MUTT_FORMAT_MAKEPRINT);
     fputs (buf, fpout);
     fputs ("\n\n", fpout);
   }
@@ -187,7 +187,7 @@ int mutt_display_message (HEADER *cur)
     pager_t info;
 
     if (WithCrypto 
-        && (cur->security & APPLICATION_SMIME) && (cmflags & M_CM_VERIFY))
+        && (cur->security & APPLICATION_SMIME) && (cmflags & MUTT_CM_VERIFY))
     {
       if (cur->security & GOODSIGN)
       {
@@ -203,7 +203,7 @@ int mutt_display_message (HEADER *cur)
     }
 
     if (WithCrypto 
-        && (cur->security & APPLICATION_PGP) && (cmflags & M_CM_VERIFY))
+        && (cur->security & APPLICATION_PGP) && (cmflags & MUTT_CM_VERIFY))
     {
       if (cur->security & GOODSIGN)
 	mutt_message (_("PGP signature successfully verified."));
@@ -217,7 +217,7 @@ int mutt_display_message (HEADER *cur)
     memset (&info, 0, sizeof (pager_t));
     info.hdr = cur;
     info.ctx = Context;
-    rc = mutt_pager (NULL, tempfile, M_PAGER_MESSAGE, &info);
+    rc = mutt_pager (NULL, tempfile, MUTT_PAGER_MESSAGE, &info);
   }
   else
   {
@@ -231,7 +231,7 @@ int mutt_display_message (HEADER *cur)
     if (!option (OPTNOCURSES))
       keypad (stdscr, TRUE);
     if (r != -1)
-      mutt_set_flag (Context, cur, M_READ, 1);
+      mutt_set_flag (Context, cur, MUTT_READ, 1);
     if (r != -1 && option (OPTPROMPTAFTER))
     {
       mutt_unget_event (mutt_any_key_to_continue _("Command: "), 0);
@@ -281,7 +281,7 @@ void ci_bounce_message (HEADER *h, int *redraw)
   else
     strfcpy(prompt, _("Bounce tagged messages to: "), sizeof(prompt));
   
-  rc = mutt_get_field (prompt, buf, sizeof (buf), M_ALIAS);
+  rc = mutt_get_field (prompt, buf, sizeof (buf), MUTT_ALIAS);
 
   if (option (OPTNEEDREDRAW))
   {
@@ -325,7 +325,7 @@ void ci_bounce_message (HEADER *h, int *redraw)
   else
     snprintf (prompt, sizeof (prompt), "%s?", scratch);
 
-  if (query_quadoption (OPT_BOUNCE, prompt) != M_YES)
+  if (query_quadoption (OPT_BOUNCE, prompt) != MUTT_YES)
   {
     rfc822_free_address (&adr);
     mutt_window_clearline (MuttMessageWindow, 0);
@@ -346,18 +346,18 @@ static void pipe_set_flags (int decode, int print, int *cmflags, int *chflags)
 {
   if (decode)
   {
-    *cmflags |= M_CM_DECODE | M_CM_CHARCONV;
+    *cmflags |= MUTT_CM_DECODE | MUTT_CM_CHARCONV;
     *chflags |= CH_DECODE | CH_REORDER;
     
     if (option (OPTWEED))
     {
       *chflags |= CH_WEED;
-      *cmflags |= M_CM_WEED;
+      *cmflags |= MUTT_CM_WEED;
     }
   }
   
   if (print)
-    *cmflags |= M_CM_PRINTING;
+    *cmflags |= MUTT_CM_PRINTING;
   
 }
 
@@ -404,7 +404,7 @@ static int _mutt_pipe_message (HEADER *h, char *cmd,
   if (h)
   {
 
-    mutt_message_hook (Context, h, M_MESSAGEHOOK);
+    mutt_message_hook (Context, h, MUTT_MESSAGEHOOK);
 
     if (WithCrypto && decode)
     {
@@ -432,7 +432,7 @@ static int _mutt_pipe_message (HEADER *h, char *cmd,
       for (i = 0; i < Context->vcount; i++)
 	if(Context->hdrs[Context->v2r[i]]->tagged)
 	{
-	  mutt_message_hook (Context, Context->hdrs[Context->v2r[i]], M_MESSAGEHOOK);
+	  mutt_message_hook (Context, Context->hdrs[Context->v2r[i]], MUTT_MESSAGEHOOK);
 	  mutt_parse_mime_message(Context, Context->hdrs[Context->v2r[i]]);
 	  if (Context->hdrs[Context->v2r[i]]->security & ENCRYPT &&
 	      !crypt_valid_passphrase(Context->hdrs[Context->v2r[i]]->security))
@@ -446,7 +446,7 @@ static int _mutt_pipe_message (HEADER *h, char *cmd,
       {
         if (Context->hdrs[Context->v2r[i]]->tagged)
         {
-	  mutt_message_hook (Context, Context->hdrs[Context->v2r[i]], M_MESSAGEHOOK);
+	  mutt_message_hook (Context, Context->hdrs[Context->v2r[i]], MUTT_MESSAGEHOOK);
 	  mutt_endwin (NULL);
 	  if ((thepid = mutt_create_filter (cmd, &fpout, NULL, NULL)) < 0)
 	  {
@@ -474,7 +474,7 @@ static int _mutt_pipe_message (HEADER *h, char *cmd,
       {
         if (Context->hdrs[Context->v2r[i]]->tagged)
         {
-	  mutt_message_hook (Context, Context->hdrs[Context->v2r[i]], M_MESSAGEHOOK);
+	  mutt_message_hook (Context, Context->hdrs[Context->v2r[i]], MUTT_MESSAGEHOOK);
           pipe_msg (Context->hdrs[Context->v2r[i]], fpout, decode, print);
           /* add the message separator */
           if (sep) fputs (sep, fpout);
@@ -496,7 +496,7 @@ void mutt_pipe_message (HEADER *h)
   char buffer[LONG_STRING];
 
   buffer[0] = 0;
-  if (mutt_get_field (_("Pipe to command: "), buffer, sizeof (buffer), M_CMD)
+  if (mutt_get_field (_("Pipe to command: "), buffer, sizeof (buffer), MUTT_CMD)
       != 0 || !buffer[0])
     return;
 
@@ -519,7 +519,7 @@ void mutt_print_message (HEADER *h)
   
   if (query_quadoption (OPT_PRINT,
 			h ? _("Print message?") : _("Print tagged messages?"))
-		  	!= M_YES)
+		  	!= MUTT_YES)
     return;
 
   if (_mutt_pipe_message (h, PrintCmd,
@@ -602,7 +602,7 @@ void mutt_shell_escape (void)
   char buf[LONG_STRING];
 
   buf[0] = 0;
-  if (mutt_get_field (_("Shell command: "), buf, sizeof (buf), M_CMD) == 0)
+  if (mutt_get_field (_("Shell command: "), buf, sizeof (buf), MUTT_CMD) == 0)
   {
     if (!buf[0] && Shell)
       strfcpy (buf, Shell, sizeof (buf));
@@ -625,7 +625,7 @@ void mutt_enter_command (void)
   int r;
 
   buffer[0] = 0;
-  if (mutt_get_field (":", buffer, sizeof (buffer), M_COMMAND) != 0 || !buffer[0])
+  if (mutt_get_field (":", buffer, sizeof (buffer), MUTT_COMMAND) != 0 || !buffer[0])
     return;
   mutt_buffer_init (&err);
   err.dsize = STRING;
@@ -680,7 +680,7 @@ static void set_copy_flags (HEADER *hdr, int decode, int decrypt, int *cmflags,
         && mutt_is_multipart_encrypted(hdr->content))
     {
       *chflags = CH_NONEWLINE | CH_XMIT | CH_MIME;
-      *cmflags = M_CM_DECODE_PGP;
+      *cmflags = MUTT_CM_DECODE_PGP;
     }
     else if ((WithCrypto & APPLICATION_PGP)
               && mutt_is_application_pgp (hdr->content) & ENCRYPT)
@@ -689,14 +689,14 @@ static void set_copy_flags (HEADER *hdr, int decode, int decrypt, int *cmflags,
              && mutt_is_application_smime(hdr->content) & ENCRYPT)
     {
       *chflags = CH_NONEWLINE | CH_XMIT | CH_MIME;
-      *cmflags = M_CM_DECODE_SMIME;
+      *cmflags = MUTT_CM_DECODE_SMIME;
     }
   }
 
   if (decode)
   {
     *chflags = CH_XMIT | CH_MIME | CH_TXTPLAIN;
-    *cmflags = M_CM_DECODE | M_CM_CHARCONV;
+    *cmflags = MUTT_CM_DECODE | MUTT_CM_CHARCONV;
 
     if (!decrypt)	/* If decode doesn't kick in for decrypt, */
     {
@@ -705,7 +705,7 @@ static void set_copy_flags (HEADER *hdr, int decode, int decrypt, int *cmflags,
       if (option (OPTWEED))
       {
 	*chflags |= CH_WEED;	/* and respect $weed. */
-	*cmflags |= M_CM_WEED;
+	*cmflags |= MUTT_CM_WEED;
       }
     }
   }
@@ -726,11 +726,11 @@ int _mutt_save_message (HEADER *h, CONTEXT *ctx, int delete, int decode, int dec
 
   if (delete)
   {
-    mutt_set_flag (Context, h, M_DELETE, 1);
+    mutt_set_flag (Context, h, MUTT_DELETE, 1);
     if (option (OPTDELETEUNTAG))
-      mutt_set_flag (Context, h, M_TAG, 0);
+      mutt_set_flag (Context, h, MUTT_TAG, 0);
   }
-  mutt_set_flag (Context, h, M_APPENDED, 1);
+  mutt_set_flag (Context, h, MUTT_APPENDED, 1);
   
   return 0;
 }
@@ -764,7 +764,7 @@ int mutt_save_message (HEADER *h, int delete,
       need_passphrase = h->security & ENCRYPT;
       app = h->security;
     }
-    mutt_message_hook (Context, h, M_MESSAGEHOOK);
+    mutt_message_hook (Context, h, MUTT_MESSAGEHOOK);
     mutt_default_save (buf, sizeof (buf), h);
   }
   else
@@ -783,7 +783,7 @@ int mutt_save_message (HEADER *h, int delete,
 
     if (h)
     {
-      mutt_message_hook (Context, h, M_MESSAGEHOOK);
+      mutt_message_hook (Context, h, MUTT_MESSAGEHOOK);
       mutt_default_save (buf, sizeof (buf), h);
       if (WithCrypto)
       {
@@ -830,7 +830,7 @@ int mutt_save_message (HEADER *h, int delete,
   mutt_message (_("Copying to %s..."), buf);
   
 #ifdef USE_IMAP
-  if (Context->magic == M_IMAP && 
+  if (Context->magic == MUTT_IMAP && 
       !(decode || decrypt) && mx_is_imap (buf))
   {
     switch (imap_copy_messages (Context, h, buf, delete))
@@ -845,7 +845,7 @@ int mutt_save_message (HEADER *h, int delete,
   }
 #endif
 
-  if (mx_open_mailbox (buf, M_APPEND, &ctx) != NULL)
+  if (mx_open_mailbox (buf, MUTT_APPEND, &ctx) != NULL)
   {
     if (h)
     {
@@ -860,21 +860,24 @@ int mutt_save_message (HEADER *h, int delete,
       int rc = 0;
 
 #ifdef USE_NOTMUCH
-      if (Context->magic == M_NOTMUCH)
+      if (Context->magic == MUTT_NOTMUCH)
         nm_longrun_init(Context, TRUE);
 #endif
       for (i = 0; i < Context->vcount; i++)
       {
 	if (Context->hdrs[Context->v2r[i]]->tagged)
 	{
-	  mutt_message_hook (Context, Context->hdrs[Context->v2r[i]], M_MESSAGEHOOK);
-	  if ((rc = _mutt_save_message(Context->hdrs[Context->v2r[i]],
-			     &ctx, delete, decode, decrypt) != 0))
-	    break;
+	  mutt_message_hook (Context, Context->hdrs[Context->v2r[i]], MUTT_MESSAGEHOOK);
+	  if (_mutt_save_message(Context->hdrs[Context->v2r[i]],
+			     &ctx, delete, decode, decrypt) != 0)
+          {
+            mx_close_mailbox (&ctx, NULL);
+            return -1;
+          }
 	}
       }
 #ifdef USE_NOTMUCH
-      if (Context->magic == M_NOTMUCH)
+      if (Context->magic == MUTT_NOTMUCH)
         nm_longrun_done(Context);
 #endif
       if (rc != 0) {
@@ -883,7 +886,7 @@ int mutt_save_message (HEADER *h, int delete,
       }
     }
 
-    need_buffy_cleanup = (ctx.magic == M_MBOX || ctx.magic == M_MMDF);
+    need_buffy_cleanup = (ctx.magic == MUTT_MBOX || ctx.magic == MUTT_MMDF);
 
     mx_close_mailbox (&ctx, NULL);
 
@@ -957,7 +960,7 @@ void mutt_edit_content_type (HEADER *h, BODY *b, FILE *fp)
     snprintf (tmp, sizeof (tmp), _("Convert to %s upon sending?"),
 	      mutt_get_parameter ("charset", b->parameter));
     if ((r = mutt_yesorno (tmp, !b->noconv)) != -1)
-      b->noconv = (r == M_NO);
+      b->noconv = (r == MUTT_NO);
   }
 
   /* inform the user */
diff --git a/compose.c b/compose.c
index 006af0e..e42c840 100644
--- a/compose.c
+++ b/compose.c
@@ -138,7 +138,7 @@ static void snd_entry (char *b, size_t blen, MUTTMENU *menu, int num)
 {
   mutt_FormatString (b, blen, 0, MuttIndexWindow->cols, NONULL (AttachFormat), mutt_attach_fmt,
 	    (unsigned long)(((ATTACHPTR **) menu->data)[num]),
-	    M_FORMAT_STAT_FILE | M_FORMAT_ARROWCURSOR);
+	    MUTT_FORMAT_STAT_FILE | MUTT_FORMAT_ARROWCURSOR);
 }
 
 
@@ -271,7 +271,7 @@ check_attachments(ATTACHPTR **idx, short idxlen)
       snprintf(msg, sizeof(msg), _("%s [#%d] modified. Update encoding?"),
 	       pretty, i+1);
       
-      if((r = mutt_yesorno(msg, M_YES)) == M_YES)
+      if((r = mutt_yesorno(msg, MUTT_YES)) == MUTT_YES)
 	mutt_update_encoding(idx[i]->content);
       else if(r == -1)
 	return -1;
@@ -346,7 +346,7 @@ static int edit_address_list (int line, ADDRESS **addr)
   
   mutt_addrlist_to_local (*addr);
   rfc822_write_address (buf, sizeof (buf), *addr, 0);
-  if (mutt_get_field (Prompts[line], buf, sizeof (buf), M_ALIAS) == 0)
+  if (mutt_get_field (Prompts[line], buf, sizeof (buf), MUTT_ALIAS) == 0)
   {
     rfc822_free_address (addr);
     *addr = mutt_parse_adrlist (*addr, buf);
@@ -491,7 +491,7 @@ compose_format_str (char *buf, size_t buflen, size_t col, int cols, char op, con
 		   unsigned long data, format_flag flags)
 {
   char fmt[SHORT_STRING], tmp[SHORT_STRING];
-  int optional = (flags & M_FORMAT_OPTIONAL);
+  int optional = (flags & MUTT_FORMAT_OPTIONAL);
   MUTTMENU *menu = (MUTTMENU *) data;
 
   *buf = 0;
@@ -529,7 +529,7 @@ compose_format_str (char *buf, size_t buflen, size_t col, int cols, char op, con
 
   if (optional)
     compose_status_line (buf, buflen, col, cols, menu, ifstring);
-  else if (flags & M_FORMAT_OPTIONAL)
+  else if (flags & MUTT_FORMAT_OPTIONAL)
     compose_status_line (buf, buflen, col, cols, menu, elsestring);
 
   return (src);
@@ -608,7 +608,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	break;
       case OP_COMPOSE_EDIT_FROM:
 	menu->redraw = edit_address_list (HDR_FROM, &msg->env->from);
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
 	break;
       case OP_COMPOSE_EDIT_TO:
 #ifdef USE_NNTP
@@ -621,7 +621,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  crypt_opportunistic_encrypt (msg);
 	  redraw_crypt_lines (msg);
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
       case OP_COMPOSE_EDIT_BCC:
 #ifdef USE_NNTP
@@ -634,7 +634,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  crypt_opportunistic_encrypt (msg);
 	  redraw_crypt_lines (msg);
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
 	break;
       case OP_COMPOSE_EDIT_CC:
 #ifdef USE_NNTP
@@ -647,7 +647,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  crypt_opportunistic_encrypt (msg);
 	  redraw_crypt_lines (msg);
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);	
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);	
         break;
 #ifdef USE_NNTP
       case OP_COMPOSE_EDIT_NEWSGROUPS:
@@ -719,15 +719,15 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  else
 	    mutt_window_clrtoeol(MuttIndexWindow);
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
       case OP_COMPOSE_EDIT_REPLY_TO:
 	menu->redraw = edit_address_list (HDR_REPLYTO, &msg->env->reply_to);
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
 	break;
       case OP_COMPOSE_EDIT_FCC:
 	strfcpy (buf, fcc, sizeof (buf));
-	if (mutt_get_field ("Fcc: ", buf, sizeof (buf), M_FILE | M_CLEAR) == 0)
+	if (mutt_get_field ("Fcc: ", buf, sizeof (buf), MUTT_FILE | MUTT_CLEAR) == 0)
 	{
 	  strfcpy (fcc, buf, fcclen);
 	  mutt_pretty_mailbox (fcc, fcclen);
@@ -736,7 +736,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  fccSet = 1;
 	}
 	MAYBE_REDRAW (menu->redraw);
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
       case OP_COMPOSE_EDIT_MESSAGE:
 	if (Editor && (mutt_strcmp ("builtin", Editor) != 0) && !option (OPTEDITHDRS))
@@ -744,7 +744,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  mutt_edit_file (Editor, msg->content->filename);
 	  mutt_update_encoding (msg->content);
 	  menu->redraw = REDRAW_FULL;
-	  mutt_message_hook (NULL, msg, M_SEND2HOOK);
+	  mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
 	  break;
 	}
 	/* fall through */
@@ -790,7 +790,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	}
 
         menu->redraw = REDRAW_FULL;
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
 	break;
 
 
@@ -821,7 +821,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  unset_option(OPTNEEDREDRAW);
 	}
 	
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
 
 
@@ -870,7 +870,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 
 	  menu->redraw |= REDRAW_INDEX | REDRAW_STATUS;
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
 
       case OP_COMPOSE_ATTACH_MESSAGE:
@@ -898,7 +898,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 
 	  if (Context)
 #ifdef USE_NNTP
-	  if ((op == OP_COMPOSE_ATTACH_MESSAGE) ^ (Context->magic == M_NNTP))
+	  if ((op == OP_COMPOSE_ATTACH_MESSAGE) ^ (Context->magic == MUTT_NNTP))
 #endif
 	  {
 	    strfcpy (fname, NONULL (Context->path), sizeof (fname));
@@ -932,7 +932,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 
 	  menu->redraw = REDRAW_FULL;
 
-	  ctx = mx_open_mailbox (fname, M_READONLY, NULL);
+	  ctx = mx_open_mailbox (fname, MUTT_READONLY, NULL);
 	  if (ctx == NULL)
 	  {
 	    mutt_error (_("Unable to open mailbox %s"), fname);
@@ -1003,7 +1003,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  Sort = oldSort;
 	  SortAux = oldSortAux;
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
 
       case OP_DELETE:
@@ -1025,7 +1025,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  msg->content = idx[0]->content;
 
         menu->redraw |= REDRAW_STATUS;
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
 
 #define CURRENT idx[menu->current]->content
@@ -1044,7 +1044,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
         else
 	  mutt_message (_("The current attachment will be converted."));
 	menu->redraw = REDRAW_CURRENT;
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
       }
 #undef CURRENT
@@ -1061,7 +1061,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  mutt_str_replace (&idx[menu->current]->content->description, buf);
 	  menu->redraw = REDRAW_CURRENT;
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
 
       case OP_COMPOSE_UPDATE_ENCODING:
@@ -1081,7 +1081,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
           mutt_update_encoding(idx[menu->current]->content);
 	  menu->redraw = REDRAW_CURRENT | REDRAW_STATUS;
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
       
       case OP_COMPOSE_TOGGLE_DISPOSITION:
@@ -1100,7 +1100,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 
 	  menu->redraw = REDRAW_CURRENT;
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
 
       case OP_COMPOSE_EDIT_ENCODING:
@@ -1119,7 +1119,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  else
 	    mutt_error _("Invalid encoding.");
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
 
       case OP_COMPOSE_SEND_MESSAGE:
@@ -1145,7 +1145,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  if ((i = query_quadoption (OPT_COPY,
 				_("Save a copy of this message?"))) == -1)
 	    break;
-	  else if (i == M_NO)
+	  else if (i == MUTT_NO)
 	    *fcc = 0;
 	}
 
@@ -1158,7 +1158,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	mutt_edit_file (NONULL(Editor), idx[menu->current]->content->filename);
 	mutt_update_encoding (idx[menu->current]->content);
 	menu->redraw = REDRAW_CURRENT | REDRAW_STATUS;
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
 	break;
 
       case OP_COMPOSE_TOGGLE_UNLINK:
@@ -1199,7 +1199,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	CHECK_COUNT;
 	strfcpy (fname, idx[menu->current]->content->filename, sizeof (fname));
 	mutt_pretty_mailbox (fname, sizeof (fname));
-	if (mutt_get_field (_("Rename to: "), fname, sizeof (fname), M_FILE)
+	if (mutt_get_field (_("Rename to: "), fname, sizeof (fname), MUTT_FILE)
 							== 0 && fname[0])
 	{
 	  if (stat(idx[menu->current]->content->filename, &st) == -1)
@@ -1221,7 +1221,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	    mutt_stamp_attachment(idx[menu->current]->content);
 	  
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
 
       case OP_COMPOSE_NEW_MIME:
@@ -1233,7 +1233,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 
           mutt_window_clearline (MuttMessageWindow, 0);
 	  fname[0] = 0;
-	  if (mutt_get_field (_("New file: "), fname, sizeof (fname), M_FILE)
+	  if (mutt_get_field (_("New file: "), fname, sizeof (fname), MUTT_FILE)
 	      != 0 || !fname[0])
 	    continue;
 	  mutt_expand_path (fname, sizeof (fname));
@@ -1289,7 +1289,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	    menu->redraw = REDRAW_FULL;
 	  }
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);    
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);    
         break;
 
       case OP_COMPOSE_EDIT_MIME:
@@ -1299,7 +1299,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  mutt_update_encoding (idx[menu->current]->content);
 	  menu->redraw = REDRAW_FULL;
 	}
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
 
       case OP_VIEW_ATTACH:
@@ -1330,17 +1330,17 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	if (op == OP_FILTER) /* cte might have changed */
 	  menu->redraw = menu->tagprefix ? REDRAW_FULL : REDRAW_CURRENT;
         menu->redraw |= REDRAW_STATUS;
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
 	break;
 
       case OP_EXIT:
-	if ((i = query_quadoption (OPT_POSTPONE, _("Postpone this message?"))) == M_NO)
+	if ((i = query_quadoption (OPT_POSTPONE, _("Postpone this message?"))) == MUTT_NO)
 	{
           for (i = 0; i < idxlen; i++)
             if (idx[i]->unowned)
               idx[i]->content->unlink = 0;
 
-          if (!(flags & M_COMPOSE_NOFREEHEADER))
+          if (!(flags & MUTT_COMPOSE_NOFREEHEADER))
           {
             while (idxlen-- > 0)
             {
@@ -1425,7 +1425,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
           if (msg->security & (ENCRYPT | SIGN))
           {
             if (mutt_yesorno (_("S/MIME already selected. Clear & continue ? "),
-                              M_YES) != M_YES)
+                              MUTT_YES) != MUTT_YES)
             {
               mutt_clear_error ();
               break;
@@ -1439,7 +1439,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	}
 	msg->security = crypt_pgp_send_menu (msg, &menu->redraw);
 	redraw_crypt_lines (msg);
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
 
 
@@ -1458,7 +1458,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
           if (msg->security & (ENCRYPT | SIGN))
           {
             if (mutt_yesorno (_("PGP already selected. Clear & continue ? "),
-                                M_YES) != M_YES)
+                                MUTT_YES) != MUTT_YES)
             {
               mutt_clear_error ();
               break;
@@ -1472,7 +1472,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	}
 	msg->security = crypt_smime_send_menu(msg, &menu->redraw);
 	redraw_crypt_lines (msg);
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
 
 
@@ -1480,7 +1480,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
       case OP_COMPOSE_MIX:
       
       	mix_make_chain (&msg->chain, &menu->redraw);
-        mutt_message_hook (NULL, msg, M_SEND2HOOK);
+        mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
         break;
 #endif
 
diff --git a/compress.c b/compress.c
index 67673d3..fb77631 100644
--- a/compress.c
+++ b/compress.c
@@ -120,7 +120,7 @@ remove_file (const CONTEXT *ctx)
 	if (!ctx)
 		return;
 
-	if ((ctx->magic == M_MBOX) || (ctx->magic == M_MMDF)) {
+	if ((ctx->magic == MUTT_MBOX) || (ctx->magic == MUTT_MMDF)) {
 		remove (ctx->path);
 	}
 }
@@ -165,7 +165,7 @@ file_exists (const char *path)
 
 /**
  * find_hook - Find a hook to match a path
- * @type: Type of hook, e.g. M_CLOSEHOOK
+ * @type: Type of hook, e.g. MUTT_CLOSEHOOK
  * @path: Filename to test
  *
  * Each hook has a type and a pattern.  Find a command that matches the type
@@ -175,7 +175,7 @@ file_exists (const char *path)
  *	open-hook '\.gz$' "gzip -cd '%f' > '%t'"
  *
  * Call:
- *	find_hook (M_OPENHOOK, "myfile.gz");
+ *	find_hook (MUTT_OPENHOOK, "myfile.gz");
  *
  * Returns:
  *	string: Matching hook command
@@ -237,9 +237,9 @@ set_compress_info (CONTEXT *ctx)
 	/* Now lets uncompress this thing */
 	ci = safe_malloc (sizeof (COMPRESS_INFO));
 	ctx->compress_info = (void*) ci;
-	ci->append = find_hook (M_APPENDHOOK, ctx->path);
-	ci->open   = find_hook (M_OPENHOOK, ctx->path);
-	ci->close  = find_hook (M_CLOSEHOOK, ctx->path);
+	ci->append = find_hook (MUTT_APPENDHOOK, ctx->path);
+	ci->open   = find_hook (MUTT_OPENHOOK, ctx->path);
+	ci->close  = find_hook (MUTT_CLOSEHOOK, ctx->path);
 	return ci;
 }
 
@@ -403,7 +403,7 @@ comp_can_read (const char *path)
 	if (!path)
 		return 0;
 
-	return find_hook (M_OPENHOOK, path) ? 1 : 0;
+	return find_hook (MUTT_OPENHOOK, path) ? 1 : 0;
 }
 
 /**
@@ -437,17 +437,17 @@ comp_can_append (const char *path)
 				dir_valid = 0;
 		}
 		FREE(&dir_path);
-		return dir_valid && (find_hook (M_CLOSEHOOK, path) ? 1 : 0);
+		return dir_valid && (find_hook (MUTT_CLOSEHOOK, path) ? 1 : 0);
 	}
 
 	magic = mx_get_magic (path);
 
-	if (magic != 0 && magic != M_COMPRESSED)
+	if (magic != 0 && magic != MUTT_COMPRESSED)
 		return 0;
 
-	return (find_hook (M_APPENDHOOK, path)
-			|| (find_hook (M_OPENHOOK, path)
-			&& find_hook (M_CLOSEHOOK, path))) ? 1 : 0;
+	return (find_hook (MUTT_APPENDHOOK, path)
+			|| (find_hook (MUTT_OPENHOOK, path)
+			&& find_hook (MUTT_CLOSEHOOK, path))) ? 1 : 0;
 }
 
 /**
@@ -618,7 +618,7 @@ comp_open_append (CONTEXT *ctx)
 	ctx->magic = DefaultMagic;
 
 	if (file_exists (ctx->realpath)) {
-		if (ctx->magic == M_MBOX || ctx->magic == M_MMDF) {
+		if (ctx->magic == MUTT_MBOX || ctx->magic == MUTT_MMDF) {
 			if ((fh = safe_fopen (ctx->path, "w"))) {
 				fclose (fh);
 			}
diff --git a/copy.c b/copy.c
index 7eb5c50..f541f5d 100644
--- a/copy.c
+++ b/copy.c
@@ -438,7 +438,7 @@ mutt_copy_header (FILE *in, HEADER *h, FILE *out, int flags, const char *prefix)
       int fail = 0;
 
       if (fail == 0 &&
-          ((h->env->kwtypes & M_X_LABEL) || (h->env->kwtypes == 0)) &&
+          ((h->env->kwtypes & MUTT_X_LABEL) || (h->env->kwtypes == 0)) &&
           (option(OPTKEYWORDSLEGACY) || option(OPTKEYWORDSSTANDARD) == 0))
       {
         mutt_labels(buf, sizeof(buf), h->env, XlabelDelim);
@@ -448,7 +448,7 @@ mutt_copy_header (FILE *in, HEADER *h, FILE *out, int flags, const char *prefix)
         FREE(&tmp);
       }
 
-      if (fail == 0 && (h->env->kwtypes & M_X_KEYWORDS) &&
+      if (fail == 0 && (h->env->kwtypes & MUTT_X_KEYWORDS) &&
           (option(OPTKEYWORDSLEGACY) || option(OPTKEYWORDSSTANDARD) == 0))
       {
         mutt_labels(buf, sizeof(buf), h->env, " ");
@@ -458,7 +458,7 @@ mutt_copy_header (FILE *in, HEADER *h, FILE *out, int flags, const char *prefix)
         FREE(&tmp);
       }
 
-      if (fail == 0 && (h->env->kwtypes & M_X_MOZILLA_KEYS) &&
+      if (fail == 0 && (h->env->kwtypes & MUTT_X_MOZILLA_KEYS) &&
           (option(OPTKEYWORDSLEGACY) || option(OPTKEYWORDSSTANDARD) == 0))
       {
         mutt_labels(buf, sizeof(buf), h->env, " ");
@@ -468,7 +468,7 @@ mutt_copy_header (FILE *in, HEADER *h, FILE *out, int flags, const char *prefix)
         FREE(&tmp);
       }
 
-      if (fail == 0 && ((h->env->kwtypes & M_KEYWORDS) ||
+      if (fail == 0 && ((h->env->kwtypes & MUTT_KEYWORDS) ||
                         option(OPTKEYWORDSSTANDARD)))
       {
         mutt_labels(buf, sizeof(buf), h->env, NULL);
@@ -544,14 +544,14 @@ static int count_delete_lines (FILE *fp, BODY *b, LOFF_T *length, size_t datelen
  * hdr		header of message being copied
  * body		structure of message being copied
  * flags
- * 	M_CM_NOHEADER	don't copy header
- * 	M_CM_PREFIX	quote header and body
- *	M_CM_DECODE	decode message body to text/plain
- *	M_CM_DISPLAY	displaying output to the user
- *      M_CM_PRINTING   printing the message
- *	M_CM_UPDATE	update structures in memory after syncing
- *	M_CM_DECODE_PGP	used for decoding PGP messages
- *	M_CM_CHARCONV	perform character set conversion 
+ * 	MUTT_CM_NOHEADER	don't copy header
+ * 	MUTT_CM_PREFIX	quote header and body
+ *	MUTT_CM_DECODE	decode message body to text/plain
+ *	MUTT_CM_DISPLAY	displaying output to the user
+ *      MUTT_CM_PRINTING   printing the message
+ *	MUTT_CM_UPDATE	update structures in memory after syncing
+ *	MUTT_CM_DECODE_PGP	used for decoding PGP messages
+ *	MUTT_CM_CHARCONV	perform character set conversion 
  * chflags	flags to mutt_copy_header()
  */
 
@@ -564,7 +564,7 @@ _mutt_copy_message (FILE *fpout, FILE *fpin, HEADER *hdr, BODY *body,
   LOFF_T new_offset = -1;
   int rc = 0;
 
-  if (flags & M_CM_PREFIX)
+  if (flags & MUTT_CM_PREFIX)
   {
     if (option (OPTTEXTFLOWED))
       strfcpy (prefix, ">", sizeof (prefix));
@@ -575,9 +575,9 @@ _mutt_copy_message (FILE *fpout, FILE *fpin, HEADER *hdr, BODY *body,
   if (hdr->label_changed)
     chflags |= CH_UPDATE_LABEL;
 
-  if ((flags & M_CM_NOHEADER) == 0)
+  if ((flags & MUTT_CM_NOHEADER) == 0)
   {
-    if (flags & M_CM_PREFIX)
+    if (flags & MUTT_CM_PREFIX)
       chflags |= CH_PREFIX;
 
     else if (hdr->attach_del && (chflags & CH_UPDATE_LEN))
@@ -628,7 +628,7 @@ _mutt_copy_message (FILE *fpout, FILE *fpin, HEADER *hdr, BODY *body,
 #endif
 
       /* Update original message if we are sync'ing a mailfolder */ 
-      if (flags & M_CM_UPDATE)
+      if (flags & MUTT_CM_UPDATE)
       {
 	hdr->attach_del = 0;
 	hdr->lines = new_lines;
@@ -657,38 +657,38 @@ _mutt_copy_message (FILE *fpout, FILE *fpin, HEADER *hdr, BODY *body,
     new_offset = ftello (fpout);
   }
 
-  if (flags & M_CM_DECODE)
+  if (flags & MUTT_CM_DECODE)
   {
     /* now make a text/plain version of the message */
     memset (&s, 0, sizeof (STATE));
     s.fpin = fpin;
     s.fpout = fpout;
-    if (flags & M_CM_PREFIX)
+    if (flags & MUTT_CM_PREFIX)
       s.prefix = prefix;
-    if (flags & M_CM_DISPLAY)
-      s.flags |= M_DISPLAY;
-    if (flags & M_CM_PRINTING)
-      s.flags |= M_PRINTING;
-    if (flags & M_CM_WEED)
-      s.flags |= M_WEED;
-    if (flags & M_CM_CHARCONV)
-      s.flags |= M_CHARCONV;
-    if (flags & M_CM_REPLYING)
-      s.flags |= M_REPLYING;
+    if (flags & MUTT_CM_DISPLAY)
+      s.flags |= MUTT_DISPLAY;
+    if (flags & MUTT_CM_PRINTING)
+      s.flags |= MUTT_PRINTING;
+    if (flags & MUTT_CM_WEED)
+      s.flags |= MUTT_WEED;
+    if (flags & MUTT_CM_CHARCONV)
+      s.flags |= MUTT_CHARCONV;
+    if (flags & MUTT_CM_REPLYING)
+      s.flags |= MUTT_REPLYING;
     
-    if (WithCrypto && flags & M_CM_VERIFY)
-      s.flags |= M_VERIFY;
+    if (WithCrypto && flags & MUTT_CM_VERIFY)
+      s.flags |= MUTT_VERIFY;
 
     rc = mutt_body_handler (body, &s);
   }
   else if (WithCrypto
-           && (flags & M_CM_DECODE_CRYPT) && (hdr->security & ENCRYPT))
+           && (flags & MUTT_CM_DECODE_CRYPT) && (hdr->security & ENCRYPT))
   {
     BODY *cur = NULL;
     FILE *fp;
 
     if ((WithCrypto & APPLICATION_PGP)
-        && (flags & M_CM_DECODE_PGP) && (hdr->security & APPLICATION_PGP) &&
+        && (flags & MUTT_CM_DECODE_PGP) && (hdr->security & APPLICATION_PGP) &&
 	hdr->content->type == TYPEMULTIPART)
     {
       if (crypt_pgp_decrypt_mime (fpin, &fp, hdr->content, &cur))
@@ -697,7 +697,7 @@ _mutt_copy_message (FILE *fpout, FILE *fpin, HEADER *hdr, BODY *body,
     }
 
     if ((WithCrypto & APPLICATION_SMIME)
-        && (flags & M_CM_DECODE_SMIME) && (hdr->security & APPLICATION_SMIME)
+        && (flags & MUTT_CM_DECODE_SMIME) && (hdr->security & APPLICATION_SMIME)
 	     && hdr->content->type == TYPEAPPLICATION)
     {
       if (crypt_smime_decrypt_mime (fpin, &fp, hdr->content, &cur))
@@ -726,7 +726,7 @@ _mutt_copy_message (FILE *fpout, FILE *fpin, HEADER *hdr, BODY *body,
   else
   {
     fseeko (fpin, body->offset, 0);
-    if (flags & M_CM_PREFIX)
+    if (flags & MUTT_CM_PREFIX)
     {
       int c;
       size_t bytes = body->length;
@@ -746,7 +746,7 @@ _mutt_copy_message (FILE *fpout, FILE *fpin, HEADER *hdr, BODY *body,
       return -1;
   }
 
-  if ((flags & M_CM_UPDATE) && (flags & M_CM_NOHEADER) == 0 
+  if ((flags & MUTT_CM_UPDATE) && (flags & MUTT_CM_NOHEADER) == 0 
       && new_offset != -1)
   {
     body->offset = new_offset;
@@ -800,17 +800,17 @@ _mutt_append_message (CONTEXT *dest, FILE *fpin, CONTEXT *src, HEADER *hdr,
   if (fgets (buf, sizeof (buf), fpin) == NULL)
     return -1;
 
-  if ((msg = mx_open_new_message (dest, hdr, is_from (buf, NULL, 0, NULL) ? 0 : M_ADD_FROM)) == NULL)
+  if ((msg = mx_open_new_message (dest, hdr, is_from (buf, NULL, 0, NULL) ? 0 : MUTT_ADD_FROM)) == NULL)
     return -1;
-  if (dest->magic == M_MBOX || dest->magic == M_MMDF)
+  if (dest->magic == MUTT_MBOX || dest->magic == MUTT_MMDF)
     chflags |= CH_FROM | CH_FORCE_FROM;
-  chflags |= (dest->magic == M_MAILDIR ? CH_NOSTATUS : CH_UPDATE);
+  chflags |= (dest->magic == MUTT_MAILDIR ? CH_NOSTATUS : CH_UPDATE);
   r = _mutt_copy_message (msg->fp, fpin, hdr, body, flags, chflags);
   if (mx_commit_message (msg, dest) != 0)
     r = -1;
 
 #ifdef USE_NOTMUCH
-  if (hdr && msg->commited_path && dest->magic == M_MAILDIR && src->magic == M_NOTMUCH)
+  if (hdr && msg->commited_path && dest->magic == MUTT_MAILDIR && src->magic == MUTT_NOTMUCH)
 	  nm_update_filename(src, NULL, msg->commited_path, hdr);
 #endif
 
diff --git a/copy.h b/copy.h
index 9f3c4e3..379cb01 100644
--- a/copy.h
+++ b/copy.h
@@ -17,21 +17,21 @@
  */ 
 
 /* flags to _mutt_copy_message */
-#define M_CM_NOHEADER	1	/* don't copy the message header */
-#define M_CM_PREFIX	(1<<1)	/* quote the message */
-#define M_CM_DECODE	(1<<2)	/* decode the message body into text/plain */
-#define M_CM_DISPLAY	(1<<3)	/* output is displayed to the user */
-#define M_CM_UPDATE	(1<<4)  /* update structs on sync */
-#define M_CM_WEED	(1<<5)  /* weed message/rfc822 attachment headers */
-#define M_CM_CHARCONV	(1<<6)  /* perform character set conversions */
-#define M_CM_PRINTING	(1<<7)	/* printing the message - display light */
-#define M_CM_REPLYING	(1<<8)	/* replying the message */
+#define MUTT_CM_NOHEADER	1	/* don't copy the message header */
+#define MUTT_CM_PREFIX	(1<<1)	/* quote the message */
+#define MUTT_CM_DECODE	(1<<2)	/* decode the message body into text/plain */
+#define MUTT_CM_DISPLAY	(1<<3)	/* output is displayed to the user */
+#define MUTT_CM_UPDATE	(1<<4)  /* update structs on sync */
+#define MUTT_CM_WEED	(1<<5)  /* weed message/rfc822 attachment headers */
+#define MUTT_CM_CHARCONV	(1<<6)  /* perform character set conversions */
+#define MUTT_CM_PRINTING	(1<<7)	/* printing the message - display light */
+#define MUTT_CM_REPLYING	(1<<8)	/* replying the message */
 
-#define M_CM_DECODE_PGP	  (1<<9) /* used for decoding PGP messages */
-#define M_CM_DECODE_SMIME (1<<10) /* used for decoding S/MIME messages */
-#define M_CM_DECODE_CRYPT  (M_CM_DECODE_PGP | M_CM_DECODE_SMIME)
+#define MUTT_CM_DECODE_PGP	  (1<<9) /* used for decoding PGP messages */
+#define MUTT_CM_DECODE_SMIME (1<<10) /* used for decoding S/MIME messages */
+#define MUTT_CM_DECODE_CRYPT  (MUTT_CM_DECODE_PGP | MUTT_CM_DECODE_SMIME)
 
-#define M_CM_VERIFY	(1<<11)	/* do signature verification */
+#define MUTT_CM_VERIFY	(1<<11)	/* do signature verification */
 
 /* flags for mutt_copy_header() */
 #define CH_UPDATE         1       /* update the status and x-status fields? */
diff --git a/crypt-gpgme.c b/crypt-gpgme.c
index 7173f42..ff74d68 100644
--- a/crypt-gpgme.c
+++ b/crypt-gpgme.c
@@ -1454,7 +1454,7 @@ static int show_one_sig_status (gpgme_ctx_t ctx, int idx, STATE *s)
 	/* pubkey not present */
       }
 
-      if (!s || !s->fpout || !(s->flags & M_DISPLAY))
+      if (!s || !s->fpout || !(s->flags & MUTT_DISPLAY))
 	; /* No state information so no way to print anything. */
       else if (err)
 	{
@@ -1724,7 +1724,7 @@ static BODY *decrypt_part (BODY *a, STATE *s, FILE *fpout, int is_smime,
             }
         }
       mutt_need_hard_redraw ();
-      if ((s->flags & M_DISPLAY))
+      if ((s->flags & MUTT_DISPLAY))
         {
           char buf[200];
           
@@ -1760,7 +1760,7 @@ static BODY *decrypt_part (BODY *a, STATE *s, FILE *fpout, int is_smime,
       if(r_is_signed)
         *r_is_signed = -1; /* A signature exists. */
 
-      if ((s->flags & M_DISPLAY))
+      if ((s->flags & MUTT_DISPLAY))
         state_attach_puts (_("[-- Begin signature "
                              "information --]\n"), s);
       for(idx = 0; (res = show_one_sig_status (ctx, idx, s)) != -1; idx++)
@@ -1773,7 +1773,7 @@ static BODY *decrypt_part (BODY *a, STATE *s, FILE *fpout, int is_smime,
       if (!anybad && idx && r_is_signed && *r_is_signed)
         *r_is_signed = anywarn? 2:1; /* Good signature. */
       
-      if ((s->flags & M_DISPLAY))
+      if ((s->flags & MUTT_DISPLAY))
         state_attach_puts (_("[-- End signature "
                              "information --]\n\n"), s);
     }
@@ -2293,9 +2293,9 @@ static void copy_clearsigned (gpgme_data_t data, STATE *s, char *charset)
 
   /* fromcode comes from the MIME Content-Type charset label. It might
    * be a wrong label, so we want the ability to do corrections via
-   * charset-hooks. Therefore we set flags to M_ICONV_HOOK_FROM.
+   * charset-hooks. Therefore we set flags to MUTT_ICONV_HOOK_FROM.
    */
-  fc = fgetconv_open (fp, charset, Charset, M_ICONV_HOOK_FROM);
+  fc = fgetconv_open (fp, charset, Charset, MUTT_ICONV_HOOK_FROM);
   
   for (complete = 1, armor_header = 1;
        fgetconvs (buf, sizeof (buf), fc) != NULL;
@@ -2395,7 +2395,7 @@ int pgp_gpgme_application_handler (BODY *m, STATE *s)
             }
           
           have_any_sigs = (have_any_sigs
-                           || (clearsign && (s->flags & M_VERIFY)));
+                           || (clearsign && (s->flags & MUTT_VERIFY)));
           
           /* Copy PGP material to an data container */
 	  armored_data = file_to_data_object (s->fpin, m->offset, m->length);
@@ -2404,7 +2404,7 @@ int pgp_gpgme_application_handler (BODY *m, STATE *s)
           {
             pgp_gpgme_extract_keys (armored_data, &pgpout, 1);
           }
-          else if (!clearsign || (s->flags & M_VERIFY))
+          else if (!clearsign || (s->flags & MUTT_VERIFY))
             {
               unsigned int sig_stat = 0;
               gpgme_data_t plaintext;
@@ -2457,7 +2457,7 @@ int pgp_gpgme_application_handler (BODY *m, STATE *s)
 
                   have_any_sigs = 0;
                   maybe_goodsig = 0;
-                  if ((s->flags & M_DISPLAY) && sig_stat)
+                  if ((s->flags & MUTT_DISPLAY) && sig_stat)
                     {
                       int res, idx;
                       int anybad = 0;
@@ -2501,7 +2501,7 @@ int pgp_gpgme_application_handler (BODY *m, STATE *s)
            * seems to be a reasonable guess.
            */
           
-          if(s->flags & M_DISPLAY)
+          if(s->flags & MUTT_DISPLAY)
             {
               if (needpass)
             state_attach_puts (_("[-- BEGIN PGP MESSAGE --]\n\n"), s);
@@ -2532,7 +2532,7 @@ int pgp_gpgme_application_handler (BODY *m, STATE *s)
               fgetconv_close (&fc);
             }
           
-          if (s->flags & M_DISPLAY)
+          if (s->flags & MUTT_DISPLAY)
             {
               state_putc ('\n', s);
               if (needpass)
@@ -2593,7 +2593,7 @@ int pgp_gpgme_encrypted_handler (BODY *a, STATE *s)
   mutt_mktemp (tempfile, sizeof (tempfile));
   if (!(fpout = safe_fopen (tempfile, "w+")))
     {
-      if (s->flags & M_DISPLAY)
+      if (s->flags & MUTT_DISPLAY)
         state_attach_puts (_("[-- Error: could not create temporary file! "
                              "--]\n"), s);
       return -1;
@@ -2604,7 +2604,7 @@ int pgp_gpgme_encrypted_handler (BODY *a, STATE *s)
     {
       tattach->goodsig = is_signed > 0;
 
-      if (s->flags & M_DISPLAY)
+      if (s->flags & MUTT_DISPLAY)
         state_attach_puts (is_signed?
           _("[-- The following data is PGP/MIME signed and encrypted --]\n\n"):
           _("[-- The following data is PGP/MIME encrypted --]\n\n"),
@@ -2625,7 +2625,7 @@ int pgp_gpgme_encrypted_handler (BODY *a, STATE *s)
       if (mutt_is_multipart_signed (tattach) && !tattach->next)
         a->goodsig |= tattach->goodsig;
     
-      if (s->flags & M_DISPLAY)
+      if (s->flags & MUTT_DISPLAY)
         {
           state_puts ("\n", s);
           state_attach_puts (is_signed?
@@ -2666,7 +2666,7 @@ int smime_gpgme_application_handler (BODY *a, STATE *s)
   mutt_mktemp (tempfile, sizeof (tempfile));
   if (!(fpout = safe_fopen (tempfile, "w+")))
     {
-      if (s->flags & M_DISPLAY)
+      if (s->flags & MUTT_DISPLAY)
         state_attach_puts (_("[-- Error: could not create temporary file! "
                              "--]\n"), s);
       return -1;
@@ -2677,7 +2677,7 @@ int smime_gpgme_application_handler (BODY *a, STATE *s)
     {
       tattach->goodsig = is_signed > 0;
 
-      if (s->flags & M_DISPLAY)
+      if (s->flags & MUTT_DISPLAY)
         state_attach_puts (is_signed?
           _("[-- The following data is S/MIME signed --]\n\n"):
           _("[-- The following data is S/MIME encrypted --]\n\n"),
@@ -2706,7 +2706,7 @@ int smime_gpgme_application_handler (BODY *a, STATE *s)
           a->warnsig = tattach->warnsig;
         }
 
-      if (s->flags & M_DISPLAY)
+      if (s->flags & MUTT_DISPLAY)
         {
           state_puts ("\n", s);
           state_attach_puts (is_signed?
@@ -2757,7 +2757,7 @@ static const char *crypt_entry_fmt (char *dest,
   crypt_entry_t *entry;
   crypt_key_t *key;
   int kflags = 0;
-  int optional = (flags & M_FORMAT_OPTIONAL);
+  int optional = (flags & MUTT_FORMAT_OPTIONAL);
   const char *s = NULL;
   unsigned long val;
 
@@ -2943,7 +2943,7 @@ static const char *crypt_entry_fmt (char *dest,
 
   if (optional)
     mutt_FormatString (dest, destlen, col, cols, ifstring, mutt_attach_fmt, data, 0);
-  else if (flags & M_FORMAT_OPTIONAL)
+  else if (flags & MUTT_FORMAT_OPTIONAL)
     mutt_FormatString (dest, destlen, col, cols, elsestring, mutt_attach_fmt, data, 0);
   return (src);
 }
@@ -2958,7 +2958,7 @@ static void crypt_entry (char *s, size_t l, MUTTMENU * menu, int num)
   entry.num = num + 1;
 
   mutt_FormatString (s, l, 0, MuttIndexWindow->cols, NONULL (PgpEntryFormat), crypt_entry_fmt, 
-		     (unsigned long) &entry, M_FORMAT_ARROWCURSOR);
+		     (unsigned long) &entry, MUTT_FORMAT_ARROWCURSOR);
 }
 
 /* Compare two addresses and the keyid to be used for sorting. */
@@ -4398,7 +4398,7 @@ static crypt_key_t *crypt_ask_for_key (char *tag,
   for (;;)
     {
       resp[0] = 0;
-      if (mutt_get_field (tag, resp, sizeof (resp), M_CLEAR) != 0)
+      if (mutt_get_field (tag, resp, sizeof (resp), MUTT_CLEAR) != 0)
         return NULL;
       
       if (whatfor)
@@ -4461,14 +4461,14 @@ static char *find_keys (ADDRESS *adrlist, unsigned int app, int oppenc_mode)
         if (crypt_hook != NULL)
           {
             crypt_hook_val = crypt_hook->data;
-            r = M_YES;
+            r = MUTT_YES;
             if (! oppenc_mode && option(OPTCRYPTCONFIRMHOOK))
               {
                 snprintf (buf, sizeof (buf), _("Use keyID = \"%s\" for %s?"),
                           crypt_hook_val, p->mailbox);
-                r = mutt_yesorno (buf, M_YES);
+                r = mutt_yesorno (buf, MUTT_YES);
               }
-            if (r == M_YES)
+            if (r == MUTT_YES)
               {
                 if (crypt_is_numerical_keyid (crypt_hook_val))
                   {
@@ -4497,7 +4497,7 @@ static char *find_keys (ADDRESS *adrlist, unsigned int app, int oppenc_mode)
 #endif
                   }
               }
-            else if (r == M_NO)
+            else if (r == MUTT_NO)
               {
                 if (key_selected || (crypt_hook->next != NULL))
                   {
diff --git a/crypt.c b/crypt.c
index 570cc36..7659fdc 100644
--- a/crypt.c
+++ b/crypt.c
@@ -149,7 +149,7 @@ int mutt_protect (HEADER *msg, char *keylist)
         ascii_strcasecmp (msg->content->subtype, "plain"))
     {
       if ((i = query_quadoption (OPT_PGPMIMEAUTO,
-              _("Inline PGP can't be used with attachments.  Revert to PGP/MIME?"))) != M_YES)
+              _("Inline PGP can't be used with attachments.  Revert to PGP/MIME?"))) != MUTT_YES)
       {
         mutt_error _("Mail not sent: inline PGP can't be used with attachments.");
         return -1;
@@ -167,7 +167,7 @@ int mutt_protect (HEADER *msg, char *keylist)
       }
 
       /* otherwise inline won't work...ask for revert */
-      if ((i = query_quadoption (OPT_PGPMIMEAUTO, _("Message can't be sent inline.  Revert to using PGP/MIME?"))) != M_YES)
+      if ((i = query_quadoption (OPT_PGPMIMEAUTO, _("Message can't be sent inline.  Revert to using PGP/MIME?"))) != MUTT_YES)
       {
         mutt_error _("Mail not sent.");
         return -1;
@@ -699,7 +699,7 @@ void crypt_extract_keys_from_messages (HEADER * h)
             && (Context->hdrs[Context->v2r[i]]->security & APPLICATION_PGP))
 	{
 	  mutt_copy_message (fpout, Context, Context->hdrs[Context->v2r[i]], 
-			     M_CM_DECODE|M_CM_CHARCONV, 0);
+			     MUTT_CM_DECODE|MUTT_CM_CHARCONV, 0);
 	  fflush(fpout);
 	  
 	  mutt_endwin (_("Trying to extract PGP keys...\n"));
@@ -711,8 +711,8 @@ void crypt_extract_keys_from_messages (HEADER * h)
 	{
 	  if (Context->hdrs[Context->v2r[i]]->security & ENCRYPT)
 	    mutt_copy_message (fpout, Context, Context->hdrs[Context->v2r[i]],
-			       M_CM_NOHEADER|M_CM_DECODE_CRYPT
-                               |M_CM_DECODE_SMIME, 0);
+			       MUTT_CM_NOHEADER|MUTT_CM_DECODE_CRYPT
+                               |MUTT_CM_DECODE_SMIME, 0);
 	  else
 	    mutt_copy_message (fpout, Context,
 			       Context->hdrs[Context->v2r[i]], 0, 0);
@@ -744,7 +744,7 @@ void crypt_extract_keys_from_messages (HEADER * h)
       if ((WithCrypto & APPLICATION_PGP)
           && (h->security & APPLICATION_PGP))
       {
-	mutt_copy_message (fpout, Context, h, M_CM_DECODE|M_CM_CHARCONV, 0);
+	mutt_copy_message (fpout, Context, h, MUTT_CM_DECODE|MUTT_CM_CHARCONV, 0);
 	fflush(fpout);
 	mutt_endwin (_("Trying to extract PGP keys...\n"));
 	crypt_pgp_invoke_import (tempfname);
@@ -754,9 +754,9 @@ void crypt_extract_keys_from_messages (HEADER * h)
           && (h->security & APPLICATION_SMIME))
       {
 	if (h->security & ENCRYPT)
-	  mutt_copy_message (fpout, Context, h, M_CM_NOHEADER
-                                                |M_CM_DECODE_CRYPT
-                                                |M_CM_DECODE_SMIME, 0);
+	  mutt_copy_message (fpout, Context, h, MUTT_CM_NOHEADER
+                                                |MUTT_CM_DECODE_CRYPT
+                                                |MUTT_CM_DECODE_SMIME, 0);
 	else
 	  mutt_copy_message (fpout, Context, h, 0, 0);
 
@@ -953,7 +953,7 @@ int mutt_signed_handler (BODY *a, STATE *s)
     return mutt_body_handler (a, s);
   }
 
-  if (s->flags & M_DISPLAY)
+  if (s->flags & MUTT_DISPLAY)
   {
     
     crypt_fetch_signatures (&signatures, a->next, &sigcnt);
@@ -1009,7 +1009,7 @@ int mutt_signed_handler (BODY *a, STATE *s)
   
   rc = mutt_body_handler (a, s);
   
-  if (s->flags & M_DISPLAY && sigcnt)
+  if (s->flags & MUTT_DISPLAY && sigcnt)
     state_attach_puts (_("\n[-- End of signed data --]\n"), s);
   
   return rc;
diff --git a/curs_lib.c b/curs_lib.c
index 13d7626..2267c3c 100644
--- a/curs_lib.c
+++ b/curs_lib.c
@@ -249,7 +249,7 @@ int mutt_yesorno (const char *msg, int def)
    * ensure there is enough room for the answer and truncate the question
    * to fit.
    */
-  safe_asprintf (&answer_string, " ([%s]/%s): ", def == M_YES ? yes : no, def == M_YES ? no : yes);
+  safe_asprintf (&answer_string, " ([%s]/%s): ", def == MUTT_YES ? yes : no, def == MUTT_YES ? no : yes);
   answer_string_len = mutt_strwidth (answer_string);
   /* maxlen here is sort of arbitrary, so pick a reasonable upper bound */
   msglen = mutt_wstr_trunc (msg, 4*MuttMessageWindow->cols, MuttMessageWindow->cols - answer_string_len, NULL);
@@ -280,7 +280,7 @@ int mutt_yesorno (const char *msg, int def)
 #endif
 	(tolower (ch.ch) == 'y'))
     {
-      def = M_YES;
+      def = MUTT_YES;
       break;
     }
     else if (
@@ -290,7 +290,7 @@ int mutt_yesorno (const char *msg, int def)
 #endif
 	     (tolower (ch.ch) == 'n'))
     {
-      def = M_NO;
+      def = MUTT_NO;
       break;
     }
     else
@@ -308,7 +308,7 @@ int mutt_yesorno (const char *msg, int def)
 
   if (def != -1)
   {
-    addstr ((char *) (def == M_YES ? yes : no));
+    addstr ((char *) (def == MUTT_YES ? yes : no));
     mutt_refresh ();
   }
   else
@@ -327,7 +327,7 @@ void mutt_query_exit (void)
   curs_set (1);
   if (Timeout)
     timeout (-1); /* restore blocking operation */
-  if (mutt_yesorno (_("Exit Mutt?"), M_YES) == M_YES)
+  if (mutt_yesorno (_("Exit Mutt?"), MUTT_YES) == MUTT_YES)
   {
     endwin ();
     exit (1);
@@ -399,7 +399,7 @@ void mutt_progress_init (progress_t* progress, const char *msg,
   progress->msg = msg;
   progress->size = size;
   if (progress->size) {
-    if (progress->flags & M_PROGRESS_SIZE)
+    if (progress->flags & MUTT_PROGRESS_SIZE)
       mutt_pretty_size (progress->sizestr, sizeof (progress->sizestr),
 			progress->size);
     else
@@ -484,7 +484,7 @@ void mutt_progress_update (progress_t* progress, long pos, int percent)
     goto out;
 
   /* refresh if size > inc */
-  if (progress->flags & M_PROGRESS_SIZE &&
+  if (progress->flags & MUTT_PROGRESS_SIZE &&
       (pos >= progress->pos + (progress->inc << 10)))
     update = 1;
   else if (pos >= progress->pos + progress->inc)
@@ -504,7 +504,7 @@ void mutt_progress_update (progress_t* progress, long pos, int percent)
 
   if (update)
   {
-    if (progress->flags & M_PROGRESS_SIZE)
+    if (progress->flags & MUTT_PROGRESS_SIZE)
     {
       pos = pos / (progress->inc << 10) * (progress->inc << 10);
       mutt_pretty_size (posstr, sizeof (posstr), pos);
@@ -810,7 +810,7 @@ int _mutt_enter_fname (const char *prompt, char *buf, size_t blen,
     mutt_refresh ();
     buf[0] = 0;
     if (!flags)
-      flags = M_SEL_FOLDER | (multiple ? M_SEL_MULTI : 0);
+      flags = MUTT_SEL_FOLDER | (multiple ? MUTT_SEL_MULTI : 0);
 
     _mutt_select_file (buf, blen, flags, files, numfiles);
     *redraw = REDRAW_FULL;
@@ -821,13 +821,13 @@ int _mutt_enter_fname (const char *prompt, char *buf, size_t blen,
 
     sprintf (pc, "%s: ", prompt);	/* __SPRINTF_CHECKED__ */
     mutt_unget_event (ch.op ? 0 : ch.ch, ch.op ? ch.op : 0);
-    if (_mutt_get_field (pc, buf, blen, (buffy ? M_EFILE : M_FILE) | M_CLEAR, multiple, files, numfiles)
+    if (_mutt_get_field (pc, buf, blen, (buffy ? MUTT_EFILE : MUTT_FILE) | MUTT_CLEAR, multiple, files, numfiles)
 	!= 0)
       buf[0] = 0;
     MAYBE_REDRAW (*redraw);
     FREE (&pc);
 #ifdef USE_NOTMUCH
-    if ((flags & M_SEL_VFOLDER) && buf[0] && strncmp(buf, "notmuch://", 10) != 0)
+    if ((flags & MUTT_SEL_VFOLDER) && buf[0] && strncmp(buf, "notmuch://", 10) != 0)
       nm_description_to_path(buf, buf, blen);
 #endif
   }
@@ -1013,10 +1013,10 @@ void mutt_format_string (char *dest, size_t destlen,
     if (escaped) {
       escaped = 0;
       w = 0;
-    } else if (arboreal && wc == M_SPECIAL_INDEX) {
+    } else if (arboreal && wc == MUTT_SPECIAL_INDEX) {
       escaped = 1;
       w = 0;
-    } else if (arboreal && wc < M_TREE_MAX) {
+    } else if (arboreal && wc < MUTT_TREE_MAX) {
       w = 1; /* hack */
     }
     else
@@ -1195,9 +1195,9 @@ size_t mutt_wstr_trunc (const char *src, size_t maxlen, size_t maxwid, size_t *w
       wc = replacement_char ();
     }
     cw = wcwidth (wc);
-    /* hack because M_TREE symbols aren't turned into characters
+    /* hack because MUTT_TREE symbols aren't turned into characters
      * until rendered by print_enriched_string (#3364) */
-    if (cw < 0 && cl == 1 && src[0] && src[0] < M_TREE_MAX)
+    if (cw < 0 && cl == 1 && src[0] && src[0] < MUTT_TREE_MAX)
       cw = 1;
     else if (cw < 0)
       cw = 0;			/* unprintable wchar */
@@ -1255,7 +1255,7 @@ int mutt_strwidth (const char *s)
   memset (&mbstate, 0, sizeof (mbstate));
   for (w=0; n && (k = mbrtowc (&wc, s, n, &mbstate)); s += k, n -= k)
   {
-    if (*s == M_SPECIAL_INDEX) {
+    if (*s == MUTT_SPECIAL_INDEX) {
       s += 2; /* skip the index coloring sequence */
       k = 0;
       continue;
diff --git a/curs_main.c b/curs_main.c
index fbdfa91..2500465 100644
--- a/curs_main.c
+++ b/curs_main.c
@@ -204,16 +204,16 @@ void mutt_ts_icon(char *str)
 
 void index_make_entry (char *s, size_t l, MUTTMENU *menu, int num)
 {
-  format_flag flag = M_FORMAT_MAKEPRINT | M_FORMAT_ARROWCURSOR | M_FORMAT_INDEX;
+  format_flag flag = MUTT_FORMAT_MAKEPRINT | MUTT_FORMAT_ARROWCURSOR | MUTT_FORMAT_INDEX;
   int edgemsgno, reverse = Sort & SORT_REVERSE;
   HEADER *h = Context->hdrs[Context->v2r[num]];
   THREAD *tmp;
 
   if ((Sort & SORT_MASK) == SORT_THREADS && h->tree)
   {
-    flag |= M_FORMAT_TREE; /* display the thread tree */
+    flag |= MUTT_FORMAT_TREE; /* display the thread tree */
     if (h->display_subject)
-      flag |= M_FORMAT_FORCESUBJ;
+      flag |= MUTT_FORMAT_FORCESUBJ;
     else
     {
       if (reverse)
@@ -235,13 +235,13 @@ void index_make_entry (char *s, size_t l, MUTTMENU *menu, int num)
 	 * subject... */
 	if (reverse ? tmp->message->msgno > edgemsgno : tmp->message->msgno < edgemsgno)
 	{
-	  flag |= M_FORMAT_FORCESUBJ;
+	  flag |= MUTT_FORMAT_FORCESUBJ;
 	  break;
 	}
 	else if (tmp->message->virtual >= 0)
 	  break;
       }
-      if (flag & M_FORMAT_FORCESUBJ)
+      if (flag & MUTT_FORMAT_FORCESUBJ)
       {
 	for (tmp = h->thread->prev; tmp; tmp = tmp->prev)
 	{
@@ -253,7 +253,7 @@ void index_make_entry (char *s, size_t l, MUTTMENU *menu, int num)
 	    break;
 	  else if (tmp->message->virtual >= 0)
 	  {
-	    flag &= ~M_FORMAT_FORCESUBJ;
+	    flag &= ~MUTT_FORMAT_FORCESUBJ;
 	    break;
 	  }
 	}
@@ -380,13 +380,13 @@ static void update_index (MUTTMENU *menu, CONTEXT *ctx, int check,
   if (ctx->pattern)
   {
 #define THIS_BODY ctx->hdrs[j]->content
-    for (j = (check == M_REOPENED) ? 0 : oldcount; j < ctx->msgcount; j++)
+    for (j = (check == MUTT_REOPENED) ? 0 : oldcount; j < ctx->msgcount; j++)
     {
       if (!j)
 	ctx->vcount = 0;
 
       if (mutt_pattern_exec (ctx->limit_pattern,
-			     M_MATCH_FULL_ADDRESS,
+			     MUTT_MATCH_FULL_ADDRESS,
 			     ctx, ctx->hdrs[j]))
       {
 	assert (ctx->vcount < ctx->msgcount);
@@ -401,7 +401,7 @@ static void update_index (MUTTMENU *menu, CONTEXT *ctx, int check,
   }
 
   /* save the list of new messages */
-  if (oldcount && check != M_REOPENED
+  if (oldcount && check != MUTT_REOPENED
       && ((Sort & SORT_MASK) == SORT_THREADS))
   {
     save_new = (HEADER **) safe_malloc (sizeof (HEADER *) * (ctx->msgcount - oldcount));
@@ -410,12 +410,12 @@ static void update_index (MUTTMENU *menu, CONTEXT *ctx, int check,
   }
 
   /* if the mailbox was reopened, need to rethread from scratch */
-  mutt_sort_headers (ctx, (check == M_REOPENED));
+  mutt_sort_headers (ctx, (check == MUTT_REOPENED));
 
   /* uncollapse threads with new mail */
   if ((Sort & SORT_MASK) == SORT_THREADS)
   {
-    if (check == M_REOPENED)
+    if (check == MUTT_REOPENED)
     {
       THREAD *h, *j;
 
@@ -639,7 +639,7 @@ static int main_change_folder(MUTTMENU *menu, int op, char *buf, size_t bufsz,
 
     if ((check = mx_close_mailbox (Context, index_hint)) != 0)
     {
-      if (check == M_NEW_MAIL || check == M_REOPENED)
+      if (check == MUTT_NEW_MAIL || check == MUTT_REOPENED)
         update_index (menu, Context, check, *oldcount, *index_hint);
 
       set_option (OPTSEARCHINVALID);
@@ -732,7 +732,7 @@ int mutt_index_menu (void)
   menu->current = ci_first_message ();
   menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_MAIN,
 #ifdef USE_NNTP
-	(Context && (Context->magic == M_NNTP)) ? IndexNewsHelp :
+	(Context && (Context->magic == MUTT_NNTP)) ? IndexNewsHelp :
 #endif
 	IndexHelp);
 
@@ -781,19 +781,19 @@ int mutt_index_menu (void)
 
 	set_option (OPTSEARCHINVALID);
       }
-      else if (check == M_NEW_MAIL || check == M_REOPENED || check == M_FLAGS)
+      else if (check == MUTT_NEW_MAIL || check == MUTT_REOPENED || check == MUTT_FLAGS)
       {
 	update_index (menu, Context, check, oldcount, index_hint);
 
 	/* notify the user of new mail */
-	if (check == M_REOPENED)
+	if (check == MUTT_REOPENED)
 	  mutt_error _("Mailbox was externally modified.  Flags may be wrong.");
-	else if (check == M_NEW_MAIL)
+	else if (check == MUTT_NEW_MAIL)
 	{
 	  mutt_message _("New mail in this mailbox.");
 	  if (option (OPTBEEPNEW))
 	    beep ();
-	} else if (check == M_FLAGS)
+	} else if (check == MUTT_FLAGS)
 	  mutt_message _("Mailbox was externally modified.");
 
 	/* avoid the message being overwritten by buffy */
@@ -1066,7 +1066,7 @@ int mutt_index_menu (void)
 	CHECK_IN_MAILBOX;
 	CHECK_READONLY;
 	CHECK_ATTACH;
-	if (Context->magic == M_NNTP)
+	if (Context->magic == MUTT_NNTP)
 	{
 	  HEADER *hdr;
 
@@ -1132,7 +1132,7 @@ int mutt_index_menu (void)
 	CHECK_VISIBLE;
 	CHECK_READONLY;
 	CHECK_ATTACH;
-	if (Context->magic == M_NNTP)
+	if (Context->magic == MUTT_NNTP)
 	{
 	  int oldmsgcount = Context->msgcount;
 	  int oldindex = CURHDR->index;
@@ -1273,10 +1273,10 @@ int mutt_index_menu (void)
         CHECK_VISIBLE;
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_DELETE, _("Cannot delete message(s)"));
+	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot delete message(s)"));
 
 	CHECK_ATTACH;
-	mutt_pattern_func (M_DELETE, _("Delete messages matching: "));
+	mutt_pattern_func (MUTT_DELETE, _("Delete messages matching: "));
 	menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
 	break;
 
@@ -1336,7 +1336,7 @@ int mutt_index_menu (void)
 	  Context->pattern = safe_strdup (buf);
 	}
 	if (((op == OP_LIMIT_CURRENT_THREAD) && mutt_limit_current_thread(CURHDR))
-	    || ((op == OP_MAIN_LIMIT) && (mutt_pattern_func (M_LIMIT, _("Limit to messages matching: ")) == 0)))
+	    || ((op == OP_MAIN_LIMIT) && (mutt_pattern_func (MUTT_LIMIT, _("Limit to messages matching: ")) == 0)))
 	{
 	  if (menu->oldcurrent >= 0)
 	  {
@@ -1370,7 +1370,7 @@ int mutt_index_menu (void)
 	 break;
 	}
 
-	if (query_quadoption (OPT_QUIT, _("Quit Mutt?")) == M_YES)
+	if (query_quadoption (OPT_QUIT, _("Quit Mutt?")) == MUTT_YES)
 	{
 	  int check;
 
@@ -1380,7 +1380,7 @@ int mutt_index_menu (void)
 	    done = 1;
 	  else
 	  {
-	    if (check == M_NEW_MAIL || check == M_REOPENED)
+	    if (check == MUTT_NEW_MAIL || check == MUTT_REOPENED)
 	      update_index (menu, Context, check, oldcount, index_hint);
 
 	    menu->redraw = REDRAW_FULL; /* new mail arrived? */
@@ -1434,12 +1434,12 @@ int mutt_index_menu (void)
 	if (tag && !option (OPTAUTOTAG))
 	{
 	  for (j = 0; j < Context->vcount; j++)
-	    mutt_set_flag (Context, Context->hdrs[Context->v2r[j]], M_TAG, 0);
+	    mutt_set_flag (Context, Context->hdrs[Context->v2r[j]], MUTT_TAG, 0);
 	  menu->redraw = REDRAW_STATUS | REDRAW_INDEX;
 	}
 	else
 	{
-	  mutt_set_flag (Context, CURHDR, M_TAG, !CURHDR->tagged);
+	  mutt_set_flag (Context, CURHDR, MUTT_TAG, !CURHDR->tagged);
 
 	  Context->last_tag = CURHDR->tagged ? CURHDR :
 	    ((Context->last_tag == CURHDR && !CURHDR->tagged)
@@ -1460,7 +1460,7 @@ int mutt_index_menu (void)
 
 	CHECK_MSGCOUNT;
         CHECK_VISIBLE;
-	mutt_pattern_func (M_TAG, _("Tag messages matching: "));
+	mutt_pattern_func (MUTT_TAG, _("Tag messages matching: "));
 	menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
 	break;
 
@@ -1470,9 +1470,9 @@ int mutt_index_menu (void)
         CHECK_VISIBLE;
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_DELETE, _("Cannot undelete message(s)"));
+	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot undelete message(s)"));
 
-	if (mutt_pattern_func (M_UNDELETE, _("Undelete messages matching: ")) == 0)
+	if (mutt_pattern_func (MUTT_UNDELETE, _("Undelete messages matching: ")) == 0)
 	  menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
 	break;
 
@@ -1480,7 +1480,7 @@ int mutt_index_menu (void)
 
 	CHECK_MSGCOUNT;
         CHECK_VISIBLE;
-	if (mutt_pattern_func (M_UNTAG, _("Untag messages matching: ")) == 0)
+	if (mutt_pattern_func (MUTT_UNTAG, _("Untag messages matching: ")) == 0)
 	  menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
 	break;
 
@@ -1490,12 +1490,12 @@ int mutt_index_menu (void)
 
 #ifdef USE_IMAP
       case OP_MAIN_IMAP_FETCH:
-	if (Context && Context->magic == M_IMAP)
+	if (Context && Context->magic == MUTT_IMAP)
 	  imap_check_mailbox (Context, &index_hint, 1);
         break;
 
       case OP_MAIN_IMAP_LOGOUT_ALL:
-	if (Context && Context->magic == M_IMAP)
+	if (Context && Context->magic == MUTT_IMAP)
 	{
 	  if (mx_close_mailbox (Context, &index_hint) != 0)
 	  {
@@ -1555,7 +1555,7 @@ int mutt_index_menu (void)
 	      }
 	    set_option (OPTSEARCHINVALID);
 	  }
-	  else if (check == M_NEW_MAIL || check == M_REOPENED)
+	  else if (check == MUTT_NEW_MAIL || check == MUTT_REOPENED)
 	    update_index (menu, Context, check, oldcount, index_hint);
 
 	  /*
@@ -1598,7 +1598,7 @@ int mutt_index_menu (void)
       case OP_MAIN_ENTIRE_THREAD:
       {
 	int oldcount  = Context->msgcount;
-	if (Context->magic != M_NOTMUCH) {
+	if (Context->magic != MUTT_NOTMUCH) {
 	  mutt_message _("No virtual folder, aborting.");
 	  break;
 	}
@@ -1632,14 +1632,14 @@ int mutt_index_menu (void)
       case OP_MAIN_MODIFY_LABELS:
       case OP_MAIN_MODIFY_LABELS_THEN_HIDE:
       {
-	if (Context->magic != M_NOTMUCH) {
+	if (Context->magic != MUTT_NOTMUCH) {
 	  mutt_message _("No virtual folder, aborting.");
 	  break;
 	}
 	CHECK_MSGCOUNT;
         CHECK_VISIBLE;
 	*buf = '\0';
-	if (mutt_get_field ("Add/remove labels: ", buf, sizeof (buf), M_NM_TAG) || !*buf)
+	if (mutt_get_field ("Add/remove labels: ", buf, sizeof (buf), MUTT_NM_TAG) || !*buf)
 	{
           mutt_message _("No label specified, aborting.");
           break;
@@ -1652,7 +1652,7 @@ int mutt_index_menu (void)
 
 	  if (!Context->quiet) {
 	    snprintf(msgbuf, sizeof (msgbuf), _("Update labels..."));
-	    mutt_progress_init(&progress, msgbuf, M_PROGRESS_MSG,
+	    mutt_progress_init(&progress, msgbuf, MUTT_PROGRESS_MSG,
 				   1, Context->tagged);
 	  }
 	  nm_longrun_init(Context, TRUE);
@@ -1706,7 +1706,7 @@ int mutt_index_menu (void)
 
       case OP_MAIN_VFOLDER_FROM_QUERY:
 	buf[0] = '\0';
-        if (mutt_get_field ("Query: ", buf, sizeof (buf), M_NM_QUERY) != 0 || !buf[0])
+        if (mutt_get_field ("Query: ", buf, sizeof (buf), MUTT_NM_QUERY) != 0 || !buf[0])
         {
           mutt_message _("No query, aborting.");
           break;
@@ -1735,7 +1735,7 @@ int mutt_index_menu (void)
 	    op == OP_MAIN_CHANGE_GROUP_READONLY ||
 #endif
 	    op == OP_MAIN_CHANGE_FOLDER_READONLY)
-	  flags = M_READONLY;
+	  flags = MUTT_READONLY;
 	else
 	  flags = 0;
 
@@ -1762,7 +1762,7 @@ int mutt_index_menu (void)
 	}
 #ifdef USE_NOTMUCH
 	else if (op == OP_MAIN_CHANGE_VFOLDER) {
-	  if (Context->magic == M_NOTMUCH) {
+	  if (Context->magic == MUTT_NOTMUCH) {
 		  strfcpy(buf, Context->path, sizeof (buf));
 		  mutt_buffy_vfolder (buf, sizeof (buf));
 	  }
@@ -1823,7 +1823,7 @@ int mutt_index_menu (void)
 #ifdef USE_NNTP
 	/* mutt_buffy_check() must be done with mail-reader mode! */
 	menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_MAIN,
-	  (Context && (Context->magic == M_NNTP)) ? IndexNewsHelp : IndexHelp);
+	  (Context && (Context->magic == MUTT_NNTP)) ? IndexNewsHelp : IndexHelp);
 #endif
 	break;
 
@@ -1872,7 +1872,7 @@ int mutt_index_menu (void)
 
 	if ((menu->menu == MENU_MAIN)
 	    && (query_quadoption (OPT_QUIT,
-				  _("Exit Mutt without saving?")) == M_YES))
+				  _("Exit Mutt without saving?")) == MUTT_YES))
 	{
 	  if (Context)
 	  {
@@ -1888,7 +1888,7 @@ int mutt_index_menu (void)
 	CHECK_MSGCOUNT;
         CHECK_VISIBLE;
 	CHECK_READONLY;
-	CHECK_ACL(M_ACL_WRITE, _("Cannot break thread"));
+	CHECK_ACL(MUTT_ACL_WRITE, _("Cannot break thread"));
 
         if ((Sort & SORT_MASK) != SORT_THREADS)
 	  mutt_error _("Threading is not enabled.");
@@ -1924,7 +1924,7 @@ int mutt_index_menu (void)
         CHECK_VISIBLE;
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_WRITE, _("Cannot link threads"));
+	CHECK_ACL(MUTT_ACL_WRITE, _("Cannot link threads"));
 
         if ((Sort & SORT_MASK) != SORT_THREADS)
 	  mutt_error _("Threading is not enabled.");
@@ -2205,7 +2205,7 @@ int mutt_index_menu (void)
         CHECK_VISIBLE;
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_WRITE, _("Cannot flag message"));
+	CHECK_ACL(MUTT_ACL_WRITE, _("Cannot flag message"));
 
         if (tag)
         {
@@ -2213,14 +2213,14 @@ int mutt_index_menu (void)
 	  {
 	    if (Context->hdrs[Context->v2r[j]]->tagged)
 	      mutt_set_flag (Context, Context->hdrs[Context->v2r[j]],
-			     M_FLAG, !Context->hdrs[Context->v2r[j]]->flagged);
+			     MUTT_FLAG, !Context->hdrs[Context->v2r[j]]->flagged);
 	  }
 
 	  menu->redraw |= REDRAW_INDEX;
 	}
         else
         {
-	  mutt_set_flag (Context, CURHDR, M_FLAG, !CURHDR->flagged);
+	  mutt_set_flag (Context, CURHDR, MUTT_FLAG, !CURHDR->flagged);
 	  if (option (OPTRESOLVE))
 	  {
 	    if ((menu->current = ci_next_undeleted (menu->current)) == -1)
@@ -2243,7 +2243,7 @@ int mutt_index_menu (void)
         CHECK_VISIBLE;
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_SEEN, _("Cannot toggle new"));
+	CHECK_ACL(MUTT_ACL_SEEN, _("Cannot toggle new"));
 
 	if (tag)
 	{
@@ -2253,9 +2253,9 @@ int mutt_index_menu (void)
 	    {
 	      if (Context->hdrs[Context->v2r[j]]->read ||
 		  Context->hdrs[Context->v2r[j]]->old)
-		mutt_set_flag (Context, Context->hdrs[Context->v2r[j]], M_NEW, 1);
+		mutt_set_flag (Context, Context->hdrs[Context->v2r[j]], MUTT_NEW, 1);
 	      else
-		mutt_set_flag (Context, Context->hdrs[Context->v2r[j]], M_READ, 1);
+		mutt_set_flag (Context, Context->hdrs[Context->v2r[j]], MUTT_READ, 1);
 	    }
 	  }
 	  menu->redraw = REDRAW_STATUS | REDRAW_INDEX;
@@ -2263,9 +2263,9 @@ int mutt_index_menu (void)
 	else
 	{
 	  if (CURHDR->read || CURHDR->old)
-	    mutt_set_flag (Context, CURHDR, M_NEW, 1);
+	    mutt_set_flag (Context, CURHDR, MUTT_NEW, 1);
 	  else
-	    mutt_set_flag (Context, CURHDR, M_READ, 1);
+	    mutt_set_flag (Context, CURHDR, MUTT_READ, 1);
 
 	  if (option (OPTRESOLVE))
 	  {
@@ -2357,7 +2357,7 @@ int mutt_index_menu (void)
 	CHECK_MSGCOUNT;
         CHECK_VISIBLE;
 	CHECK_READONLY;
-	/* CHECK_ACL(M_ACL_WRITE); */
+	/* CHECK_ACL(MUTT_ACL_WRITE); */
 
 	if (mutt_change_flag (tag ? NULL : CURHDR, (op == OP_MAIN_SET_FLAG)) == 0)
 	{
@@ -2499,23 +2499,23 @@ int mutt_index_menu (void)
         CHECK_VISIBLE;
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_DELETE, _("Cannot delete message"));
+	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot delete message"));
 
 	if (tag)
 	{
-	  mutt_tag_set_flag (M_DELETE, 1);
-	  mutt_tag_set_flag (M_PURGED, (op != OP_PURGE_MESSAGE) ? 0 : 1);
+	  mutt_tag_set_flag (MUTT_DELETE, 1);
+	  mutt_tag_set_flag (MUTT_PURGED, (op != OP_PURGE_MESSAGE) ? 0 : 1);
 	  if (option (OPTDELETEUNTAG))
-	    mutt_tag_set_flag (M_TAG, 0);
+	    mutt_tag_set_flag (MUTT_TAG, 0);
 	  menu->redraw = REDRAW_INDEX;
 	}
 	else
 	{
-	  mutt_set_flag (Context, CURHDR, M_DELETE, 1);
-	  mutt_set_flag (Context, CURHDR, M_PURGED,
+	  mutt_set_flag (Context, CURHDR, MUTT_DELETE, 1);
+	  mutt_set_flag (Context, CURHDR, MUTT_PURGED,
 			 (op != OP_PURGE_MESSAGE) ? 0 : 1);
 	  if (option (OPTDELETEUNTAG))
-	    mutt_set_flag (Context, CURHDR, M_TAG, 0);
+	    mutt_set_flag (Context, CURHDR, MUTT_TAG, 0);
 	  if (option (OPTRESOLVE))
 	  {
 	    if ((menu->current = ci_next_undeleted (menu->current)) == -1)
@@ -2544,15 +2544,15 @@ int mutt_index_menu (void)
         CHECK_VISIBLE;
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_DELETE, _("Cannot delete message(s)"));
+	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot delete message(s)"));
 
-	rc = mutt_thread_set_flag (CURHDR, M_DELETE, 1,
+	rc = mutt_thread_set_flag (CURHDR, MUTT_DELETE, 1,
 				   op == OP_DELETE_THREAD ? 0 : 1);
 
 	if (rc != -1)
 	{
 	  if (option (OPTDELETEUNTAG))
-	    mutt_thread_set_flag (CURHDR, M_TAG, 0,
+	    mutt_thread_set_flag (CURHDR, MUTT_TAG, 0,
 				  op == OP_DELETE_THREAD ? 0 : 1);
 	  if (option (OPTRESOLVE))
 	    if ((menu->current = ci_next_undeleted (menu->current)) == -1)
@@ -2566,7 +2566,7 @@ int mutt_index_menu (void)
 	CHECK_MSGCOUNT;
 	CHECK_READONLY;
 	CHECK_ATTACH
-	if (Context && Context->magic == M_NNTP)
+	if (Context && Context->magic == MUTT_NNTP)
 	{
 	  NNTP_DATA *nntp_data = Context->data;
 	  if (mutt_newsgroup_catchup (nntp_data->nserv, nntp_data->group))
@@ -2600,7 +2600,7 @@ int mutt_index_menu (void)
 	CHECK_READONLY;
 	CHECK_ATTACH;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_INSERT, _("Cannot edit message"));
+	CHECK_ACL(MUTT_ACL_INSERT, _("Cannot edit message"));
 
 	if (option (OPTPGPAUTODEC) && (tag || !(CURHDR->security & PGP_TRADITIONAL_CHECKED)))
 	  mutt_check_traditional_pgp (tag ? NULL : CURHDR, &menu->redraw);
@@ -2713,7 +2713,7 @@ int mutt_index_menu (void)
 	/* in an IMAP folder index with imap_peek=no, piping could change
 	 * new or old messages status to read. Redraw what's needed.
 	 */
-	if (Context->magic == M_IMAP && !option (OPTIMAPPEEK))
+	if (Context->magic == MUTT_IMAP && !option (OPTIMAPPEEK))
 	{
 	  menu->redraw = (tag ? REDRAW_INDEX : REDRAW_CURRENT) | REDRAW_STATUS;
 	}
@@ -2732,7 +2732,7 @@ int mutt_index_menu (void)
 	/* in an IMAP folder index with imap_peek=no, printing could change
 	 * new or old messages status to read. Redraw what's needed.
 	 */
-	if (Context->magic == M_IMAP && !option (OPTIMAPPEEK))
+	if (Context->magic == MUTT_IMAP && !option (OPTIMAPPEEK))
 	{
 	  menu->redraw = (tag ? REDRAW_INDEX : REDRAW_CURRENT) | REDRAW_STATUS;
 	}
@@ -2747,9 +2747,9 @@ int mutt_index_menu (void)
 	CHECK_VISIBLE;
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_SEEN, _("Cannot mark message(s) as read"));
+	CHECK_ACL(MUTT_ACL_SEEN, _("Cannot mark message(s) as read"));
 
-	rc = mutt_thread_set_flag (CURHDR, M_READ, 1,
+	rc = mutt_thread_set_flag (CURHDR, MUTT_READ, 1,
 				   op == OP_MAIN_READ_THREAD ? 0 : 1);
 
 	if (rc != -1)
@@ -2809,12 +2809,12 @@ int mutt_index_menu (void)
 	if (op != OP_FOLLOWUP || !CURHDR->env->followup_to ||
 	    mutt_strcasecmp (CURHDR->env->followup_to, "poster") ||
 	    query_quadoption (OPT_FOLLOWUPTOPOSTER,
-	    _("Reply by mail as poster prefers?")) != M_YES)
+	    _("Reply by mail as poster prefers?")) != MUTT_YES)
 	{
-	  if (Context && Context->magic == M_NNTP &&
+	  if (Context && Context->magic == MUTT_NNTP &&
 	      !((NNTP_DATA *)Context->data)->allowed &&
 	      query_quadoption (OPT_TOMODERATED,
-	      _("Posting to this group not allowed, may be moderated. Continue?")) != M_YES)
+	      _("Posting to this group not allowed, may be moderated. Continue?")) != MUTT_YES)
 	    break;
 	  if (op == OP_POST)
 	    ci_send_message (SENDNEWS, NULL, NULL, Context, NULL);
@@ -2851,7 +2851,7 @@ int mutt_index_menu (void)
 
 	CHECK_MSGCOUNT;
         CHECK_VISIBLE;
-	rc = mutt_thread_set_flag (CURHDR, M_TAG, !CURHDR->tagged,
+	rc = mutt_thread_set_flag (CURHDR, MUTT_TAG, !CURHDR->tagged,
 				   op == OP_TAG_THREAD ? 0 : 1);
 
 	if (rc != -1)
@@ -2876,18 +2876,18 @@ int mutt_index_menu (void)
         CHECK_VISIBLE;
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_DELETE, _("Cannot undelete message"));
+	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot undelete message"));
 
 	if (tag)
 	{
-	  mutt_tag_set_flag (M_DELETE, 0);
-	  mutt_tag_set_flag (M_PURGED, 0);
+	  mutt_tag_set_flag (MUTT_DELETE, 0);
+	  mutt_tag_set_flag (MUTT_PURGED, 0);
 	  menu->redraw = REDRAW_INDEX;
 	}
 	else
 	{
-	  mutt_set_flag (Context, CURHDR, M_DELETE, 0);
-	  mutt_set_flag (Context, CURHDR, M_PURGED, 0);
+	  mutt_set_flag (Context, CURHDR, MUTT_DELETE, 0);
+	  mutt_set_flag (Context, CURHDR, MUTT_PURGED, 0);
 	  if (option (OPTRESOLVE) && menu->current < Context->vcount - 1)
 	  {
 	    menu->current++;
@@ -2906,11 +2906,11 @@ int mutt_index_menu (void)
         CHECK_VISIBLE;
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_DELETE, _("Cannot undelete message(s)"));
+	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot undelete message(s)"));
 
-	rc = mutt_thread_set_flag (CURHDR, M_DELETE, 0,
+	rc = mutt_thread_set_flag (CURHDR, MUTT_DELETE, 0,
 				   op == OP_UNDELETE_THREAD ? 0 : 1)
-	  + mutt_thread_set_flag (CURHDR, M_PURGED, 0,
+	  + mutt_thread_set_flag (CURHDR, MUTT_PURGED, 0,
 				  (op == OP_UNDELETE_THREAD) ? 0 : 1);
 
 	if (rc > -1)
@@ -3007,7 +3007,7 @@ void mutt_set_header_color (CONTEXT *ctx, HEADER *curhdr)
     return;
 
   for (color = ColorIndexList; color; color = color->next)
-   if (mutt_pattern_exec (color->color_pattern, M_MATCH_FULL_ADDRESS, ctx, curhdr))
+   if (mutt_pattern_exec (color->color_pattern, MUTT_MATCH_FULL_ADDRESS, ctx, curhdr))
    {
       curhdr->pair = color->pair;
       return;
diff --git a/doc/makedoc.c b/doc/makedoc.c
index 1fcbc24..382b422 100644
--- a/doc/makedoc.c
+++ b/doc/makedoc.c
@@ -482,10 +482,10 @@ static void pretty_default (char *t, size_t l, const char *s, int type)
   {
     case DT_QUAD:
     {    
-      if (!strcasecmp (s, "M_YES")) strncpy (t, "yes", l);
-      else if (!strcasecmp (s, "M_NO")) strncpy (t, "no", l);
-      else if (!strcasecmp (s, "M_ASKYES")) strncpy (t, "ask-yes", l);
-      else if (!strcasecmp (s, "M_ASKNO")) strncpy (t, "ask-no", l);
+      if (!strcasecmp (s, "MUTT_YES")) strncpy (t, "yes", l);
+      else if (!strcasecmp (s, "MUTT_NO")) strncpy (t, "no", l);
+      else if (!strcasecmp (s, "MUTT_ASKYES")) strncpy (t, "ask-yes", l);
+      else if (!strcasecmp (s, "MUTT_ASKNO")) strncpy (t, "ask-no", l);
       break;
     }
     case DT_BOOL:
diff --git a/editmsg.c b/editmsg.c
index 8ba3105..5a2e8f5 100644
--- a/editmsg.c
+++ b/editmsg.c
@@ -67,9 +67,9 @@ static int edit_one_message (CONTEXT *ctx, HEADER *cur)
   mutt_mktemp (tmp, sizeof (tmp));
 
   omagic = DefaultMagic;
-  DefaultMagic = M_MBOX;
+  DefaultMagic = MUTT_MBOX;
 
-  rc = (mx_open_mailbox (tmp, M_NEWFOLDER, &tmpctx) == NULL) ? -1 : 0;
+  rc = (mx_open_mailbox (tmp, MUTT_NEWFOLDER, &tmpctx) == NULL) ? -1 : 0;
 
   DefaultMagic = omagic;
 
@@ -80,7 +80,7 @@ static int edit_one_message (CONTEXT *ctx, HEADER *cur)
   }
 
   rc = mutt_append_message (&tmpctx, ctx, cur, 0, CH_NOLEN |
-	((ctx->magic == M_MBOX || ctx->magic == M_MMDF) ? 0 : CH_NOSTATUS));
+	((ctx->magic == MUTT_MBOX || ctx->magic == MUTT_MMDF) ? 0 : CH_NOSTATUS));
   oerrno = errno;
 
   mx_close_mailbox (&tmpctx, NULL);
@@ -143,7 +143,7 @@ static int edit_one_message (CONTEXT *ctx, HEADER *cur)
     goto bail;
   }
 
-  if (mx_open_mailbox (ctx->path, M_APPEND, &tmpctx) == NULL)
+  if (mx_open_mailbox (ctx->path, MUTT_APPEND, &tmpctx) == NULL)
   {
     rc = -1;
     /* L10N: %s is from strerror(errno) */
@@ -152,15 +152,15 @@ static int edit_one_message (CONTEXT *ctx, HEADER *cur)
   }
 
   of = 0;
-  cf = ((tmpctx.magic == M_MBOX || tmpctx.magic == M_MMDF) ? 0 : CH_NOSTATUS);
+  cf = ((tmpctx.magic == MUTT_MBOX || tmpctx.magic == MUTT_MMDF) ? 0 : CH_NOSTATUS);
   
   if (fgets (buff, sizeof (buff), fp) && is_from (buff, NULL, 0, NULL))
   {
-    if (tmpctx.magic == M_MBOX || tmpctx.magic == M_MMDF)
+    if (tmpctx.magic == MUTT_MBOX || tmpctx.magic == MUTT_MMDF)
       cf = CH_FROM | CH_FORCE_FROM;
   }
   else
-    of = M_ADD_FROM;
+    of = MUTT_ADD_FROM;
 
   /* 
    * XXX - we have to play games with the message flags to avoid
@@ -199,11 +199,11 @@ static int edit_one_message (CONTEXT *ctx, HEADER *cur)
 
   if (rc == 0)
   {
-    mutt_set_flag (Context, cur, M_DELETE, 1);
-    mutt_set_flag (Context, cur, M_READ, 1);
+    mutt_set_flag (Context, cur, MUTT_DELETE, 1);
+    mutt_set_flag (Context, cur, MUTT_READ, 1);
 
     if (option (OPTDELETEUNTAG))
-      mutt_set_flag (Context, cur, M_TAG, 0);
+      mutt_set_flag (Context, cur, MUTT_TAG, 0);
   }
   else if (rc == -1)
     mutt_message (_("Error. Preserving temporary file: %s"), tmp);
diff --git a/enter.c b/enter.c
index 333730a..7a806dd 100644
--- a/enter.c
+++ b/enter.c
@@ -32,8 +32,8 @@
 /* redraw flags for mutt_enter_string() */
 enum
 {
-  M_REDRAW_INIT = 1,	/* go to end of line and redraw */
-  M_REDRAW_LINE		/* redraw entire line */
+  MUTT_REDRAW_INIT = 1,	/* go to end of line and redraw */
+  MUTT_REDRAW_LINE		/* redraw entire line */
 };
 
 static int my_wcwidth (wchar_t wc)
@@ -225,7 +225,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 {
   int width = MuttMessageWindow->cols - col - 1;
   int redraw;
-  int pass = (flags & M_PASS);
+  int pass = (flags & MUTT_PASS);
   int first = 1;
   int ch, w, r;
   size_t i;
@@ -241,7 +241,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
   if (state->wbuf)
   {
     /* Coming back after return 1 */
-    redraw = M_REDRAW_LINE;
+    redraw = MUTT_REDRAW_LINE;
     first = 0;
   }
   else
@@ -249,20 +249,20 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
     /* Initialise wbuf from buf */
     state->wbuflen = 0;
     state->lastchar = my_mbstowcs (&state->wbuf, &state->wbuflen, 0, buf);
-    redraw = M_REDRAW_INIT;
+    redraw = MUTT_REDRAW_INIT;
   }
 
-  if (flags & M_FILE)
+  if (flags & MUTT_FILE)
     hclass = HC_FILE;
-  else if (flags & M_EFILE)
+  else if (flags & MUTT_EFILE)
     hclass = HC_MBOX;
-  else if (flags & M_CMD)
+  else if (flags & MUTT_CMD)
     hclass = HC_CMD;
-  else if (flags & M_ALIAS)
+  else if (flags & MUTT_ALIAS)
     hclass = HC_ALIAS;
-  else if (flags & M_COMMAND)
+  else if (flags & MUTT_COMMAND)
     hclass = HC_COMMAND;
-  else if (flags & M_PATTERN)
+  else if (flags & MUTT_PATTERN)
     hclass = HC_PATTERN;
   else 
     hclass = HC_OTHER;
@@ -271,7 +271,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
   {
     if (redraw && !pass)
     {
-      if (redraw == M_REDRAW_INIT)
+      if (redraw == MUTT_REDRAW_INIT)
       {
 	/* Go to end of line */
 	state->curpos = state->lastchar;
@@ -306,7 +306,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
       first = 0;
       if (ch != OP_EDITOR_COMPLETE && ch != OP_EDITOR_COMPLETE_QUERY)
 	state->tabs = 0;
-      redraw = M_REDRAW_LINE;
+      redraw = MUTT_REDRAW_LINE;
       switch (ch)
       {
 	case OP_EDITOR_HISTORY_UP:
@@ -317,7 +317,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	    mutt_history_save_scratch (hclass, buf);
 	  }
 	  replace_part (state, 0, mutt_history_prev (hclass));
-	  redraw = M_REDRAW_INIT;
+	  redraw = MUTT_REDRAW_INIT;
 	  break;
 
 	case OP_EDITOR_HISTORY_DOWN:
@@ -328,7 +328,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	    mutt_history_save_scratch (hclass, buf);
 	  }
 	  replace_part (state, 0, mutt_history_next (hclass));
-	  redraw = M_REDRAW_INIT;
+	  redraw = MUTT_REDRAW_INIT;
 	  break;
 
 	case OP_EDITOR_BACKSPACE:
@@ -352,7 +352,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	  break;
 
 	case OP_EDITOR_EOL:
-	  redraw= M_REDRAW_INIT;
+	  redraw= MUTT_REDRAW_INIT;
 	  break;
 
 	case OP_EDITOR_KILL_LINE:
@@ -508,7 +508,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	  break;
 
 	case OP_EDITOR_BUFFY_CYCLE:
-	  if (flags & M_EFILE)
+	  if (flags & MUTT_EFILE)
 	  {
 	    first = 1; /* clear input if user types a real key later */
 	    my_wcstombs (buf, buflen, state->wbuf, state->curpos);
@@ -516,14 +516,14 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	    state->curpos = state->lastchar = my_mbstowcs (&state->wbuf, &state->wbuflen, 0, buf);
 	    break;
 	  }
-	  else if (!(flags & M_FILE))
+	  else if (!(flags & MUTT_FILE))
 	    goto self_insert;
-	  /* fall through to completion routine (M_FILE) */
+	  /* fall through to completion routine (MUTT_FILE) */
 
 	case OP_EDITOR_COMPLETE:
 	case OP_EDITOR_COMPLETE_QUERY:
 	  state->tabs++;
-	  if (flags & M_CMD)
+	  if (flags & MUTT_CMD)
 	  {
 	    for (i = state->curpos; i && !is_shell_char(state->wbuf[i-1]); i--)
 	      ;
@@ -531,7 +531,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	    if (tempbuf && templen == state->lastchar - i &&
 		!memcmp (tempbuf, state->wbuf + i, (state->lastchar - i) * sizeof (wchar_t)))
 	    {
-	      mutt_select_file (buf, buflen, (flags & M_EFILE) ? M_SEL_FOLDER : 0);
+	      mutt_select_file (buf, buflen, (flags & MUTT_EFILE) ? MUTT_SEL_FOLDER : 0);
 	      set_option (OPTNEEDREDRAW);
 	      if (*buf)
 		replace_part (state, i, buf);
@@ -548,7 +548,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 
 	    replace_part (state, i, buf);
 	  }
-	  else if (flags & M_ALIAS && ch == OP_EDITOR_COMPLETE)
+	  else if (flags & MUTT_ALIAS && ch == OP_EDITOR_COMPLETE)
 	  {
 	    /* invoke the alias-menu to get more addresses */
 	    for (i = state->curpos; i && state->wbuf[i-1] != ',' && 
@@ -566,7 +566,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	    }
 	    break;
 	  }
-	  else if (flags & M_LABEL && ch == OP_EDITOR_COMPLETE)
+	  else if (flags & MUTT_LABEL && ch == OP_EDITOR_COMPLETE)
 	  {
 	    for (i = state->curpos; i && state->wbuf[i-1] != ',' && 
 		 state->wbuf[i-1] != ':'; i--)
@@ -583,7 +583,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	    }
 	    break;
 	  }
-	  else if (flags & M_PATTERN && ch == OP_EDITOR_COMPLETE)
+	  else if (flags & MUTT_PATTERN && ch == OP_EDITOR_COMPLETE)
 	  {
         char *p;
 	    for (i = state->curpos; i && state->wbuf[i-1] != ',' && 
@@ -609,7 +609,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
           goto self_insert;
 	    break;
 	  }
-	  else if (flags & M_ALIAS && ch == OP_EDITOR_COMPLETE_QUERY)
+	  else if (flags & MUTT_ALIAS && ch == OP_EDITOR_COMPLETE_QUERY)
 	  {
 	    /* invoke the query-menu to get more addresses */
 	    if ((i = state->curpos))
@@ -627,7 +627,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	    rv = 1; 
 	    goto bye;
 	  }
-	  else if (flags & M_COMMAND)
+	  else if (flags & MUTT_COMMAND)
 	  {
 	    my_wcstombs (buf, buflen, state->wbuf, state->curpos);
 	    i = strlen (buf);
@@ -638,7 +638,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	      BEEP ();
 	    replace_part (state, 0, buf);
 	  }
-	  else if (flags & (M_FILE | M_EFILE))
+	  else if (flags & (MUTT_FILE | MUTT_EFILE))
 	  {
 	    my_wcstombs (buf, buflen, state->wbuf, state->curpos);
 
@@ -647,7 +647,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 		!memcmp (tempbuf, state->wbuf, state->lastchar * sizeof (wchar_t))))
 	    {
 	      _mutt_select_file (buf, buflen, 
-				 ((flags & M_EFILE) ? M_SEL_FOLDER : 0) | (multiple ? M_SEL_MULTI : 0), 
+				 ((flags & MUTT_EFILE) ? MUTT_SEL_FOLDER : 0) | (multiple ? MUTT_SEL_MULTI : 0), 
 				 files, numfiles);
 	      set_option (OPTNEEDREDRAW);
 	      if (*buf)
@@ -675,7 +675,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 	    replace_part (state, 0, buf);
 	  }
 #if USE_NOTMUCH
-	  else if (flags & M_NM_QUERY)
+	  else if (flags & MUTT_NM_QUERY)
 	  {
 	    my_wcstombs (buf, buflen, state->wbuf, state->curpos);
 	    i = strlen (buf);
@@ -684,7 +684,7 @@ int _mutt_enter_string (char *buf, size_t buflen, int col,
 
 	    replace_part (state, 0, buf);
 	  }
-	  else if (flags & M_NM_TAG)
+	  else if (flags & MUTT_NM_TAG)
 	  {
 	    my_wcstombs (buf, buflen, state->wbuf, state->curpos);
 	    i = strlen (buf);
@@ -762,7 +762,7 @@ self_insert:
 	}
       }
 
-      if (first && (flags & M_CLEAR))
+      if (first && (flags & MUTT_CLEAR))
       {
 	first = 0;
 	if (IsWPrint (wc)) /* why? */
diff --git a/flags.c b/flags.c
index f544f51..eb8e6dc 100644
--- a/flags.c
+++ b/flags.c
@@ -37,14 +37,14 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
   int flagged = ctx->flagged;
   int update = 0;
 
-  if (ctx->readonly && flag != M_TAG)
+  if (ctx->readonly && flag != MUTT_TAG)
     return; /* don't modify anything if we are read-only */
 
   switch (flag)
   {
-    case M_DELETE:
+    case MUTT_DELETE:
 
-      if (!mutt_bit_isset(ctx->rights,M_ACL_DELETE))
+      if (!mutt_bit_isset(ctx->rights,MUTT_ACL_DELETE))
 	return;
 
       if (bf)
@@ -57,7 +57,7 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
 #ifdef USE_IMAP
           /* deleted messages aren't treated as changed elsewhere so that the
            * purge-on-sync option works correctly. This isn't applicable here */
-          if (ctx && ctx->magic == M_IMAP)
+          if (ctx && ctx->magic == MUTT_IMAP)
           {
             h->changed = 1;
 	    if (upd_ctx) ctx->changed = 1;
@@ -78,7 +78,7 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
         h->appended = 0; /* when undeleting, also reset the appended flag */
 #ifdef USE_IMAP
         /* see my comment above */
-	if (ctx->magic == M_IMAP) 
+	if (ctx->magic == MUTT_IMAP) 
 	{
 	  h->changed = 1;
 	  if (upd_ctx) ctx->changed = 1;
@@ -92,12 +92,12 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
 	 * is checked in specific code in the maildir folder
 	 * driver. 
 	 */
-	if (ctx->magic == M_MAILDIR && upd_ctx && h->trash)
+	if (ctx->magic == MUTT_MAILDIR && upd_ctx && h->trash)
 	  ctx->changed = 1;
       }
       break;
 
-    case M_APPENDED:
+    case MUTT_APPENDED:
       if (bf) {
         if (!h->appended) {
           h->appended = 1;
@@ -108,7 +108,7 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
       }
       break;
 
-    case M_PURGED:
+    case MUTT_PURGED:
       if (bf) {
         if (!h->purged) {
           h->purged = 1;
@@ -118,9 +118,9 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
       }
       break;
 
-    case M_NEW:
+    case MUTT_NEW:
 
-      if (!mutt_bit_isset(ctx->rights,M_ACL_SEEN))
+      if (!mutt_bit_isset(ctx->rights,MUTT_ACL_SEEN))
 	return;
 
       if (bf)
@@ -151,9 +151,9 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
       }
       break;
 
-    case M_OLD:
+    case MUTT_OLD:
 
-      if (!mutt_bit_isset(ctx->rights,M_ACL_SEEN))
+      if (!mutt_bit_isset(ctx->rights,MUTT_ACL_SEEN))
 	return;
 
       if (bf)
@@ -179,9 +179,9 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
       }
       break;
 
-    case M_READ:
+    case MUTT_READ:
 
-      if (!mutt_bit_isset(ctx->rights,M_ACL_SEEN))
+      if (!mutt_bit_isset(ctx->rights,MUTT_ACL_SEEN))
 	return;
 
       if (bf)
@@ -209,9 +209,9 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
       }
       break;
 
-    case M_REPLIED:
+    case MUTT_REPLIED:
 
-      if (!mutt_bit_isset(ctx->rights,M_ACL_WRITE))
+      if (!mutt_bit_isset(ctx->rights,MUTT_ACL_WRITE))
 	return;
 
       if (bf)
@@ -240,9 +240,9 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
       }
       break;
 
-    case M_FLAG:
+    case MUTT_FLAG:
 
-      if (!mutt_bit_isset(ctx->rights,M_ACL_WRITE))
+      if (!mutt_bit_isset(ctx->rights,MUTT_ACL_WRITE))
 	return;
 
       if (bf)
@@ -266,7 +266,7 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
       }
       break;
 
-    case M_TAG:
+    case MUTT_TAG:
       if (bf)
       {
 	if (!h->tagged)
@@ -374,34 +374,34 @@ int mutt_change_flag (HEADER *h, int bf)
   {
     case 'd':
     case 'D':
-      flag = M_DELETE;
+      flag = MUTT_DELETE;
       break;
 
     case 'N':
     case 'n':
-      flag = M_NEW;
+      flag = MUTT_NEW;
       break;
 
     case 'o':
     case 'O':
       if (h)
-	mutt_set_flag (Context, h, M_READ, !bf);
+	mutt_set_flag (Context, h, MUTT_READ, !bf);
       else
-	mutt_tag_set_flag (M_READ, !bf);
-      flag = M_OLD;
+	mutt_tag_set_flag (MUTT_READ, !bf);
+      flag = MUTT_OLD;
       break;
 
     case 'r':
     case 'R':
-      flag = M_REPLIED;
+      flag = MUTT_REPLIED;
       break;
 
     case '*':
-      flag = M_TAG;
+      flag = MUTT_TAG;
       break;
 
     case '!':
-      flag = M_FLAG;
+      flag = MUTT_FLAG;
       break;
 
     default:
diff --git a/functions.h b/functions.h
index 5747425..5231e27 100644
--- a/functions.h
+++ b/functions.h
@@ -22,7 +22,7 @@
  *
  * Notes:
  *
- * - If you want to bind \n or \r, use M_ENTER_S so that it will work
+ * - If you want to bind \n or \r, use MUTT_ENTER_S so that it will work
  * correctly under both ncurses and S-Lang
  *
  * - If you need to bind a control char, use the octal value because the \cX
@@ -70,7 +70,7 @@ const struct binding_t OpGeneric[] = { /* map: generic */
   { "tag-prefix-cond",	OP_TAG_PREFIX_COND,	NULL },
   { "end-cond",		OP_END_COND,		NULL },
   { "shell-escape",	OP_SHELL_ESCAPE,	"!" },
-  { "select-entry",	OP_GENERIC_SELECT_ENTRY,M_ENTER_S },
+  { "select-entry",	OP_GENERIC_SELECT_ENTRY,MUTT_ENTER_S },
   { "search",		OP_SEARCH,		"/" },
   { "search-reverse",	OP_SEARCH_REVERSE,	"\033/" },
   { "search-opposite",	OP_SEARCH_OPPOSITE,	NULL },
@@ -169,7 +169,7 @@ const struct binding_t OpMain[] = { /* map: index */
 #ifdef USE_NNTP
   { "catchup",			OP_CATCHUP,			"y" },
 #endif
-  { "display-message",		OP_DISPLAY_MESSAGE,		M_ENTER_S },
+  { "display-message",		OP_DISPLAY_MESSAGE,		MUTT_ENTER_S },
   { "buffy-list",		OP_BUFFY_LIST,			"." },
   { "sync-mailbox",		OP_MAIN_SYNC_FOLDER,		"$" },
   { "display-address",		OP_DISPLAY_ADDRESS,		"@" },
@@ -301,7 +301,7 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "search",		OP_SEARCH,			"/" },
   { "search-reverse",	OP_SEARCH_REVERSE,		"\033/" },
   { "search-opposite",	OP_SEARCH_OPPOSITE,		NULL },
-  { "next-line",	OP_NEXT_LINE,			M_ENTER_S },
+  { "next-line",	OP_NEXT_LINE,			MUTT_ENTER_S },
   { "jump",		OP_JUMP,			NULL },
   { "next-unread",	OP_MAIN_NEXT_UNREAD,		NULL },
   { "previous-new",	OP_MAIN_PREV_NEW,		NULL },
@@ -368,7 +368,7 @@ const struct binding_t OpAttach[] = { /* map: attachment */
   { "list-reply",	OP_LIST_REPLY,			"L" },
   { "forward-message",	OP_FORWARD_MESSAGE,		"f" },
   { "view-text",	OP_ATTACH_VIEW_TEXT,		"T" },
-  { "view-attach",	OP_VIEW_ATTACH,			M_ENTER_S },
+  { "view-attach",	OP_VIEW_ATTACH,			MUTT_ENTER_S },
   { "delete-entry",	OP_DELETE,			"d" },
   { "undelete-entry",	OP_UNDELETE,			"u" },
   { "collapse-parts",	OP_ATTACH_COLLAPSE,		"v" },
@@ -418,7 +418,7 @@ const struct binding_t OpCompose[] = { /* map: compose */
   { "toggle-unlink",	OP_COMPOSE_TOGGLE_UNLINK,	"u" },
   { "toggle-recode",    OP_COMPOSE_TOGGLE_RECODE,	NULL },
   { "update-encoding",	OP_COMPOSE_UPDATE_ENCODING,	"U" },
-  { "view-attach",	OP_VIEW_ATTACH,			M_ENTER_S },
+  { "view-attach",	OP_VIEW_ATTACH,			MUTT_ENTER_S },
   { "send-message",	OP_COMPOSE_SEND_MESSAGE,	"y" },
   { "pipe-entry",	OP_PIPE,			"|" },
 
@@ -542,7 +542,7 @@ const struct binding_t OpSmime[] = { /* map: smime */
 
 #ifdef MIXMASTER
 const struct binding_t OpMix[] = { /* map: mixmaster */
-  { "accept",		OP_MIX_USE,	M_ENTER_S },
+  { "accept",		OP_MIX_USE,	MUTT_ENTER_S },
   { "append",		OP_MIX_APPEND,	"a"       },
   { "insert",		OP_MIX_INSERT,	"i"       },
   { "delete",		OP_MIX_DELETE,  "d"	  },
diff --git a/group.h b/group.h
index d61c615..68f01dc 100644
--- a/group.h
+++ b/group.h
@@ -20,8 +20,8 @@
 #ifndef _MUTT_GROUP_H_
 #define _MUTT_GROUP_H_ 1
 
-#define M_GROUP		0
-#define M_UNGROUP	1
+#define MUTT_GROUP		0
+#define MUTT_UNGROUP	1
 
 void mutt_group_add_adrlist (group_t *g, ADDRESS *a);
 
diff --git a/handler.c b/handler.c
index 4b2aa5c..d4490fd 100644
--- a/handler.c
+++ b/handler.c
@@ -646,7 +646,7 @@ static void enriched_putwc (wchar_t c, struct enriched_state *stte)
   }
   else
   {
-    if (stte->s->flags & M_DISPLAY)
+    if (stte->s->flags & MUTT_DISPLAY)
     {
       if (stte->tag_level[RICH_BOLD])
       {
@@ -721,7 +721,7 @@ static void enriched_set_flags (const wchar_t *tag, struct enriched_state *stte)
     {
       if (stte->tag_level[j]) /* make sure not to go negative */
 	stte->tag_level[j]--;
-      if ((stte->s->flags & M_DISPLAY) && j == RICH_PARAM && stte->tag_level[RICH_COLOR])
+      if ((stte->s->flags & MUTT_DISPLAY) && j == RICH_PARAM && stte->tag_level[RICH_COLOR])
       {
 	stte->param[stte->param_used] = (wchar_t) '\0';
 	if (!wcscasecmp(L"black", stte->param))
@@ -757,7 +757,7 @@ static void enriched_set_flags (const wchar_t *tag, struct enriched_state *stte)
 	  enriched_puts("\033[37m", stte);
 	}
       }
-      if ((stte->s->flags & M_DISPLAY) && j == RICH_COLOR)
+      if ((stte->s->flags & MUTT_DISPLAY) && j == RICH_COLOR)
       {
 	enriched_puts("\033[0m", stte);
       }
@@ -791,7 +791,7 @@ static int text_enriched_handler (BODY *a, STATE *s)
 
   memset (&stte, 0, sizeof (stte));
   stte.s = s;
-  stte.WrapMargin = ((s->flags & M_DISPLAY) ? (MuttIndexWindow->cols-4) :
+  stte.WrapMargin = ((s->flags & MUTT_DISPLAY) ? (MuttIndexWindow->cols-4) :
                      ((MuttIndexWindow->cols-4)<72)?(MuttIndexWindow->cols-4):72);
   stte.line_max = stte.WrapMargin * 4;
   stte.line = (wchar_t *) safe_calloc (1, (stte.line_max + 1) * sizeof (wchar_t));
@@ -987,7 +987,7 @@ static int mutt_is_autoview (BODY *b)
    *
    * WARNING: type is altered by this call as a result of `mime_lookup' support */
   if (is_autoview)
-    return rfc1524_mailcap_lookup(b, type, NULL, M_AUTOVIEW);
+    return rfc1524_mailcap_lookup(b, type, NULL, MUTT_AUTOVIEW);
 
   return 0;
 }
@@ -1125,14 +1125,14 @@ static int alternative_handler (BODY *a, STATE *s)
 
   if (choice)
   {
-    if (s->flags & M_DISPLAY && !option (OPTWEED))
+    if (s->flags & MUTT_DISPLAY && !option (OPTWEED))
     {
       fseeko (s->fpin, choice->hdr_offset, 0);
       mutt_copy_bytes(s->fpin, s->fpout, choice->offset-choice->hdr_offset);
     }
     mutt_body_handler (choice, s);
   }
-  else if (s->flags & M_DISPLAY)
+  else if (s->flags & MUTT_DISPLAY)
   {
     /* didn't find anything that we could display! */
     state_mark_attach (s);
@@ -1169,9 +1169,9 @@ static int message_handler (BODY *a, STATE *s)
   if (b->parts)
   {
     mutt_copy_hdr (s->fpin, s->fpout, off_start, b->parts->offset,
-	(((s->flags & M_WEED) || ((s->flags & (M_DISPLAY|M_PRINTING)) && option (OPTWEED))) ? (CH_WEED | CH_REORDER) : 0) |
+	(((s->flags & MUTT_WEED) || ((s->flags & (MUTT_DISPLAY|MUTT_PRINTING)) && option (OPTWEED))) ? (CH_WEED | CH_REORDER) : 0) |
 	(s->prefix ? CH_PREFIX : 0) | CH_DECODE | CH_FROM |
-	((s->flags & M_DISPLAY) ? CH_DISPLAY : 0), s->prefix);
+	((s->flags & MUTT_DISPLAY) ? CH_DISPLAY : 0), s->prefix);
 
     if (s->prefix)
       state_puts (s->prefix, s);
@@ -1248,7 +1248,7 @@ static int multipart_handler (BODY *a, STATE *s)
 
   for (p = b->parts, count = 1; p; p = p->next, count++)
   {
-    if (s->flags & M_DISPLAY)
+    if (s->flags & MUTT_DISPLAY)
     {
       state_mark_attach (s);
       state_printf (s, _("[-- Attachment #%d"), count);
@@ -1283,8 +1283,8 @@ static int multipart_handler (BODY *a, STATE *s)
       dprint (1, (debugfile, "Failed on attachment #%d, type %s/%s.\n", count, TYPE(p), NONULL (p->subtype)));
     }
     
-    if ((s->flags & M_REPLYING)
-        && (option (OPTINCLUDEONLYFIRST)) && (s->flags & M_FIRSTDONE))
+    if ((s->flags & MUTT_REPLYING)
+        && (option (OPTINCLUDEONLYFIRST)) && (s->flags & MUTT_FIRSTDONE))
       break;
   }
 
@@ -1314,7 +1314,7 @@ static int autoview_handler (BODY *a, STATE *s)
   int rc = 0;
 
   snprintf (type, sizeof (type), "%s/%s", TYPE (a), a->subtype);
-  rfc1524_mailcap_lookup (a, type, entry, M_AUTOVIEW);
+  rfc1524_mailcap_lookup (a, type, entry, MUTT_AUTOVIEW);
 
   fname = safe_strdup (a->filename);
   mutt_sanitize_filename (fname, 1);
@@ -1328,7 +1328,7 @@ static int autoview_handler (BODY *a, STATE *s)
     /* rfc1524_expand_command returns 0 if the file is required */
     piped = rfc1524_expand_command (a, tempfile, type, command, sizeof (command));
 
-    if (s->flags & M_DISPLAY)
+    if (s->flags & MUTT_DISPLAY)
     {
       state_mark_attach (s);
       state_printf (s, _("[-- Autoview using %s --]\n"), command);
@@ -1361,7 +1361,7 @@ static int autoview_handler (BODY *a, STATE *s)
     if (thepid < 0)
     {
       mutt_perror _("Can't create filter");
-      if (s->flags & M_DISPLAY)
+      if (s->flags & MUTT_DISPLAY)
       {
 	state_mark_attach (s);
 	state_printf (s, _("[-- Can't run %s. --]\n"), command);
@@ -1380,7 +1380,7 @@ static int autoview_handler (BODY *a, STATE *s)
       /* check for data on stderr */
       if (fgets (buffer, sizeof(buffer), fperr)) 
       {
-	if (s->flags & M_DISPLAY)
+	if (s->flags & MUTT_DISPLAY)
 	{
 	  state_mark_attach (s);
 	  state_printf (s, _("[-- Autoview stderr of %s --]\n"), command);
@@ -1401,7 +1401,7 @@ static int autoview_handler (BODY *a, STATE *s)
       /* Check for stderr messages */
       if (fgets (buffer, sizeof(buffer), fperr))
       {
-	if (s->flags & M_DISPLAY)
+	if (s->flags & MUTT_DISPLAY)
 	{
 	  state_mark_attach (s);
 	  state_printf (s, _("[-- Autoview stderr of %s --]\n"), 
@@ -1423,7 +1423,7 @@ static int autoview_handler (BODY *a, STATE *s)
     else
       mutt_unlink (tempfile);
 
-    if (s->flags & M_DISPLAY) 
+    if (s->flags & MUTT_DISPLAY) 
       mutt_clear_error ();
   }
   rfc1524_free_entry (&entry);
@@ -1440,7 +1440,7 @@ static int external_body_handler (BODY *b, STATE *s)
   access_type = mutt_get_parameter ("access-type", b->parameter);
   if (!access_type)
   {
-    if (s->flags & M_DISPLAY)
+    if (s->flags & MUTT_DISPLAY)
     {
       state_mark_attach (s);
       state_puts (_("[-- Error: message/external-body has no access-type parameter --]\n"), s);
@@ -1458,7 +1458,7 @@ static int external_body_handler (BODY *b, STATE *s)
 
   if (!ascii_strcasecmp (access_type, "x-mutt-deleted"))
   {
-    if (s->flags & (M_DISPLAY|M_PRINTING))
+    if (s->flags & (MUTT_DISPLAY|MUTT_PRINTING))
     {
       char *length;
       char pretty_size[10];
@@ -1493,7 +1493,7 @@ static int external_body_handler (BODY *b, STATE *s)
   }
   else if(expiration && expire < time(NULL))
   {
-    if (s->flags & M_DISPLAY)
+    if (s->flags & MUTT_DISPLAY)
     {
       state_mark_attach (s);
       state_printf (s, _("[-- This %s/%s attachment is not included, --]\n"),
@@ -1508,7 +1508,7 @@ static int external_body_handler (BODY *b, STATE *s)
   }
   else
   {
-    if (s->flags & M_DISPLAY)
+    if (s->flags & MUTT_DISPLAY)
     {
       state_mark_attach (s);
       state_printf (s,
@@ -1532,16 +1532,16 @@ void mutt_decode_attachment (BODY *b, STATE *s)
   int istext = mutt_is_text_part (b);
   iconv_t cd = (iconv_t)(-1);
 
-  if (istext && s->flags & M_CHARCONV)
+  if (istext && s->flags & MUTT_CHARCONV)
   {
     char *charset = mutt_get_parameter ("charset", b->parameter);
     if (!charset && AssumedCharset && *AssumedCharset)
       charset = mutt_get_default_charset ();
     if (charset && Charset)
-      cd = mutt_iconv_open (Charset, charset, M_ICONV_HOOK_FROM);
+      cd = mutt_iconv_open (Charset, charset, MUTT_ICONV_HOOK_FROM);
   }
   else if (istext && b->charset)
-    cd = mutt_iconv_open (Charset, b->charset, M_ICONV_HOOK_FROM);
+    cd = mutt_iconv_open (Charset, b->charset, MUTT_ICONV_HOOK_FROM);
 
   fseeko (s->fpin, b->offset, 0);
   switch (b->encoding)
@@ -1715,7 +1715,7 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
       s->fpin = fp;
     }
   }
-  s->flags |= M_FIRSTDONE;
+  s->flags |= MUTT_FIRSTDONE;
 
   return rc;
 }
@@ -1758,7 +1758,7 @@ int mutt_body_handler (BODY *b, STATE *s)
   if (mutt_is_autoview (b))
   {
     handler = autoview_handler;
-    s->flags &= ~M_CHARCONV;
+    s->flags &= ~MUTT_CHARCONV;
   }
   else if (b->type == TYPETEXT)
   {
@@ -1800,7 +1800,7 @@ int mutt_body_handler (BODY *b, STATE *s)
 
       if (!p)
         mutt_error _("Error: multipart/signed has no protocol.");
-      else if (s->flags & M_VERIFY)
+      else if (s->flags & MUTT_VERIFY)
 	handler = mutt_signed_handler;
     }
     else if (mutt_is_valid_multipart_pgp_encrypted (b))
@@ -1843,7 +1843,7 @@ int mutt_body_handler (BODY *b, STATE *s)
   }
   /* print hint to use attachment menu for disposition == attachment
      if we're not already being called from there */
-  else if ((s->flags & M_DISPLAY) || (b->disposition == DISPATTACH &&
+  else if ((s->flags & MUTT_DISPLAY) || (b->disposition == DISPATTACH &&
 				      !option (OPTVIEWATTACH) &&
 				      option (OPTHONORDISP) &&
 				      (plaintext || handler)))
@@ -1866,7 +1866,7 @@ int mutt_body_handler (BODY *b, STATE *s)
     fputs (" --]\n", s->fpout);
   }
 
-  s->flags = oflags | (s->flags & M_FIRSTDONE);
+  s->flags = oflags | (s->flags & MUTT_FIRSTDONE);
   if (rc)
   {
     dprint (1, (debugfile, "Bailing on attachment of type %s/%s.\n", TYPE(b), NONULL (b->subtype)));
diff --git a/hcache.c b/hcache.c
index 2f4b71d..912b80a 100644
--- a/hcache.c
+++ b/hcache.c
@@ -625,7 +625,7 @@ mutt_hcache_dump(header_cache_t *h, HEADER * header, int *off,
   *off = 0;
   d = lazy_malloc(sizeof (validate));
 
-  if (flags & M_GENERATE_UIDVALIDITY)
+  if (flags & MUTT_GENERATE_UIDVALIDITY)
   {
     struct timeval now;
     gettimeofday(&now, NULL);
@@ -787,7 +787,7 @@ mutt_hcache_fetch_raw (header_cache_t *h, const char *filename,
 /*
  * flags
  *
- * M_GENERATE_UIDVALIDITY
+ * MUTT_GENERATE_UIDVALIDITY
  * ignore uidvalidity param and store gettimeofday() as the value
  */
 int
diff --git a/hcache.h b/hcache.h
index 62eaa18..ca0b425 100644
--- a/hcache.h
+++ b/hcache.h
@@ -35,7 +35,7 @@ void *mutt_hcache_fetch_raw (header_cache_t *h, const char *filename,
                              size_t (*keylen)(const char *fn));
 
 typedef enum {
-  M_GENERATE_UIDVALIDITY = 1 /* use gettimeofday() as value */
+  MUTT_GENERATE_UIDVALIDITY = 1 /* use gettimeofday() as value */
 } mutt_hcache_store_flags_t;
 
 /* uidvalidity is an IMAP-specific unsigned 32 bit number */
diff --git a/hdrline.c b/hdrline.c
index c8b0818..d2c1253 100644
--- a/hdrline.c
+++ b/hdrline.c
@@ -120,7 +120,7 @@ add_index_color (char *buf, size_t buflen, format_flag flags, char color)
 	int len;
 
 	/* only add color markers if we are operating on main index entries. */
-	if (!(flags & M_FORMAT_INDEX))
+	if (!(flags & MUTT_FORMAT_INDEX))
 		return 0;
 
 	if (color == MT_COLOR_INDEX) { /* buf might be uninitialized other cases */
@@ -132,7 +132,7 @@ add_index_color (char *buf, size_t buflen, format_flag flags, char color)
 	if (buflen < 2)
 		return 0;
 
-	buf[0] = M_SPECIAL_INDEX;
+	buf[0] = MUTT_SPECIAL_INDEX;
 	buf[1] = color;
 	buf[2] = '\0';
 
@@ -291,9 +291,9 @@ hdr_format_str (char *dest,
   CONTEXT *ctx;
   char fmt[SHORT_STRING], buf2[LONG_STRING], ch, *p;
   int do_locales, i;
-  int optional = (flags & M_FORMAT_OPTIONAL);
+  int optional = (flags & MUTT_FORMAT_OPTIONAL);
   int threads = ((Sort & SORT_MASK) == SORT_THREADS);
-  int is_index = (flags & M_FORMAT_INDEX);
+  int is_index = (flags & MUTT_FORMAT_INDEX);
 #define THREAD_NEW (threads && hdr->collapsed && hdr->num_hidden > 1 && mutt_thread_contains_unread (ctx, hdr) == 1)
 #define THREAD_OLD (threads && hdr->collapsed && hdr->num_hidden > 1 && mutt_thread_contains_unread (ctx, hdr) == 2)
   size_t len;
@@ -769,9 +769,9 @@ hdr_format_str (char *dest,
 
     case 's':
       
-      if (flags & M_FORMAT_TREE && !hdr->collapsed)
+      if (flags & MUTT_FORMAT_TREE && !hdr->collapsed)
       {
-	if (flags & M_FORMAT_FORCESUBJ)
+	if (flags & MUTT_FORMAT_FORCESUBJ)
 	{
 	  colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_SUBJECT);
 	  mutt_format_s (dest + colorlen, destlen - colorlen, "", NONULL (hdr->env->subject));
@@ -943,12 +943,12 @@ hdr_format_str (char *dest,
 
         i = 1;  /* reduce reuse recycle */
         htmp = NULL;
-        if ((flags & M_FORMAT_TREE) &&
+        if ((flags & MUTT_FORMAT_TREE) &&
             hdr->thread->prev &&
             hdr->thread->prev->message &&
             hdr->thread->prev->message->env->labels)
           htmp = hdr->thread->prev->message;
-        else if ((flags & M_FORMAT_TREE) &&
+        else if ((flags & MUTT_FORMAT_TREE) &&
                  hdr->thread->parent &&
                  hdr->thread->parent->message &&
                  hdr->thread->parent->message->env->labels)
@@ -1023,7 +1023,7 @@ hdr_format_str (char *dest,
 
   if (optional)
     mutt_FormatString (dest, destlen, col, cols, ifstring, hdr_format_str, (unsigned long) hfi, flags);
-  else if (flags & M_FORMAT_OPTIONAL)
+  else if (flags & MUTT_FORMAT_OPTIONAL)
     mutt_FormatString (dest, destlen, col, cols, elsestring, hdr_format_str, (unsigned long) hfi, flags);
 
   return (src);
diff --git a/headers.c b/headers.c
index b126c23..19546ce 100644
--- a/headers.c
+++ b/headers.c
@@ -316,7 +316,7 @@ int mutt_label_message(HEADER *hdr)
   if (buf[0])
     strcat(buf, ", ");    /* __STRCAT_CHECKED__ */
 
-  if (mutt_get_field("Label: ", buf, sizeof(buf), M_LABEL /* | M_CLEAR */) != 0)
+  if (mutt_get_field("Label: ", buf, sizeof(buf), MUTT_LABEL /* | MUTT_CLEAR */) != 0)
     return 0;
 
   new = buf;
@@ -347,7 +347,7 @@ int mutt_label_message(HEADER *hdr)
         if (label_message(HDR_OF(i), new)) {
           ++changed;
           mutt_set_flag(Context, HDR_OF(i),
-            M_TAG, 0);
+            MUTT_TAG, 0);
         }
     }
   }
diff --git a/help.c b/help.c
index 3f0cf95..ab3d0ff 100644
--- a/help.c
+++ b/help.c
@@ -377,7 +377,7 @@ void mutt_help (int menu)
   }
   while
     (mutt_do_pager (buf, t,
-		    M_PAGER_RETWINCH | M_PAGER_MARKER | M_PAGER_NSKIP | M_PAGER_NOWRAP,
+		    MUTT_PAGER_RETWINCH | MUTT_PAGER_MARKER | MUTT_PAGER_NSKIP | MUTT_PAGER_NOWRAP,
 		    NULL)
      == OP_REFORMAT_WINCH);
 }
diff --git a/hook.c b/hook.c
index 98c2f26..893bb88 100644
--- a/hook.c
+++ b/hook.c
@@ -74,7 +74,7 @@ int mutt_parse_hook (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
     goto error;
   }
 
-  mutt_extract_token (&command, s, (data & (M_FOLDERHOOK | M_SENDHOOK | M_SEND2HOOK | M_ACCOUNTHOOK | M_REPLYHOOK)) ?  M_TOKEN_SPACE : 0);
+  mutt_extract_token (&command, s, (data & (MUTT_FOLDERHOOK | MUTT_SENDHOOK | MUTT_SEND2HOOK | MUTT_ACCOUNTHOOK | MUTT_REPLYHOOK)) ?  MUTT_TOKEN_SPACE : 0);
 
   if (!command.data)
   {
@@ -88,7 +88,7 @@ int mutt_parse_hook (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
     goto error;
   }
 
-  if (data & (M_FOLDERHOOK | M_MBOXHOOK))
+  if (data & (MUTT_FOLDERHOOK | MUTT_MBOXHOOK))
   {
     /* Accidentally using the ^ mailbox shortcut in the .muttrc is a
      * common mistake */
@@ -114,15 +114,15 @@ int mutt_parse_hook (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
     pattern.data = safe_strdup (path);
   }
 #ifdef USE_COMPRESSED
-  else if (data & (M_APPENDHOOK | M_OPENHOOK | M_CLOSEHOOK)) {
+  else if (data & (MUTT_APPENDHOOK | MUTT_OPENHOOK | MUTT_CLOSEHOOK)) {
     if (comp_valid_command (command.data) == 0) {
       strfcpy (err->data, _("badly formatted command string"), err->dsize);
       return -1;
     }
   }
 #endif
-  else if (DefaultHook && !(data & (M_CHARSETHOOK | M_ICONVHOOK | M_ACCOUNTHOOK))
-           && (!WithCrypto || !(data & M_CRYPTHOOK))
+  else if (DefaultHook && !(data & (MUTT_CHARSETHOOK | MUTT_ICONVHOOK | MUTT_ACCOUNTHOOK))
+           && (!WithCrypto || !(data & MUTT_CRYPTHOOK))
       )
   {
     char tmp[HUGE_STRING];
@@ -138,7 +138,7 @@ int mutt_parse_hook (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
     pattern.data = safe_strdup (tmp);
   }
 
-  if (data & (M_MBOXHOOK | M_SAVEHOOK | M_FCCHOOK))
+  if (data & (MUTT_MBOXHOOK | MUTT_SAVEHOOK | MUTT_FCCHOOK))
   {
     strfcpy (path, command.data, sizeof (path));
     mutt_expand_path (path, sizeof (path));
@@ -154,7 +154,7 @@ int mutt_parse_hook (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
 	ptr->rx.not == not &&
 	!mutt_strcmp (pattern.data, ptr->rx.pattern))
     {
-      if (data & (M_FOLDERHOOK | M_SENDHOOK | M_SEND2HOOK | M_MESSAGEHOOK | M_ACCOUNTHOOK | M_REPLYHOOK | M_CRYPTHOOK))
+      if (data & (MUTT_FOLDERHOOK | MUTT_SENDHOOK | MUTT_SEND2HOOK | MUTT_MESSAGEHOOK | MUTT_ACCOUNTHOOK | MUTT_REPLYHOOK | MUTT_CRYPTHOOK))
       {
 	/* these hooks allow multiple commands with the same
 	 * pattern, so if we've already seen this pattern/command pair, just
@@ -183,10 +183,10 @@ int mutt_parse_hook (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
       break;
   }
 
-  if (data & (M_SENDHOOK | M_SEND2HOOK | M_SAVEHOOK | M_FCCHOOK | M_MESSAGEHOOK | M_REPLYHOOK))
+  if (data & (MUTT_SENDHOOK | MUTT_SEND2HOOK | MUTT_SAVEHOOK | MUTT_FCCHOOK | MUTT_MESSAGEHOOK | MUTT_REPLYHOOK))
   {
     if ((pat = mutt_pattern_comp (pattern.data,
-	   (data & (M_SENDHOOK | M_SEND2HOOK | M_FCCHOOK)) ? 0 : M_FULL_MSG,
+	   (data & (MUTT_SENDHOOK | MUTT_SEND2HOOK | MUTT_FCCHOOK)) ? 0 : MUTT_FULL_MSG,
 				  err)) == NULL)
       goto error;
   }
@@ -194,11 +194,11 @@ int mutt_parse_hook (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
   {
     /* Hooks not allowing full patterns: Check syntax of regexp */
     rx = safe_malloc (sizeof (regex_t));
-#ifdef M_CRYPTHOOK
-    if ((rc = REGCOMP (rx, NONULL(pattern.data), ((data & (M_CRYPTHOOK|M_CHARSETHOOK|M_ICONVHOOK)) ? REG_ICASE : 0))) != 0)
+#ifdef MUTT_CRYPTHOOK
+    if ((rc = REGCOMP (rx, NONULL(pattern.data), ((data & (MUTT_CRYPTHOOK|MUTT_CHARSETHOOK|MUTT_ICONVHOOK)) ? REG_ICASE : 0))) != 0)
 #else
-    if ((rc = REGCOMP (rx, NONULL(pattern.data), (data & (M_CHARSETHOOK|M_ICONVHOOK)) ? REG_ICASE : 0)) != 0)
-#endif /* M_CRYPTHOOK */
+    if ((rc = REGCOMP (rx, NONULL(pattern.data), (data & (MUTT_CHARSETHOOK|MUTT_ICONVHOOK)) ? REG_ICASE : 0)) != 0)
+#endif /* MUTT_CRYPTHOOK */
     {
       regerror (rc, rx, err->data, err->dsize);
       FREE (&rx);
@@ -309,7 +309,7 @@ void mutt_folder_hook (char *path)
   HOOK *tmp = Hooks;
   BUFFER err, token;
 
-  current_hook_type = M_FOLDERHOOK;
+  current_hook_type = MUTT_FOLDERHOOK;
 
   mutt_buffer_init (&err);
   err.dsize = STRING;
@@ -320,7 +320,7 @@ void mutt_folder_hook (char *path)
     if(!tmp->command)
       continue;
 
-    if (tmp->type & M_FOLDERHOOK)
+    if (tmp->type & MUTT_FOLDERHOOK)
     {
       if ((regexec (tmp->rx.rx, path, 0, NULL, 0) == 0) ^ tmp->rx.not)
       {
@@ -416,7 +416,7 @@ mutt_addr_hook (char *path, size_t pathlen, int type, CONTEXT *ctx, HEADER *hdr)
 void mutt_default_save (char *path, size_t pathlen, HEADER *hdr)
 {
   *path = 0;
-  if (mutt_addr_hook (path, pathlen, M_SAVEHOOK, Context, hdr) != 0)
+  if (mutt_addr_hook (path, pathlen, MUTT_SAVEHOOK, Context, hdr) != 0)
   {
     char tmp[_POSIX_PATH_MAX];
     ADDRESS *adr;
@@ -447,7 +447,7 @@ void mutt_select_fcc (char *path, size_t pathlen, HEADER *hdr)
   char buf[_POSIX_PATH_MAX];
   ENVELOPE *env = hdr->env;
 
-  if (mutt_addr_hook (path, pathlen, M_FCCHOOK, NULL, hdr) != 0)
+  if (mutt_addr_hook (path, pathlen, MUTT_FCCHOOK, NULL, hdr) != 0)
   {
     if ((option (OPTSAVENAME) || option (OPTFORCENAME)) &&
 	(env->to || env->cc || env->bcc))
@@ -493,17 +493,17 @@ static LIST *_mutt_list_hook (const char *match, int hook)
 
 char *mutt_charset_hook (const char *chs)
 {
-  return _mutt_string_hook (chs, M_CHARSETHOOK);
+  return _mutt_string_hook (chs, MUTT_CHARSETHOOK);
 }
 
 char *mutt_iconv_hook (const char *chs)
 {
-  return _mutt_string_hook (chs, M_ICONVHOOK);
+  return _mutt_string_hook (chs, MUTT_ICONVHOOK);
 }
 
 LIST *mutt_crypt_hook (ADDRESS *adr)
 {
-  return _mutt_list_hook (adr->mailbox, M_CRYPTHOOK);
+  return _mutt_list_hook (adr->mailbox, MUTT_CRYPTHOOK);
 }
 
 #ifdef USE_SOCKET
@@ -528,7 +528,7 @@ void mutt_account_hook (const char* url)
 
   for (hook = Hooks; hook; hook = hook->next)
   {
-    if (! (hook->command && (hook->type & M_ACCOUNTHOOK)))
+    if (! (hook->command && (hook->type & MUTT_ACCOUNTHOOK)))
       continue;
 
     if ((regexec (hook->rx.rx, url, 0, NULL, 0) == 0) ^ hook->rx.not)
diff --git a/imap/browse.c b/imap/browse.c
index 04d0c0b..e9b9b74 100644
--- a/imap/browse.c
+++ b/imap/browse.c
@@ -220,7 +220,7 @@ int imap_mailbox_state (const char* path, struct mailbox_state* state)
     dprint (1, (debugfile, "imap_mailbox_state: bad path %s\n", path));
     return -1;
   }
-  if (!(idata = imap_conn_find (&mx.account, M_IMAP_CONN_NONEW)))
+  if (!(idata = imap_conn_find (&mx.account, MUTT_IMAP_CONN_NONEW)))
   {
     dprint (2, (debugfile, "imap_mailbox_state: no open connection for %s\n",
 		path));
@@ -259,7 +259,7 @@ int imap_mailbox_create (const char* folder)
     return -1;
   }
 
-  if (!(idata = imap_conn_find (&mx.account, M_IMAP_CONN_NONEW)))
+  if (!(idata = imap_conn_find (&mx.account, MUTT_IMAP_CONN_NONEW)))
   {
     dprint (1, (debugfile, "imap_mailbox_create: Couldn't find open connection to %s", mx.account.host));
     goto fail;
@@ -275,7 +275,7 @@ int imap_mailbox_create (const char* folder)
     buf[n] = '\0';
   }
   
-  if (mutt_get_field (_("Create mailbox: "), buf, sizeof (buf), M_FILE) < 0)
+  if (mutt_get_field (_("Create mailbox: "), buf, sizeof (buf), MUTT_FILE) < 0)
     goto fail;
 
   if (!mutt_strlen (buf))
@@ -313,7 +313,7 @@ int imap_mailbox_rename(const char* mailbox)
     return -1;
   }
 
-  if (!(idata = imap_conn_find (&mx.account, M_IMAP_CONN_NONEW)))
+  if (!(idata = imap_conn_find (&mx.account, MUTT_IMAP_CONN_NONEW)))
   {
     dprint (1, (debugfile, "imap_mailbox_rename: Couldn't find open connection to %s", mx.account.host));
     goto fail;
@@ -328,7 +328,7 @@ int imap_mailbox_rename(const char* mailbox)
   snprintf(buf, sizeof (buf), _("Rename mailbox %s to: "), mx.mbox);
   strfcpy (newname, mx.mbox, sizeof (newname));
   
- if (mutt_get_field (buf, newname, sizeof (newname), M_FILE) < 0)
+ if (mutt_get_field (buf, newname, sizeof (newname), MUTT_FILE) < 0)
     goto fail;
 
   if (!mutt_strlen (newname))
diff --git a/imap/command.c b/imap/command.c
index 82c992c..f73e895 100644
--- a/imap/command.c
+++ b/imap/command.c
@@ -806,47 +806,47 @@ static void cmd_parse_myrights (IMAP_DATA* idata, const char* s)
     switch (*s) 
     {
       case 'l':
-	mutt_bit_set (idata->ctx->rights, M_ACL_LOOKUP);
+	mutt_bit_set (idata->ctx->rights, MUTT_ACL_LOOKUP);
 	break;
       case 'r':
-	mutt_bit_set (idata->ctx->rights, M_ACL_READ);
+	mutt_bit_set (idata->ctx->rights, MUTT_ACL_READ);
 	break;
       case 's':
-	mutt_bit_set (idata->ctx->rights, M_ACL_SEEN);
+	mutt_bit_set (idata->ctx->rights, MUTT_ACL_SEEN);
 	break;
       case 'w':
-	mutt_bit_set (idata->ctx->rights, M_ACL_WRITE);
+	mutt_bit_set (idata->ctx->rights, MUTT_ACL_WRITE);
 	break;
       case 'i':
-	mutt_bit_set (idata->ctx->rights, M_ACL_INSERT);
+	mutt_bit_set (idata->ctx->rights, MUTT_ACL_INSERT);
 	break;
       case 'p':
-	mutt_bit_set (idata->ctx->rights, M_ACL_POST);
+	mutt_bit_set (idata->ctx->rights, MUTT_ACL_POST);
 	break;
       case 'a':
-	mutt_bit_set (idata->ctx->rights, M_ACL_ADMIN);
+	mutt_bit_set (idata->ctx->rights, MUTT_ACL_ADMIN);
 	break;
       case 'k':
-	mutt_bit_set (idata->ctx->rights, M_ACL_CREATE);
+	mutt_bit_set (idata->ctx->rights, MUTT_ACL_CREATE);
         break;
       case 'x':
-        mutt_bit_set (idata->ctx->rights, M_ACL_DELMX);
+        mutt_bit_set (idata->ctx->rights, MUTT_ACL_DELMX);
         break;
       case 't':
-	mutt_bit_set (idata->ctx->rights, M_ACL_DELETE);
+	mutt_bit_set (idata->ctx->rights, MUTT_ACL_DELETE);
         break;
       case 'e':
-        mutt_bit_set (idata->ctx->rights, M_ACL_EXPUNGE);
+        mutt_bit_set (idata->ctx->rights, MUTT_ACL_EXPUNGE);
         break;
 
         /* obsolete rights */
       case 'c':
-	mutt_bit_set (idata->ctx->rights, M_ACL_CREATE);
-        mutt_bit_set (idata->ctx->rights, M_ACL_DELMX);
+	mutt_bit_set (idata->ctx->rights, MUTT_ACL_CREATE);
+        mutt_bit_set (idata->ctx->rights, MUTT_ACL_DELMX);
 	break;
       case 'd':
-	mutt_bit_set (idata->ctx->rights, M_ACL_DELETE);
-        mutt_bit_set (idata->ctx->rights, M_ACL_EXPUNGE);
+	mutt_bit_set (idata->ctx->rights, MUTT_ACL_DELETE);
+        mutt_bit_set (idata->ctx->rights, MUTT_ACL_EXPUNGE);
 	break;
       default:
         dprint(1, (debugfile, "Unknown right: %c\n", *s));
@@ -969,7 +969,7 @@ static void cmd_parse_status (IMAP_DATA* idata, char* s)
   /* should perhaps move this code back to imap_buffy_check */
   for (inc = Incoming; inc; inc = inc->next)
   {
-    if (inc->magic != M_IMAP)
+    if (inc->magic != MUTT_IMAP)
       continue;
     
     if (imap_parse_path (inc->path, &mx) < 0)
diff --git a/imap/imap.c b/imap/imap.c
index 5c85f0c..1a51a2e 100644
--- a/imap/imap.c
+++ b/imap/imap.c
@@ -68,7 +68,7 @@ int imap_access (const char* path, int flags)
     return -1;
 
   if (!(idata = imap_conn_find (&mx.account,
-    option (OPTIMAPPASSIVE) ? M_IMAP_CONN_NONEW : 0)))
+    option (OPTIMAPPASSIVE) ? MUTT_IMAP_CONN_NONEW : 0)))
   {
     FREE (&mx.mbox);
     return -1;
@@ -153,7 +153,7 @@ int imap_delete_mailbox (CONTEXT* ctx, IMAP_MBOX mx)
 
   if (!ctx || !ctx->data) {
     if (!(idata = imap_conn_find (&mx.account,
-          option (OPTIMAPPASSIVE) ? M_IMAP_CONN_NONEW : 0)))
+          option (OPTIMAPPASSIVE) ? MUTT_IMAP_CONN_NONEW : 0)))
     {
       FREE (&mx.mbox);
       return -1;
@@ -184,7 +184,7 @@ void imap_logout_all (void)
   {
     tmp = conn->next;
 
-    if (conn->account.type == M_ACCT_TYPE_IMAP && conn->fd >= 0)
+    if (conn->account.type == MUTT_ACCT_TYPE_IMAP && conn->fd >= 0)
     {
       mutt_message (_("Closing connection to %s..."), conn->account.host);
       imap_logout ((IMAP_DATA**) (void*) &conn->data);
@@ -332,7 +332,7 @@ IMAP_DATA* imap_conn_find (const ACCOUNT* account, int flags)
       memcpy (&conn->account, creds, sizeof (ACCOUNT));
 
     idata = (IMAP_DATA*)conn->data;
-    if (flags & M_IMAP_CONN_NONEW)
+    if (flags & MUTT_IMAP_CONN_NONEW)
     {
       if (!idata)
       {
@@ -343,7 +343,7 @@ IMAP_DATA* imap_conn_find (const ACCOUNT* account, int flags)
       else if (idata->state < IMAP_AUTHENTICATED)
         continue;
     }
-    if (flags & M_IMAP_CONN_NOSELECT && idata && idata->state >= IMAP_SELECTED)
+    if (flags & MUTT_IMAP_CONN_NOSELECT && idata && idata->state >= IMAP_SELECTED)
       continue;
     if (idata && idata->status == IMAP_FATAL)
       continue;
@@ -429,11 +429,11 @@ int imap_open_connection (IMAP_DATA* idata)
       int rc;
 
       if (option(OPTSSLFORCETLS))
-        rc = M_YES;
+        rc = MUTT_YES;
       else if ((rc = query_quadoption (OPT_SSLSTARTTLS,
         _("Secure connection with TLS?"))) == -1)
 	goto err_close_conn;
-      if (rc == M_YES) {
+      if (rc == MUTT_YES) {
 	if ((rc = imap_exec (idata, "STARTTLS", IMAP_CMD_FAIL_OK)) == -1)
 	  goto bail;
 	if (rc != -2)
@@ -571,7 +571,7 @@ int imap_open_mailbox (CONTEXT* ctx)
   }
 
   /* we require a connection which isn't currently in IMAP_SELECTED state */
-  if (!(idata = imap_conn_find (&(mx.account), M_IMAP_CONN_NOSELECT)))
+  if (!(idata = imap_conn_find (&(mx.account), MUTT_IMAP_CONN_NOSELECT)))
     goto fail_noidata;
   if (idata->state < IMAP_AUTHENTICATED)
     goto fail;
@@ -610,14 +610,14 @@ int imap_open_mailbox (CONTEXT* ctx)
   /* assume we have all rights if ACL is unavailable */
   else
   {
-    mutt_bit_set (idata->ctx->rights, M_ACL_LOOKUP);
-    mutt_bit_set (idata->ctx->rights, M_ACL_READ);
-    mutt_bit_set (idata->ctx->rights, M_ACL_SEEN);
-    mutt_bit_set (idata->ctx->rights, M_ACL_WRITE);
-    mutt_bit_set (idata->ctx->rights, M_ACL_INSERT);
-    mutt_bit_set (idata->ctx->rights, M_ACL_POST);
-    mutt_bit_set (idata->ctx->rights, M_ACL_CREATE);
-    mutt_bit_set (idata->ctx->rights, M_ACL_DELETE);
+    mutt_bit_set (idata->ctx->rights, MUTT_ACL_LOOKUP);
+    mutt_bit_set (idata->ctx->rights, MUTT_ACL_READ);
+    mutt_bit_set (idata->ctx->rights, MUTT_ACL_SEEN);
+    mutt_bit_set (idata->ctx->rights, MUTT_ACL_WRITE);
+    mutt_bit_set (idata->ctx->rights, MUTT_ACL_INSERT);
+    mutt_bit_set (idata->ctx->rights, MUTT_ACL_POST);
+    mutt_bit_set (idata->ctx->rights, MUTT_ACL_CREATE);
+    mutt_bit_set (idata->ctx->rights, MUTT_ACL_DELETE);
   }
   /* pipeline the postponed count if possible */
   pmx.mbox = NULL;
@@ -740,10 +740,10 @@ int imap_open_mailbox (CONTEXT* ctx)
   }
 #endif
 
-  if (!(mutt_bit_isset(idata->ctx->rights, M_ACL_DELETE) ||
-        mutt_bit_isset(idata->ctx->rights, M_ACL_SEEN) ||
-        mutt_bit_isset(idata->ctx->rights, M_ACL_WRITE) ||
-        mutt_bit_isset(idata->ctx->rights, M_ACL_INSERT)))
+  if (!(mutt_bit_isset(idata->ctx->rights, MUTT_ACL_DELETE) ||
+        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_SEEN) ||
+        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE) ||
+        mutt_bit_isset(idata->ctx->rights, MUTT_ACL_INSERT)))
      ctx->readonly = 1;
 
   ctx->hdrmax = count;
@@ -790,7 +790,7 @@ int imap_open_mailbox_append (CONTEXT *ctx)
     return -1;
   }
 
-  ctx->magic = M_IMAP;
+  ctx->magic = MUTT_IMAP;
   ctx->data = idata;
 
   imap_fix_path (idata, mx.mbox, mailbox, sizeof (mailbox));
@@ -884,34 +884,34 @@ static int imap_make_msg_set (IMAP_DATA* idata, BUFFER* buf, int flag,
     if (hdrs[n]->active)
       switch (flag)
       {
-        case M_DELETED:
+        case MUTT_DELETED:
           if (hdrs[n]->deleted != HEADER_DATA(hdrs[n])->deleted)
             match = invert ^ hdrs[n]->deleted;
 	  break;
-        case M_EXPIRED: /* imap_fast_trash version of M_DELETED */
+        case MUTT_EXPIRED: /* imap_fast_trash version of MUTT_DELETED */
 	  if (hdrs[n]->purged)
 	    break;
           if (hdrs[n]->deleted != HEADER_DATA(hdrs[n])->deleted)
             match = invert ^ (hdrs[n]->deleted && !hdrs[n]->appended);
 	  break;
-        case M_FLAG:
+        case MUTT_FLAG:
           if (hdrs[n]->flagged != HEADER_DATA(hdrs[n])->flagged)
             match = invert ^ hdrs[n]->flagged;
 	  break;
-        case M_OLD:
+        case MUTT_OLD:
           if (hdrs[n]->old != HEADER_DATA(hdrs[n])->old)
             match = invert ^ hdrs[n]->old;
 	  break;
-        case M_READ:
+        case MUTT_READ:
           if (hdrs[n]->read != HEADER_DATA(hdrs[n])->read)
             match = invert ^ hdrs[n]->read;
 	  break;
-        case M_REPLIED:
+        case MUTT_REPLIED:
           if (hdrs[n]->replied != HEADER_DATA(hdrs[n])->replied)
             match = invert ^ hdrs[n]->replied;
 	  break;
 
-        case M_TAG:
+        case MUTT_TAG:
 	  if (hdrs[n]->tagged)
 	    match = 1;
 	  break;
@@ -958,7 +958,7 @@ static int imap_make_msg_set (IMAP_DATA* idata, BUFFER* buf, int flag,
  *     pre, message set, post
  *   flag: enum of flag type on which to filter
  *   changed: include only changed messages in message set
- *   invert: invert sense of flag, eg M_READ matches unread messages
+ *   invert: invert sense of flag, eg MUTT_READ matches unread messages
  * Returns: number of matched messages, or -1 on failure */
 int imap_exec_msgset (IMAP_DATA* idata, const char* pre, const char* post,
                       int flag, int changed, int invert)
@@ -1066,19 +1066,19 @@ int imap_sync_message (IMAP_DATA *idata, HEADER *hdr, BUFFER *cmd,
 
   flags[0] = '\0';
 
-  imap_set_flag (idata, M_ACL_SEEN, hdr->read, "\\Seen ",
+  imap_set_flag (idata, MUTT_ACL_SEEN, hdr->read, "\\Seen ",
 		 flags, sizeof (flags));
-  imap_set_flag (idata, M_ACL_WRITE, hdr->old,
+  imap_set_flag (idata, MUTT_ACL_WRITE, hdr->old,
                  "Old ", flags, sizeof (flags));
-  imap_set_flag (idata, M_ACL_WRITE, hdr->flagged,
+  imap_set_flag (idata, MUTT_ACL_WRITE, hdr->flagged,
 		 "\\Flagged ", flags, sizeof (flags));
-  imap_set_flag (idata, M_ACL_WRITE, hdr->replied,
+  imap_set_flag (idata, MUTT_ACL_WRITE, hdr->replied,
 		 "\\Answered ", flags, sizeof (flags));
-  imap_set_flag (idata, M_ACL_DELETE, hdr->deleted,
+  imap_set_flag (idata, MUTT_ACL_DELETE, hdr->deleted,
 		 "\\Deleted ", flags, sizeof (flags));
 
   /* now make sure we don't lose custom tags */
-  if (mutt_bit_isset (idata->ctx->rights, M_ACL_WRITE))
+  if (mutt_bit_isset (idata->ctx->rights, MUTT_ACL_WRITE))
     imap_add_keywords (flags, hdr, idata->flags, sizeof (flags));
 
   mutt_remove_trailing_ws (flags);
@@ -1087,11 +1087,11 @@ int imap_sync_message (IMAP_DATA *idata, HEADER *hdr, BUFFER *cmd,
    * explicitly revoke all system flags (if we have permission) */
   if (!*flags)
   {
-    imap_set_flag (idata, M_ACL_SEEN, 1, "\\Seen ", flags, sizeof (flags));
-    imap_set_flag (idata, M_ACL_WRITE, 1, "Old ", flags, sizeof (flags));
-    imap_set_flag (idata, M_ACL_WRITE, 1, "\\Flagged ", flags, sizeof (flags));
-    imap_set_flag (idata, M_ACL_WRITE, 1, "\\Answered ", flags, sizeof (flags));
-    imap_set_flag (idata, M_ACL_DELETE, 1, "\\Deleted ", flags, sizeof (flags));
+    imap_set_flag (idata, MUTT_ACL_SEEN, 1, "\\Seen ", flags, sizeof (flags));
+    imap_set_flag (idata, MUTT_ACL_WRITE, 1, "Old ", flags, sizeof (flags));
+    imap_set_flag (idata, MUTT_ACL_WRITE, 1, "\\Flagged ", flags, sizeof (flags));
+    imap_set_flag (idata, MUTT_ACL_WRITE, 1, "\\Answered ", flags, sizeof (flags));
+    imap_set_flag (idata, MUTT_ACL_DELETE, 1, "\\Deleted ", flags, sizeof (flags));
 
     mutt_remove_trailing_ws (flags);
 
@@ -1108,11 +1108,11 @@ int imap_sync_message (IMAP_DATA *idata, HEADER *hdr, BUFFER *cmd,
   /* after all this it's still possible to have no flags, if you
    * have no ACL rights */
   if (*flags && (imap_exec (idata, cmd->data, 0) != 0) &&
-      err_continue && (*err_continue != M_YES))
+      err_continue && (*err_continue != MUTT_YES))
   {
     *err_continue = imap_continue ("imap_sync_message: STORE failed",
 				   idata->buf);
-    if (*err_continue != M_YES)
+    if (*err_continue != MUTT_YES)
       return -1;
   }
 
@@ -1134,7 +1134,7 @@ static int sync_helper (IMAP_DATA* idata, int right, int flag, const char* name)
   if (!mutt_bit_isset (idata->ctx->rights, right))
     return 0;
 
-  if (right == M_ACL_WRITE && !imap_has_flag (idata->flags, name))
+  if (right == MUTT_ACL_WRITE && !imap_has_flag (idata->flags, name))
     return 0;
 
   snprintf (buf, sizeof(buf), "+FLAGS.SILENT (%s)", name);
@@ -1181,10 +1181,10 @@ int imap_sync_mailbox (CONTEXT* ctx, int expunge, int* index_hint)
     return rc;
 
   /* if we are expunging anyway, we can do deleted messages very quickly... */
-  if (expunge && mutt_bit_isset (ctx->rights, M_ACL_DELETE))
+  if (expunge && mutt_bit_isset (ctx->rights, MUTT_ACL_DELETE))
   {
     if ((rc = imap_exec_msgset (idata, "UID STORE", "+FLAGS.SILENT (\\Deleted)",
-                                M_DELETED, 1, 0)) < 0)
+                                MUTT_DELETED, 1, 0)) < 0)
     {
       mutt_error (_("Expunge failed"));
       mutt_sleep (1);
@@ -1233,7 +1233,7 @@ int imap_sync_mailbox (CONTEXT* ctx, int expunge, int* index_hint)
         mutt_message (_("Saving changed messages... [%d/%d]"), n+1,
                       ctx->msgcount);
 	if (!appendctx)
-	  appendctx = mx_open_mailbox (ctx->path, M_APPEND | M_QUIET, NULL);
+	  appendctx = mx_open_mailbox (ctx->path, MUTT_APPEND | MUTT_QUIET, NULL);
 	if (!appendctx)
 	  dprint (1, (debugfile, "imap_sync_mailbox: Error opening mailbox in append mode\n"));
 	else
@@ -1260,15 +1260,15 @@ int imap_sync_mailbox (CONTEXT* ctx, int expunge, int* index_hint)
            mutt_get_sort_func (SORT_ORDER));
   }
 
-  rc = sync_helper (idata, M_ACL_DELETE, M_DELETED, "\\Deleted");
+  rc = sync_helper (idata, MUTT_ACL_DELETE, MUTT_DELETED, "\\Deleted");
   if (rc >= 0)
-    rc |= sync_helper (idata, M_ACL_WRITE, M_FLAG, "\\Flagged");
+    rc |= sync_helper (idata, MUTT_ACL_WRITE, MUTT_FLAG, "\\Flagged");
   if (rc >= 0)
-    rc |= sync_helper (idata, M_ACL_WRITE, M_OLD, "Old");
+    rc |= sync_helper (idata, MUTT_ACL_WRITE, MUTT_OLD, "Old");
   if (rc >= 0)
-    rc |= sync_helper (idata, M_ACL_SEEN, M_READ, "\\Seen");
+    rc |= sync_helper (idata, MUTT_ACL_SEEN, MUTT_READ, "\\Seen");
   if (rc >= 0)
-    rc |= sync_helper (idata, M_ACL_WRITE, M_REPLIED, "\\Answered");
+    rc |= sync_helper (idata, MUTT_ACL_WRITE, MUTT_REPLIED, "\\Answered");
 
   if (oldsort != Sort)
   {
@@ -1286,7 +1286,7 @@ int imap_sync_mailbox (CONTEXT* ctx, int expunge, int* index_hint)
   {
     if (ctx->closing)
     {
-      if (mutt_yesorno (_("Error saving flags. Close anyway?"), 0) == M_YES)
+      if (mutt_yesorno (_("Error saving flags. Close anyway?"), 0) == MUTT_YES)
       {
         rc = 0;
         idata->state = IMAP_AUTHENTICATED;
@@ -1315,7 +1315,7 @@ int imap_sync_mailbox (CONTEXT* ctx, int expunge, int* index_hint)
 
   /* We must send an EXPUNGE command if we're not closing. */
   if (expunge && !(ctx->closing) &&
-      mutt_bit_isset(ctx->rights, M_ACL_DELETE))
+      mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))
   {
     mutt_message _("Expunging messages from server...");
     /* Set expunge bit so we don't get spurious reopened messages */
@@ -1399,8 +1399,8 @@ int imap_close_mailbox (CONTEXT* ctx)
 /* use the NOOP or IDLE command to poll for new mail
  *
  * return values:
- *	M_REOPENED	mailbox has been externally modified
- *	M_NEW_MAIL	new mail has arrived!
+ *	MUTT_REOPENED	mailbox has been externally modified
+ *	MUTT_NEW_MAIL	new mail has arrived!
  *	0		no change
  *	-1		error
  */
@@ -1447,11 +1447,11 @@ int imap_check_mailbox (CONTEXT *ctx, int *index_hint, int force)
   imap_cmd_finish (idata);
 
   if (idata->check_status & IMAP_EXPUNGE_PENDING)
-    result = M_REOPENED;
+    result = MUTT_REOPENED;
   else if (idata->check_status & IMAP_NEWMAIL_PENDING)
-    result = M_NEW_MAIL;
+    result = MUTT_NEW_MAIL;
   else if (idata->check_status & IMAP_FLAGS_PENDING)
-    result = M_FLAGS;
+    result = MUTT_FLAGS;
 
   idata->check_status = 0;
 
@@ -1468,7 +1468,7 @@ static int imap_get_mailbox (const char* path, IMAP_DATA** hidata, char* buf, si
     dprint (1, (debugfile, "imap_get_mailbox: Error parsing %s\n", path));
     return -1;
   }
-  if (!(*hidata = imap_conn_find (&(mx.account), option (OPTIMAPPASSIVE) ? M_IMAP_CONN_NONEW : 0))
+  if (!(*hidata = imap_conn_find (&(mx.account), option (OPTIMAPPASSIVE) ? MUTT_IMAP_CONN_NONEW : 0))
       || (*hidata)->state < IMAP_AUTHENTICATED)
   {
     FREE (&mx.mbox);
@@ -1502,10 +1502,10 @@ int imap_buffy_check (int force)
     if (! mailbox->magic)
     {
       if (mx_is_imap (mailbox->path))
-        mailbox->magic = M_IMAP;
+        mailbox->magic = MUTT_IMAP;
     }
 
-    if (mailbox->magic != M_IMAP)
+    if (mailbox->magic != MUTT_IMAP)
       continue;
 
     mailbox->new = 0;
@@ -1564,7 +1564,7 @@ int imap_buffy_check (int force)
   /* collect results */
   for (mailbox = Incoming; mailbox; mailbox = mailbox->next)
   {
-    if (mailbox->magic == M_IMAP && mailbox->new)
+    if (mailbox->magic == MUTT_IMAP && mailbox->new)
       buffies++;
   }
 
@@ -1703,9 +1703,9 @@ static int do_search (const pattern_t* search, int allpats)
   {
     switch (pat->op)
     {
-      case M_BODY:
-      case M_HEADER:
-      case M_WHOLE_MSG:
+      case MUTT_BODY:
+      case MUTT_HEADER:
+      case MUTT_WHOLE_MSG:
         if (pat->stringmatch)
           rc++;
         break;
@@ -1746,7 +1746,7 @@ static int imap_compile_search (const pattern_t* pat, BUFFER* buf)
       {
         if (do_search (clause, 0))
         {
-          if (pat->op == M_OR && clauses > 1)
+          if (pat->op == MUTT_OR && clauses > 1)
             mutt_buffer_addstr (buf, "OR ");
           clauses--;
 
@@ -1770,7 +1770,7 @@ static int imap_compile_search (const pattern_t* pat, BUFFER* buf)
 
     switch (pat->op)
     {
-      case M_HEADER:
+      case MUTT_HEADER:
         mutt_buffer_addstr (buf, "HEADER ");
 
         /* extract header name */
@@ -1791,12 +1791,12 @@ static int imap_compile_search (const pattern_t* pat, BUFFER* buf)
         imap_quote_string (term, sizeof (term), delim);
         mutt_buffer_addstr (buf, term);
         break;
-      case M_BODY:
+      case MUTT_BODY:
         mutt_buffer_addstr (buf, "BODY ");
         imap_quote_string (term, sizeof (term), pat->p.str);
         mutt_buffer_addstr (buf, term);
         break;
-      case M_WHOLE_MSG:
+      case MUTT_WHOLE_MSG:
         mutt_buffer_addstr (buf, "TEXT ");
         imap_quote_string (term, sizeof (term), pat->p.str);
         mutt_buffer_addstr (buf, term);
@@ -1938,7 +1938,7 @@ imap_complete_hosts (char *dest, size_t len)
     ciss_url_t url;
     char urlstr[LONG_STRING];
 
-    if (conn->account.type != M_ACCT_TYPE_IMAP)
+    if (conn->account.type != MUTT_ACCT_TYPE_IMAP)
       continue;
 
     mutt_account_tourl (&conn->account, &url);
@@ -1982,7 +1982,7 @@ int imap_complete(char* dest, size_t dlen, char* path) {
 
   /* don't open a new socket just for completion. Instead complete over
    * known mailboxes/hooks/etc */
-  if (!(idata = imap_conn_find (&(mx.account), M_IMAP_CONN_NONEW)))
+  if (!(idata = imap_conn_find (&(mx.account), MUTT_IMAP_CONN_NONEW)))
   {
     FREE (&mx.mbox);
     strfcpy (dest, path, dlen);
@@ -2056,7 +2056,7 @@ int imap_complete(char* dest, size_t dlen, char* path) {
 int
 imap_fast_trash (void)
 {
-	if ((Context->magic == M_IMAP) && mx_is_imap (TrashPath)) {
+	if ((Context->magic == MUTT_IMAP) && mx_is_imap (TrashPath)) {
 		IMAP_MBOX mx;
 		IMAP_DATA *idata = (IMAP_DATA *) Context->data;
 		char mbox[LONG_STRING];
@@ -2073,7 +2073,7 @@ imap_fast_trash (void)
 					strfcpy (mbox, "INBOX", sizeof (mbox));
 				imap_munge_mbox_name (idata, mmbox, sizeof (mmbox), mbox);
 
-				rc = imap_exec_msgset (idata, "UID COPY", mmbox, M_EXPIRED, 0, 0);
+				rc = imap_exec_msgset (idata, "UID COPY", mmbox, MUTT_EXPIRED, 0, 0);
 				if (rc == 0) {
 					dprint (1, (debugfile, "imap_copy_messages: No messages del-tagged\n"));
 					rc = -1;
diff --git a/imap/imap_private.h b/imap/imap_private.h
index 1ea2864..b557974 100644
--- a/imap/imap_private.h
+++ b/imap/imap_private.h
@@ -121,8 +121,8 @@ enum
 };
 
 /* imap_conn_find flags */
-#define M_IMAP_CONN_NONEW    (1<<0)
-#define M_IMAP_CONN_NOSELECT (1<<1)
+#define MUTT_IMAP_CONN_NONEW    (1<<0)
+#define MUTT_IMAP_CONN_NOSELECT (1<<1)
 
 /* -- data structures -- */
 typedef struct
diff --git a/imap/message.c b/imap/message.c
index 3280f5d..cd31e84 100644
--- a/imap/message.c
+++ b/imap/message.c
@@ -140,7 +140,7 @@ int imap_read_headers (IMAP_DATA* idata, int msgbegin, int msgend)
     /* L10N:
        Comparing the cached data with the IMAP server's data */
     mutt_progress_init (&progress, _("Evaluating cache..."),
-			M_PROGRESS_MSG, ReadInc, msgend + 1);
+			MUTT_PROGRESS_MSG, ReadInc, msgend + 1);
 
     snprintf (buf, sizeof (buf),
       "UID FETCH 1:%u (UID FLAGS)", uidnext - 1);
@@ -230,7 +230,7 @@ int imap_read_headers (IMAP_DATA* idata, int msgbegin, int msgend)
 #endif /* USE_HCACHE */
 
   mutt_progress_init (&progress, _("Fetching message headers..."),
-		      M_PROGRESS_MSG, ReadInc, msgend + 1);
+		      MUTT_PROGRESS_MSG, ReadInc, msgend + 1);
 
   for (msgno = msgbegin; msgno <= msgend ; msgno++)
   {
@@ -499,7 +499,7 @@ int imap_fetch_message (MESSAGE *msg, CONTEXT *ctx, int msgno)
 	    goto bail;
 	  }
 	  mutt_progress_init (&progressbar, _("Fetching message..."),
-			      M_PROGRESS_SIZE, NetInc, bytes);
+			      MUTT_PROGRESS_SIZE, NetInc, bytes);
 	  if (imap_read_literal (msg->fp, idata, bytes, &progressbar) < 0)
 	    goto bail;
 	  /* pick up trailing line */
@@ -560,7 +560,7 @@ int imap_fetch_message (MESSAGE *msg, CONTEXT *ctx, int msgno)
   if (read != h->read)
   {
     h->read = read;
-    mutt_set_flag (ctx, h, M_NEW, read);
+    mutt_set_flag (ctx, h, MUTT_NEW, read);
   }
 
   h->lines = 0;
@@ -643,7 +643,7 @@ int imap_append_message (CONTEXT *ctx, MESSAGE *msg)
   rewind (fp);
 
   mutt_progress_init (&progressbar, _("Uploading message..."),
-		      M_PROGRESS_SIZE, NetInc, len);
+		      MUTT_PROGRESS_SIZE, NetInc, len);
 
   imap_munge_mbox_name (idata, mbox, sizeof (mbox), mailbox);
   imap_make_date (internaldate, msg->received);
@@ -748,7 +748,7 @@ int imap_copy_messages (CONTEXT* ctx, HEADER* h, char* dest, int delete)
   int rc;
   int n;
   IMAP_MBOX mx;
-  int err_continue = M_NO;
+  int err_continue = MUTT_NO;
   int triedcreate = 0;
 
   idata = (IMAP_DATA*) ctx->data;
@@ -810,7 +810,7 @@ int imap_copy_messages (CONTEXT* ctx, HEADER* h, char* dest, int delete)
         }
       }
 
-      rc = imap_exec_msgset (idata, "UID COPY", mmbox, M_TAG, 0, 0);
+      rc = imap_exec_msgset (idata, "UID COPY", mmbox, MUTT_TAG, 0, 0);
       if (!rc)
       {
         dprint (1, (debugfile, "imap_copy_messages: No messages tagged\n"));
@@ -886,18 +886,18 @@ int imap_copy_messages (CONTEXT* ctx, HEADER* h, char* dest, int delete)
       {
         if (ctx->hdrs[n]->tagged)
         {
-          mutt_set_flag (ctx, ctx->hdrs[n], M_DELETE, 1);
-          mutt_set_flag (ctx, ctx->hdrs[n], M_APPENDED, 1);
+          mutt_set_flag (ctx, ctx->hdrs[n], MUTT_DELETE, 1);
+          mutt_set_flag (ctx, ctx->hdrs[n], MUTT_APPENDED, 1);
           if (option (OPTDELETEUNTAG))
-            mutt_set_flag (ctx, ctx->hdrs[n], M_TAG, 0);
+            mutt_set_flag (ctx, ctx->hdrs[n], MUTT_TAG, 0);
         }
       }
     else
     {
-      mutt_set_flag (ctx, h, M_DELETE, 1);
-      mutt_set_flag (ctx, h, M_APPENDED, 1);
+      mutt_set_flag (ctx, h, MUTT_DELETE, 1);
+      mutt_set_flag (ctx, h, MUTT_APPENDED, 1);
       if (option (OPTDELETEUNTAG))
-        mutt_set_flag (ctx, h, M_TAG, 0);
+        mutt_set_flag (ctx, h, MUTT_TAG, 0);
     }
   }
 
@@ -1062,12 +1062,12 @@ char* imap_set_flags (IMAP_DATA* idata, HEADER* h, char* s)
   readonly = ctx->readonly;
   ctx->readonly = 0;
 
-  mutt_set_flag (ctx, h, M_NEW, !(hd->read || hd->old));
-  mutt_set_flag (ctx, h, M_OLD, hd->old);
-  mutt_set_flag (ctx, h, M_READ, hd->read);
-  mutt_set_flag (ctx, h, M_DELETE, hd->deleted);
-  mutt_set_flag (ctx, h, M_FLAG, hd->flagged);
-  mutt_set_flag (ctx, h, M_REPLIED, hd->replied);
+  mutt_set_flag (ctx, h, MUTT_NEW, !(hd->read || hd->old));
+  mutt_set_flag (ctx, h, MUTT_OLD, hd->old);
+  mutt_set_flag (ctx, h, MUTT_READ, hd->read);
+  mutt_set_flag (ctx, h, MUTT_DELETE, hd->deleted);
+  mutt_set_flag (ctx, h, MUTT_FLAG, hd->flagged);
+  mutt_set_flag (ctx, h, MUTT_REPLIED, hd->replied);
 
   /* this message is now definitively *not* changed (mutt_set_flag
    * marks things changed as a side-effect) */
diff --git a/imap/util.c b/imap/util.c
index ef8fee7..924d573 100644
--- a/imap/util.c
+++ b/imap/util.c
@@ -23,7 +23,7 @@
 #include "config.h"
 
 #include "mutt.h"
-#include "mx.h"	/* for M_IMAP */
+#include "mx.h"	/* for MUTT_IMAP */
 #include "url.h"
 #include "imap_private.h"
 #ifdef USE_HCACHE
@@ -61,7 +61,7 @@ int imap_expand_path (char* path, size_t len)
   if (imap_parse_path (path, &mx) < 0)
     return -1;
 
-  idata = imap_conn_find (&mx.account, M_IMAP_CONN_NONEW);
+  idata = imap_conn_find (&mx.account, MUTT_IMAP_CONN_NONEW);
   mutt_account_tourl (&mx.account, &url);
   imap_fix_path (idata, mx.mbox, fixedpath, sizeof (fixedpath));
   url.path = fixedpath;
@@ -195,7 +195,7 @@ int imap_parse_path (const char* path, IMAP_MBOX* mx)
   /* Defaults */
   memset(&mx->account, 0, sizeof(mx->account));
   mx->account.port = ImapPort;
-  mx->account.type = M_ACCT_TYPE_IMAP;
+  mx->account.type = MUTT_ACCT_TYPE_IMAP;
 
   c = safe_strdup (path);
   url_parse_ciss (&url, c);
@@ -210,7 +210,7 @@ int imap_parse_path (const char* path, IMAP_MBOX* mx)
     mx->mbox = safe_strdup (url.path);
 
     if (url.scheme == U_IMAPS)
-      mx->account.flags |= M_ACCT_SSL;
+      mx->account.flags |= MUTT_ACCT_SSL;
 
     FREE (&c);
   }
@@ -233,7 +233,7 @@ int imap_parse_path (const char* path, IMAP_MBOX* mx)
       *c = '\0';
       strfcpy (mx->account.user, tmp, sizeof (mx->account.user));
       strfcpy (tmp, c+1, sizeof (tmp));
-      mx->account.flags |= M_ACCT_USER;
+      mx->account.flags |= MUTT_ACCT_USER;
     }
 
     if ((n = sscanf (tmp, "%127[^:/]%127s", mx->account.host, tmp)) < 1)
@@ -245,11 +245,11 @@ int imap_parse_path (const char* path, IMAP_MBOX* mx)
 
     if (n > 1) {
       if (sscanf (tmp, ":%hu%127s", &(mx->account.port), tmp) >= 1)
-	mx->account.flags |= M_ACCT_PORT;
+	mx->account.flags |= MUTT_ACCT_PORT;
       if (sscanf (tmp, "/%s", tmp) == 1)
       {
 	if (!ascii_strncmp (tmp, "ssl", 3))
-	  mx->account.flags |= M_ACCT_SSL;
+	  mx->account.flags |= MUTT_ACCT_SSL;
 	else
 	{
 	  dprint (1, (debugfile, "imap_parse_path: Unknown connection type in %s\n", path));
@@ -260,7 +260,7 @@ int imap_parse_path (const char* path, IMAP_MBOX* mx)
     }
   }
 
-  if ((mx->account.flags & M_ACCT_SSL) && !(mx->account.flags & M_ACCT_PORT))
+  if ((mx->account.flags & MUTT_ACCT_SSL) && !(mx->account.flags & MUTT_ACCT_PORT))
     mx->account.port = ImapsPort;
 
   return 0;
@@ -748,7 +748,7 @@ void imap_keepalive (void)
   conn = mutt_socket_head ();
   while (conn)
   {
-    if (conn->account.type == M_ACCT_TYPE_IMAP)
+    if (conn->account.type == MUTT_ACCT_TYPE_IMAP)
     {
       int need_free = 0;
 
@@ -830,20 +830,20 @@ int imap_wait_keepalive (pid_t pid)
 
 void imap_allow_reopen (CONTEXT *ctx)
 {
-  if (ctx && ctx->magic == M_IMAP && CTX_DATA->ctx == ctx)
+  if (ctx && ctx->magic == MUTT_IMAP && CTX_DATA->ctx == ctx)
     CTX_DATA->reopen |= IMAP_REOPEN_ALLOW;
 }
 
 void imap_disallow_reopen (CONTEXT *ctx)
 {
-  if (ctx && ctx->magic == M_IMAP && CTX_DATA->ctx == ctx)
+  if (ctx && ctx->magic == MUTT_IMAP && CTX_DATA->ctx == ctx)
     CTX_DATA->reopen &= ~IMAP_REOPEN_ALLOW;
 }
 
 int imap_account_match (const ACCOUNT* a1, const ACCOUNT* a2)
 {
-  IMAP_DATA* a1_idata = imap_conn_find (a1, M_IMAP_CONN_NONEW);
-  IMAP_DATA* a2_idata = imap_conn_find (a2, M_IMAP_CONN_NONEW);
+  IMAP_DATA* a1_idata = imap_conn_find (a1, MUTT_IMAP_CONN_NONEW);
+  IMAP_DATA* a2_idata = imap_conn_find (a2, MUTT_IMAP_CONN_NONEW);
   const ACCOUNT* a1_canon = a1_idata == NULL ? a1 : &a1_idata->conn->account;
   const ACCOUNT* a2_canon = a2_idata == NULL ? a2 : &a2_idata->conn->account;
 
diff --git a/init.c b/init.c
index 90240de..c9a6dd2 100644
--- a/init.c
+++ b/init.c
@@ -116,12 +116,12 @@ int query_quadoption (int opt, const char *prompt)
 
   switch (v)
   {
-    case M_YES:
-    case M_NO:
+    case MUTT_YES:
+    case MUTT_NO:
       return (v);
 
     default:
-      v = mutt_yesorno (prompt, (v == M_ASKYES));
+      v = mutt_yesorno (prompt, (v == MUTT_ASKYES));
       mutt_window_clearline (MuttMessageWindow, 0);
       return (v);
   }
@@ -155,11 +155,11 @@ int mutt_extract_token (BUFFER *dest, BUFFER *tok, int flags)
   {
     if (!qc)
     {
-      if ((ISSPACE (ch) && !(flags & M_TOKEN_SPACE)) ||
-	  (ch == '#' && !(flags & M_TOKEN_COMMENT)) ||
-	  (ch == '=' && (flags & M_TOKEN_EQUAL)) ||
-	  (ch == ';' && !(flags & M_TOKEN_SEMICOLON)) ||
-	  ((flags & M_TOKEN_PATTERN) && strchr ("~%=!|", ch)))
+      if ((ISSPACE (ch) && !(flags & MUTT_TOKEN_SPACE)) ||
+	  (ch == '#' && !(flags & MUTT_TOKEN_COMMENT)) ||
+	  (ch == '=' && (flags & MUTT_TOKEN_EQUAL)) ||
+	  (ch == ';' && !(flags & MUTT_TOKEN_SEMICOLON)) ||
+	  ((flags & MUTT_TOKEN_PATTERN) && strchr ("~%=!|", ch)))
 	break;
     }
 
@@ -167,7 +167,7 @@ int mutt_extract_token (BUFFER *dest, BUFFER *tok, int flags)
 
     if (ch == qc)
       qc = 0; /* end of quote */
-    else if (!qc && (ch == '\'' || ch == '"') && !(flags & M_TOKEN_QUOTE))
+    else if (!qc && (ch == '\'' || ch == '"') && !(flags & MUTT_TOKEN_QUOTE))
       qc = ch;
     else if (ch == '\\' && qc != '\'')
     {
@@ -211,7 +211,7 @@ int mutt_extract_token (BUFFER *dest, BUFFER *tok, int flags)
 	    mutt_buffer_addch (dest, ch);
       }
     }
-    else if (ch == '^' && (flags & M_TOKEN_CONDENSE))
+    else if (ch == '^' && (flags & MUTT_TOKEN_CONDENSE))
     {
 	if (!*tok->dptr)
 	    return -1; /* premature end of token */
@@ -701,7 +701,7 @@ static int parse_ifdef (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
 			(data ? "ifndef" : "ifdef"));
 		return -1;
 	}
-	mutt_extract_token (tmp, s, M_TOKEN_SPACE);
+	mutt_extract_token (tmp, s, MUTT_TOKEN_SPACE);
 
         /* ifdef KNOWN_SYMBOL or ifndef UNKNOWN_SYMBOL */
 	if ((res && (data == 0)) || (!res && (data == 1))) {
@@ -827,7 +827,7 @@ static int parse_spam_list (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *
   /* Insist on at least one parameter */
   if (!MoreArgs(s))
   {
-    if (data == M_SPAM)
+    if (data == MUTT_SPAM)
       strfcpy(err->data, _("spam: no matching pattern"), err->dsize);
     else
       strfcpy(err->data, _("nospam: no matching pattern"), err->dsize);
@@ -837,8 +837,8 @@ static int parse_spam_list (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *
   /* Extract the first token, a regexp */
   mutt_extract_token (buf, s, 0);
 
-  /* data should be either M_SPAM or M_NOSPAM. M_SPAM is for spam commands. */
-  if (data == M_SPAM)
+  /* data should be either MUTT_SPAM or MUTT_NOSPAM. MUTT_SPAM is for spam commands. */
+  if (data == MUTT_SPAM)
   {
     /* If there's a second parameter, it's a template for the spam tag. */
     if (MoreArgs(s))
@@ -862,8 +862,8 @@ static int parse_spam_list (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *
     return 0;
   }
 
-  /* M_NOSPAM is for nospam commands. */
-  else if (data == M_NOSPAM)
+  /* MUTT_NOSPAM is for nospam commands. */
+  else if (data == MUTT_NOSPAM)
   {
     /* nospam only ever has one parameter. */
 
@@ -958,7 +958,7 @@ static int parse_group (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
     if (parse_group_context (&gc, buf, s, data, err) == -1)
       goto bail;
 
-    if (data == M_UNGROUP && !mutt_strcasecmp (buf->data, "*"))
+    if (data == MUTT_UNGROUP && !mutt_strcasecmp (buf->data, "*"))
     {
       if (mutt_group_context_clear (&gc) < 0)
 	goto bail;
@@ -975,14 +975,14 @@ static int parse_group (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
       {
 	case NONE:
 	  snprintf (err->data, err->dsize, _("%sgroup: missing -rx or -addr."),
-		   data == M_UNGROUP ? "un" : "");
+		   data == MUTT_UNGROUP ? "un" : "");
 	  goto bail;
 
 	case RX:
-	  if (data == M_GROUP &&
+	  if (data == MUTT_GROUP &&
 	      mutt_group_context_add_rx (gc, buf->data, REG_ICASE, err) != 0)
 	    goto bail;
-	  else if (data == M_UNGROUP &&
+	  else if (data == MUTT_UNGROUP &&
 		   mutt_group_context_remove_rx (gc, buf->data) < 0)
 	    goto bail;
 	  break;
@@ -996,9 +996,9 @@ static int parse_group (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
 		      data == 1 ? "un" : "", estr);
 	    goto bail;
 	  }
-	  if (data == M_GROUP)
+	  if (data == MUTT_GROUP)
 	    mutt_group_context_add_adrlist (gc, addr);
-	  else if (data == M_UNGROUP)
+	  else if (data == MUTT_UNGROUP)
 	    mutt_group_context_remove_adrlist (gc, addr);
 	  rfc822_free_address (&addr);
 	  break;
@@ -1445,7 +1445,7 @@ static int parse_alias (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
       set_option (OPTFORCEREDRAWINDEX);
   }
 
-  mutt_extract_token (buf, s, M_TOKEN_QUOTE | M_TOKEN_SPACE | M_TOKEN_SEMICOLON);
+  mutt_extract_token (buf, s, MUTT_TOKEN_QUOTE | MUTT_TOKEN_SPACE | MUTT_TOKEN_SEMICOLON);
   dprint (3, (debugfile, "parse_alias: Second token is '%s'.\n",
 	      buf->data));
 
@@ -1542,7 +1542,7 @@ static int parse_my_hdr (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err
   size_t keylen;
   char *p;
 
-  mutt_extract_token (buf, s, M_TOKEN_SPACE | M_TOKEN_QUOTE);
+  mutt_extract_token (buf, s, MUTT_TOKEN_SPACE | MUTT_TOKEN_QUOTE);
   if ((p = strpbrk (buf->data, ": \t")) == NULL || *p != ':')
   {
     strfcpy (err->data, _("invalid header field"), err->dsize);
@@ -1820,9 +1820,9 @@ static int parse_set (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
   {
     /* reset state variables */
     query = 0;
-    unset = data & M_SET_UNSET;
-    inv = data & M_SET_INV;
-    reset = data & M_SET_RESET;
+    unset = data & MUTT_SET_UNSET;
+    inv = data & MUTT_SET_INV;
+    reset = data & MUTT_SET_RESET;
     myvar = NULL;
 
     if (*s->dptr == '?')
@@ -1847,7 +1847,7 @@ static int parse_set (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
     }
 
     /* get the variable name */
-    mutt_extract_token (tmp, s, M_TOKEN_EQUAL);
+    mutt_extract_token (tmp, s, MUTT_TOKEN_EQUAL);
 
     if (!mutt_strncmp ("my_", tmp->data, 3))
       myvar = tmp->data;
@@ -2138,16 +2138,16 @@ static int parse_set (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
       {
 	switch (DefaultMagic)
 	{
-	  case M_MBOX:
+	  case MUTT_MBOX:
 	    p = "mbox";
 	    break;
-	  case M_MMDF:
+	  case MUTT_MMDF:
 	    p = "MMDF";
 	    break;
-	  case M_MH:
+	  case MUTT_MH:
 	    p = "MH";
 	    break;
-	  case M_MAILDIR:
+	  case MUTT_MAILDIR:
 	    p = "Maildir";
 	    break;
 	  default:
@@ -2248,13 +2248,13 @@ static int parse_set (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
 	s->dptr++;
 	mutt_extract_token (tmp, s, 0);
 	if (ascii_strcasecmp ("yes", tmp->data) == 0)
-	  set_quadoption (MuttVars[idx].data, M_YES);
+	  set_quadoption (MuttVars[idx].data, MUTT_YES);
 	else if (ascii_strcasecmp ("no", tmp->data) == 0)
-	  set_quadoption (MuttVars[idx].data, M_NO);
+	  set_quadoption (MuttVars[idx].data, MUTT_NO);
 	else if (ascii_strcasecmp ("ask-yes", tmp->data) == 0)
-	  set_quadoption (MuttVars[idx].data, M_ASKYES);
+	  set_quadoption (MuttVars[idx].data, MUTT_ASKYES);
 	else if (ascii_strcasecmp ("ask-no", tmp->data) == 0)
-	  set_quadoption (MuttVars[idx].data, M_ASKNO);
+	  set_quadoption (MuttVars[idx].data, MUTT_ASKNO);
 	else
 	{
 	  snprintf (err->data, err->dsize, _("%s: invalid value"), tmp->data);
@@ -2267,9 +2267,9 @@ static int parse_set (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
 	if (inv)
 	  toggle_quadoption (MuttVars[idx].data);
 	else if (unset)
-	  set_quadoption (MuttVars[idx].data, M_NO);
+	  set_quadoption (MuttVars[idx].data, MUTT_NO);
 	else
-	  set_quadoption (MuttVars[idx].data, M_YES);
+	  set_quadoption (MuttVars[idx].data, MUTT_YES);
       }
     }
     else if (DTYPE (MuttVars[idx].type) == DT_SORT)
@@ -2378,7 +2378,7 @@ static int source_rc (const char *rcfile, BUFFER *err)
   }
 
   mutt_buffer_init (&token);
-  while ((linebuf = mutt_read_line (linebuf, &buflen, f, &line, M_CONT)) != NULL)
+  while ((linebuf = mutt_read_line (linebuf, &buflen, f, &line, MUTT_CONT)) != NULL)
   {
     conv=ConfigCharset && (*ConfigCharset) && Charset;
     if (conv) 
@@ -3000,16 +3000,16 @@ static int var_to_string (int idx, char* val, size_t len)
 
     switch (DefaultMagic)
     {
-      case M_MBOX:
+      case MUTT_MBOX:
         p = "mbox";
         break;
-      case M_MMDF:
+      case MUTT_MMDF:
         p = "MMDF";
         break;
-      case M_MH:
+      case MUTT_MH:
         p = "MH";
         break;
-      case M_MAILDIR:
+      case MUTT_MAILDIR:
         p = "Maildir";
         break;
       default:
diff --git a/init.h b/init.h
index 4a73af1..d057c73 100644
--- a/init.h
+++ b/init.h
@@ -50,9 +50,9 @@
 #define DT_SORT_SIDEBAR	0x100
 
 /* flags to parse_set() */
-#define M_SET_INV	(1<<0)	/* default is to invert all vars */
-#define M_SET_UNSET	(1<<1)	/* default is to unset all vars */
-#define M_SET_RESET	(1<<2)	/* default is to reset all vars to default */
+#define MUTT_SET_INV	(1<<0)	/* default is to invert all vars */
+#define MUTT_SET_UNSET	(1<<1)	/* default is to unset all vars */
+#define MUTT_SET_RESET	(1<<2)	/* default is to reset all vars to default */
 
 /* forced redraw/resort types */
 #define R_NONE		0
@@ -85,7 +85,7 @@ struct option_t
 
 struct option_t MuttVars[] = {
   /*++*/
-  { "abort_nosubject",	DT_QUAD, R_NONE, OPT_SUBJECT, M_ASKYES },
+  { "abort_nosubject",	DT_QUAD, R_NONE, OPT_SUBJECT, MUTT_ASKYES },
   /*
   ** .pp
   ** If set to \fIyes\fP, when composing messages and no subject is given
@@ -93,7 +93,7 @@ struct option_t MuttVars[] = {
   ** \fIno\fP, composing messages with no subject given at the subject
   ** prompt will never be aborted.
   */
-  { "abort_unmodified",	DT_QUAD, R_NONE, OPT_ABORT, M_YES },
+  { "abort_unmodified",	DT_QUAD, R_NONE, OPT_ABORT, MUTT_YES },
   /*
   ** .pp
   ** If set to \fIyes\fP, composition will automatically abort after
@@ -315,7 +315,7 @@ struct option_t MuttVars[] = {
   ** notifying you of new mail.  This is independent of the setting of the
   ** $$beep variable.
   */
-  { "bounce",	DT_QUAD, R_NONE, OPT_BOUNCE, M_ASKYES },
+  { "bounce",	DT_QUAD, R_NONE, OPT_BOUNCE, MUTT_ASKYES },
   /*
   ** .pp
   ** Controls whether you will be asked to confirm bouncing messages.
@@ -339,7 +339,7 @@ struct option_t MuttVars[] = {
   ** visual terminals don't permit making the cursor invisible.
   */
 #ifdef USE_NNTP
-  { "catchup_newsgroup", DT_QUAD, R_NONE, OPT_CATCHUP, M_ASKYES },
+  { "catchup_newsgroup", DT_QUAD, R_NONE, OPT_CATCHUP, MUTT_ASKYES },
   /*
   ** .pp
   ** If this variable is \fIset\fP, Mutt will mark all articles in newsgroup
@@ -467,7 +467,7 @@ struct option_t MuttVars[] = {
   ** .pp
   ** Sets the default Content-Type for the body of newly composed messages.
   */
-  { "copy",		DT_QUAD, R_NONE, OPT_COPY, M_YES },
+  { "copy",		DT_QUAD, R_NONE, OPT_COPY, MUTT_YES },
   /*
   ** .pp
   ** This variable controls whether or not copies of your outgoing messages
@@ -604,7 +604,7 @@ struct option_t MuttVars[] = {
   ** verification (only supported by the GPGME backend).
   */
   { "pgp_verify_sig",   DT_SYN,  R_NONE, UL "crypt_verify_sig", 0},
-  { "crypt_verify_sig",	DT_QUAD, R_NONE, OPT_VERIFYSIG, M_YES },
+  { "crypt_verify_sig",	DT_QUAD, R_NONE, OPT_VERIFYSIG, MUTT_YES },
   /*
   ** .pp
   ** If \fI``yes''\fP, always attempt to verify PGP or S/MIME signatures.
@@ -642,7 +642,7 @@ struct option_t MuttVars[] = {
   ** ``$alternates'') and is to or cc'ed to a user matching the given
   ** regular expression.
   */
-  { "delete",		DT_QUAD, R_NONE, OPT_DELETE, M_ASKYES },
+  { "delete",		DT_QUAD, R_NONE, OPT_DELETE, MUTT_ASKYES },
   /*
   ** .pp
   ** Controls whether or not messages are really deleted when closing or
@@ -793,7 +793,7 @@ struct option_t MuttVars[] = {
   ** \fBNote:\fP this variable has no effect when the $$autoedit
   ** variable is \fIset\fP.
   */
-  { "fcc_attach",	DT_QUAD, R_NONE, OPT_FCCATTACH, M_YES },
+  { "fcc_attach",	DT_QUAD, R_NONE, OPT_FCCATTACH, MUTT_YES },
   /*
   ** .pp
   ** This variable controls whether or not attachments on outgoing messages
@@ -866,7 +866,7 @@ struct option_t MuttVars[] = {
   ** of the same email for you.
   */
 #ifdef USE_NNTP
-  { "followup_to_poster", DT_QUAD, R_NONE, OPT_FOLLOWUPTOPOSTER, M_ASKYES },
+  { "followup_to_poster", DT_QUAD, R_NONE, OPT_FOLLOWUPTOPOSTER, MUTT_ASKYES },
   /*
   ** .pp
   ** If this variable is \fIset\fP and the keyword "poster" is present in
@@ -907,7 +907,7 @@ struct option_t MuttVars[] = {
   { "forw_decrypt",	DT_SYN,  R_NONE, UL "forward_decrypt", 0 },
   /*
   */
-  { "forward_edit",	DT_QUAD, R_NONE, OPT_FORWEDIT, M_YES },
+  { "forward_edit",	DT_QUAD, R_NONE, OPT_FORWEDIT, MUTT_YES },
   /*
   ** .pp
   ** This quadoption controls whether or not the user is automatically
@@ -1107,7 +1107,7 @@ struct option_t MuttVars[] = {
   ** If \fIunset\fP, Mutt will render all MIME parts it can
   ** properly transform to plain text.
   */
-  { "honor_followup_to", DT_QUAD, R_NONE, OPT_MFUPTO, M_YES },
+  { "honor_followup_to", DT_QUAD, R_NONE, OPT_MFUPTO, MUTT_YES },
   /*
   ** .pp
   ** This variable controls whether or not a Mail-Followup-To header is
@@ -1317,7 +1317,7 @@ struct option_t MuttVars[] = {
   ** use the viewer defined in that entry to convert the body part to text
   ** form.
   */
-  { "include",		DT_QUAD, R_NONE, OPT_INCLUDE, M_ASKYES },
+  { "include",		DT_QUAD, R_NONE, OPT_INCLUDE, MUTT_ASKYES },
   /*
   ** .pp
   ** Controls whether or not a copy of the message(s) you are replying to
@@ -1586,7 +1586,7 @@ struct option_t MuttVars[] = {
   ** .pp
   ** Also see the $$move variable.
   */
-  { "mbox_type",	DT_MAGIC,R_NONE, UL &DefaultMagic, M_MBOX },
+  { "mbox_type",	DT_MAGIC,R_NONE, UL &DefaultMagic, MUTT_MBOX },
   /*
   ** .pp
   ** The default mailbox type used when creating new folders. May be any of
@@ -1690,7 +1690,7 @@ struct option_t MuttVars[] = {
   ** .pp
   ** The name of the MH sequence used for unseen messages.
   */
-  { "mime_forward",	DT_QUAD, R_NONE, OPT_MIMEFWD, M_NO },
+  { "mime_forward",	DT_QUAD, R_NONE, OPT_MIMEFWD, MUTT_NO },
   /*
   ** .pp
   ** When \fIset\fP, the message you are forwarding will be attached as a
@@ -1712,7 +1712,7 @@ struct option_t MuttVars[] = {
   { "mime_fwd",		DT_SYN,  R_NONE, UL "mime_forward", 0 },
   /*
   */
-  { "mime_forward_rest", DT_QUAD, R_NONE, OPT_MIMEFWDREST, M_YES },
+  { "mime_forward_rest", DT_QUAD, R_NONE, OPT_MIMEFWDREST, MUTT_YES },
   /*
   ** .pp
   ** When forwarding multiple attachments of a MIME message from the attachment
@@ -1751,7 +1751,7 @@ struct option_t MuttVars[] = {
   ** mixmaster chain.
   */
 #endif
-  { "move",		DT_QUAD, R_NONE, OPT_MOVE, M_NO },
+  { "move",		DT_QUAD, R_NONE, OPT_MOVE, MUTT_NO },
   /*
   ** .pp
   ** Controls whether or not Mutt will move read messages
@@ -2211,7 +2211,7 @@ struct option_t MuttVars[] = {
   ** in the key selection menu and a few other places.
   ** (PGP only)
   */
-  { "pgp_mime_auto", DT_QUAD, R_NONE, OPT_PGPMIMEAUTO, M_ASKYES },
+  { "pgp_mime_auto", DT_QUAD, R_NONE, OPT_PGPMIMEAUTO, MUTT_ASKYES },
   /*
   ** .pp
   ** This option controls whether Mutt will prompt you for
@@ -2397,7 +2397,7 @@ struct option_t MuttVars[] = {
   ** This variable configures how often (in seconds) mutt should look for
   ** new mail in the currently selected mailbox if it is a POP mailbox.
   */
-  { "pop_delete",	DT_QUAD, R_NONE, OPT_POPDELETE, M_ASKNO },
+  { "pop_delete",	DT_QUAD, R_NONE, OPT_POPDELETE, MUTT_ASKNO },
   /*
   ** .pp
   ** If \fIset\fP, Mutt will delete successfully downloaded messages from the POP
@@ -2432,7 +2432,7 @@ struct option_t MuttVars[] = {
   ** fairly secure machine, because the superuser can read your muttrc
   ** even if you are the only one who can read the file.
   */
-  { "pop_reconnect",	DT_QUAD, R_NONE, OPT_POPRECONNECT, M_ASKYES },
+  { "pop_reconnect",	DT_QUAD, R_NONE, OPT_POPRECONNECT, MUTT_ASKYES },
   /*
   ** .pp
   ** Controls whether or not Mutt will try to reconnect to the POP server if
@@ -2456,7 +2456,7 @@ struct option_t MuttVars[] = {
   /*
   */
 #ifdef USE_NNTP
-  { "post_moderated",	DT_QUAD, R_NONE, OPT_TOMODERATED, M_ASKYES },
+  { "post_moderated",	DT_QUAD, R_NONE, OPT_TOMODERATED, MUTT_ASKYES },
   /*
   ** .pp
   ** If set to \fIyes\fP, Mutt will post article to newsgroup that have
@@ -2465,7 +2465,7 @@ struct option_t MuttVars[] = {
   ** posting will not have an effect.
   */
 #endif
-  { "postpone",		DT_QUAD, R_NONE, OPT_POSTPONE, M_ASKYES },
+  { "postpone",		DT_QUAD, R_NONE, OPT_POSTPONE, MUTT_ASKYES },
   /*
   ** .pp
   ** Controls whether or not messages are saved in the $$postponed
@@ -2517,7 +2517,7 @@ struct option_t MuttVars[] = {
   ** remote machine without having to enter a password.
   */
 #endif /* USE_SOCKET */
-  { "print",		DT_QUAD, R_NONE, OPT_PRINT, M_ASKNO },
+  { "print",		DT_QUAD, R_NONE, OPT_PRINT, MUTT_ASKNO },
   /*
   ** .pp
   ** Controls whether or not Mutt really prints messages.
@@ -2595,7 +2595,7 @@ struct option_t MuttVars[] = {
   ** .pp
   ** * = can be optionally printed if nonzero, see the $$status_format documentation.
   */
-  { "quit",		DT_QUAD, R_NONE, OPT_QUIT, M_YES },
+  { "quit",		DT_QUAD, R_NONE, OPT_QUIT, MUTT_YES },
   /*
   ** .pp
   ** This variable controls whether ``quit'' and ``exit'' actually quit
@@ -2649,7 +2649,7 @@ struct option_t MuttVars[] = {
   ** variable will \fInot\fP be used when the user has set a real name
   ** in the $$from variable.
   */
-  { "recall",		DT_QUAD, R_NONE, OPT_RECALL, M_ASKYES },
+  { "recall",		DT_QUAD, R_NONE, OPT_RECALL, MUTT_ASKYES },
   /*
   ** .pp
   ** Controls whether or not Mutt recalls postponed messages
@@ -2720,7 +2720,7 @@ struct option_t MuttVars[] = {
   ** .pp
   ** Also see the ``$alternates'' command.
   */
-  { "reply_to",		DT_QUAD, R_NONE, OPT_REPLYTO, M_ASKYES },
+  { "reply_to",		DT_QUAD, R_NONE, OPT_REPLYTO, MUTT_ASKYES },
   /*
   ** .pp
   ** If \fIset\fP, when replying to a message, Mutt will use the address listed
@@ -3570,7 +3570,7 @@ struct option_t MuttVars[] = {
   ** the default from the GNUTLS library.
   */
 # endif /* USE_SSL_GNUTLS */
-  { "ssl_starttls", DT_QUAD, R_NONE, OPT_SSLSTARTTLS, M_YES },
+  { "ssl_starttls", DT_QUAD, R_NONE, OPT_SSLSTARTTLS, MUTT_YES },
   /*
   ** .pp
   ** If \fIset\fP (the default), mutt will attempt to use \fCSTARTTLS\fP on servers
@@ -4223,7 +4223,7 @@ const struct command_t Commands[] = {
   { "alternates",	parse_alternates,	0 },
   { "unalternates",	parse_unalternates,	0 },
 #ifdef USE_SOCKET
-  { "account-hook",     mutt_parse_hook,        M_ACCOUNTHOOK },
+  { "account-hook",     mutt_parse_hook,        MUTT_ACCOUNTHOOK },
 #endif
   { "alias",		parse_alias,		0 },
   { "attachments",	parse_attachments,	0 },
@@ -4231,34 +4231,34 @@ const struct command_t Commands[] = {
   { "auto_view",	parse_list,		UL &AutoViewList },
   { "alternative_order",	parse_list,	UL &AlternativeOrderList},
   { "bind",		mutt_parse_bind,	0 },
-  { "charset-hook",	mutt_parse_hook,	M_CHARSETHOOK },
+  { "charset-hook",	mutt_parse_hook,	MUTT_CHARSETHOOK },
 #ifdef HAVE_COLOR
   { "color",		mutt_parse_color,	0 },
   { "uncolor",		mutt_parse_uncolor,	0 },
 #endif
   { "exec",		mutt_parse_exec,	0 },
-  { "fcc-hook",		mutt_parse_hook,	M_FCCHOOK },
-  { "fcc-save-hook",	mutt_parse_hook,	M_FCCHOOK | M_SAVEHOOK },
-  { "folder-hook",	mutt_parse_hook,	M_FOLDERHOOK },
+  { "fcc-hook",		mutt_parse_hook,	MUTT_FCCHOOK },
+  { "fcc-save-hook",	mutt_parse_hook,	MUTT_FCCHOOK | MUTT_SAVEHOOK },
+  { "folder-hook",	mutt_parse_hook,	MUTT_FOLDERHOOK },
 #ifdef USE_COMPRESSED
-  { "open-hook",	mutt_parse_hook,	M_OPENHOOK },
-  { "close-hook",	mutt_parse_hook,	M_CLOSEHOOK },
-  { "append-hook",	mutt_parse_hook,	M_APPENDHOOK },
+  { "open-hook",	mutt_parse_hook,	MUTT_OPENHOOK },
+  { "close-hook",	mutt_parse_hook,	MUTT_CLOSEHOOK },
+  { "append-hook",	mutt_parse_hook,	MUTT_APPENDHOOK },
 #endif
-  { "group",		parse_group,		M_GROUP },
-  { "ungroup",		parse_group,		M_UNGROUP },
+  { "group",		parse_group,		MUTT_GROUP },
+  { "ungroup",		parse_group,		MUTT_UNGROUP },
   { "hdr_order",	parse_list,		UL &HeaderOrderList },
   { "ifdef",		parse_ifdef,		0 },
   { "ifndef",		parse_ifdef,		1 },
   { "finish",		finish_source,		0 },
 #ifdef HAVE_ICONV
-  { "iconv-hook",	mutt_parse_hook,	M_ICONVHOOK },
+  { "iconv-hook",	mutt_parse_hook,	MUTT_ICONVHOOK },
 #endif
   { "ignore",		parse_ignore,		0 },
   { "lists",		parse_lists,		0 },
   { "macro",		mutt_parse_macro,	0 },
-  { "mailboxes",	mutt_parse_mailboxes,	M_MAILBOXES },
-  { "unmailboxes",	mutt_parse_mailboxes,	M_UNMAILBOXES },
+  { "mailboxes",	mutt_parse_mailboxes,	MUTT_MAILBOXES },
+  { "unmailboxes",	mutt_parse_mailboxes,	MUTT_UNMAILBOXES },
 #ifdef USE_NOTMUCH
   { "virtual-mailboxes",mutt_parse_virtual_mailboxes, 0 },
   { "tag-transforms",	parse_tag_transforms,	0 },
@@ -4266,30 +4266,30 @@ const struct command_t Commands[] = {
 #endif
   { "mailto_allow",	parse_list,		UL &MailtoAllow },
   { "unmailto_allow",	parse_unlist,		UL &MailtoAllow },
-  { "message-hook",	mutt_parse_hook,	M_MESSAGEHOOK },
-  { "mbox-hook",	mutt_parse_hook,	M_MBOXHOOK },
+  { "message-hook",	mutt_parse_hook,	MUTT_MESSAGEHOOK },
+  { "mbox-hook",	mutt_parse_hook,	MUTT_MBOXHOOK },
   { "mime_lookup",	parse_list,	UL &MimeLookupList },
   { "unmime_lookup",	parse_unlist,	UL &MimeLookupList },
   { "mono",		mutt_parse_mono,	0 },
   { "my_hdr",		parse_my_hdr,		0 },
-  { "pgp-hook",		mutt_parse_hook,	M_CRYPTHOOK },
-  { "crypt-hook",	mutt_parse_hook,	M_CRYPTHOOK },
+  { "pgp-hook",		mutt_parse_hook,	MUTT_CRYPTHOOK },
+  { "crypt-hook",	mutt_parse_hook,	MUTT_CRYPTHOOK },
   { "push",		mutt_parse_push,	0 },
-  { "reply-hook",	mutt_parse_hook,	M_REPLYHOOK },
-  { "reset",		parse_set,		M_SET_RESET },
-  { "save-hook",	mutt_parse_hook,	M_SAVEHOOK },
+  { "reply-hook",	mutt_parse_hook,	MUTT_REPLYHOOK },
+  { "reset",		parse_set,		MUTT_SET_RESET },
+  { "save-hook",	mutt_parse_hook,	MUTT_SAVEHOOK },
   { "score",		mutt_parse_score,	0 },
-  { "send-hook",	mutt_parse_hook,	M_SENDHOOK },
-  { "send2-hook",	mutt_parse_hook,	M_SEND2HOOK },
+  { "send-hook",	mutt_parse_hook,	MUTT_SENDHOOK },
+  { "send2-hook",	mutt_parse_hook,	MUTT_SEND2HOOK },
   { "set",		parse_set,		0 },
 #ifdef USE_SIDEBAR
   { "sidebar_whitelist",parse_list,		UL &SidebarWhitelist },
 #endif
   { "source",		parse_source,		0 },
-  { "spam",		parse_spam_list,	M_SPAM },
-  { "nospam",		parse_spam_list,	M_NOSPAM },
+  { "spam",		parse_spam_list,	MUTT_SPAM },
+  { "nospam",		parse_spam_list,	MUTT_NOSPAM },
   { "subscribe",	parse_subscribe,	0 },
-  { "toggle",		parse_set,		M_SET_INV },
+  { "toggle",		parse_set,		MUTT_SET_INV },
   { "unalias",		parse_unalias,		0 },
   { "unalternative_order",parse_unlist,		UL &AlternativeOrderList },
   { "unauto_view",	parse_unlist,		UL &AutoViewList },
@@ -4300,7 +4300,7 @@ const struct command_t Commands[] = {
   { "unmono",		mutt_parse_unmono,	0 },
   { "unmy_hdr",		parse_unmy_hdr,		0 },
   { "unscore",		mutt_parse_unscore,	0 },
-  { "unset",		parse_set,		M_SET_UNSET },
+  { "unset",		parse_set,		MUTT_SET_UNSET },
   { "unsubscribe",	parse_unsubscribe,	0 },
   { NULL,		NULL,			0 }
 };
diff --git a/keymap.c b/keymap.c
index e305bcd..4bbc4d9 100644
--- a/keymap.c
+++ b/keymap.c
@@ -864,7 +864,7 @@ int mutt_parse_push (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
 {
   int r = 0;
 
-  mutt_extract_token (buf, s, M_TOKEN_CONDENSE);
+  mutt_extract_token (buf, s, MUTT_TOKEN_CONDENSE);
   if (MoreArgs (s))
   {
     strfcpy (err->data, _("push: too many arguments"), err->dsize);
@@ -1042,7 +1042,7 @@ int mutt_parse_macro (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
   if ((key = parse_keymap (menu, s, sizeof (menu) / sizeof (menu[0]), &nummenus, err)) == NULL)
     return (-1);
 
-  mutt_extract_token (buf, s, M_TOKEN_CONDENSE);
+  mutt_extract_token (buf, s, MUTT_TOKEN_CONDENSE);
   /* make sure the macro sequence is not an empty string */
   if (!*buf->data)
   {
@@ -1053,7 +1053,7 @@ int mutt_parse_macro (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
     if (MoreArgs (s))
     {
       seq = safe_strdup (buf->data);
-      mutt_extract_token (buf, s, M_TOKEN_CONDENSE);
+      mutt_extract_token (buf, s, MUTT_TOKEN_CONDENSE);
 
       if (MoreArgs (s))
       {
diff --git a/lib.c b/lib.c
index fa3067e..5f7c38f 100644
--- a/lib.c
+++ b/lib.c
@@ -765,12 +765,12 @@ char *mutt_read_line (char *s, size_t *size, FILE *fp, int *line, int flags)
     {
       if (line)
 	(*line)++;
-      if (flags & M_EOL)
+      if (flags & MUTT_EOL)
 	return s;
       *ch = 0;
       if (ch > s && *(ch - 1) == '\r')
 	*--ch = 0;
-      if (!(flags & M_CONT) || ch == s || *(ch - 1) != '\\')
+      if (!(flags & MUTT_CONT) || ch == s || *(ch - 1) != '\\')
 	return s;
       offset = ch - s - 1;
     }
diff --git a/lib.h b/lib.h
index eddfc70..84d33b5 100644
--- a/lib.h
+++ b/lib.h
@@ -160,8 +160,8 @@ void mutt_debug (FILE *, const char *, ...);
 #define S_BKG 126
 
 /* Flags for mutt_read_line() */
-#define M_CONT		(1<<0)		/* \-continuation */
-#define M_EOL		(1<<1)		/* don't strip \n/\r\n */
+#define MUTT_CONT		(1<<0)		/* \-continuation */
+#define MUTT_EOL		(1<<1)		/* don't strip \n/\r\n */
 
 /* The actual library functions. */
 
diff --git a/mailbox.h b/mailbox.h
index ec1e0e2..579b5ad 100644
--- a/mailbox.h
+++ b/mailbox.h
@@ -20,28 +20,28 @@
 #define _MAILBOX_H
 
 /* flags for mutt_open_mailbox() */
-#define M_NOSORT	(1<<0) /* do not sort the mailbox after opening it */
-#define M_APPEND	(1<<1) /* open mailbox for appending messages */
-#define M_READONLY	(1<<2) /* open in read-only mode */
-#define M_QUIET		(1<<3) /* do not print any messages */
-#define M_NEWFOLDER	(1<<4) /* create a new folder - same as M_APPEND, but uses
+#define MUTT_NOSORT	(1<<0) /* do not sort the mailbox after opening it */
+#define MUTT_APPEND	(1<<1) /* open mailbox for appending messages */
+#define MUTT_READONLY	(1<<2) /* open in read-only mode */
+#define MUTT_QUIET		(1<<3) /* do not print any messages */
+#define MUTT_NEWFOLDER	(1<<4) /* create a new folder - same as MUTT_APPEND, but uses
 				* safe_fopen() for mbox-style folders.
 				*/
 #ifdef USE_SIDEBAR
-#define M_PEEK		(1<<5) /* revert atime back after taking a look (if applicable) */
+#define MUTT_PEEK	(1<<5) /* revert atime back after taking a look (if applicable) */
 #endif
 
 /* mx_open_new_message() */
-#define M_ADD_FROM	(1<<0)	/* add a From_ line */
-#define M_SET_DRAFT	(1<<1)	/* set the message draft flag */
+#define MUTT_ADD_FROM	(1<<0)	/* add a From_ line */
+#define MUTT_SET_DRAFT	(1<<1)	/* set the message draft flag */
 
 /* return values from mx_check_mailbox() */
 enum
 {
-  M_NEW_MAIL = 1,	/* new mail received in mailbox */
-  M_LOCKED,		/* couldn't lock the mailbox */
-  M_REOPENED,		/* mailbox was reopened */
-  M_FLAGS               /* nondestructive flags change (IMAP) */
+  MUTT_NEW_MAIL = 1,	/* new mail received in mailbox */
+  MUTT_LOCKED,		/* couldn't lock the mailbox */
+  MUTT_REOPENED,		/* mailbox was reopened */
+  MUTT_FLAGS               /* nondestructive flags change (IMAP) */
 };
 
 typedef struct
diff --git a/main.c b/main.c
index a0e62fc..55ebcc3 100644
--- a/main.c
+++ b/main.c
@@ -168,13 +168,13 @@ init_extended_keys();
   mutt_init_windows ();
 }
 
-#define M_IGNORE  (1<<0)	/* -z */
-#define M_BUFFY   (1<<1)	/* -Z */
-#define M_NOSYSRC (1<<2)	/* -n */
-#define M_RO      (1<<3)	/* -R */
-#define M_SELECT  (1<<4)	/* -y */
+#define MUTT_IGNORE  (1<<0)	/* -z */
+#define MUTT_BUFFY   (1<<1)	/* -Z */
+#define MUTT_NOSYSRC (1<<2)	/* -n */
+#define MUTT_RO      (1<<3)	/* -R */
+#define MUTT_SELECT  (1<<4)	/* -y */
 #ifdef USE_NNTP
-#define M_NEWS    (1<<5)	/* -g and -G */
+#define MUTT_NEWS    (1<<5)	/* -g and -G */
 #endif
 
 int main (int argc, char **argv)
@@ -327,7 +327,7 @@ int main (int argc, char **argv)
 	break;
 
       case 'n':
-	flags |= M_NOSYSRC;
+	flags |= MUTT_NOSYSRC;
 	break;
 
       case 'p':
@@ -339,7 +339,7 @@ int main (int argc, char **argv)
         break;
       
       case 'R':
-	flags |= M_RO; /* read-only mode */
+	flags |= MUTT_RO; /* read-only mode */
 	break;
 
       case 's':
@@ -355,7 +355,7 @@ int main (int argc, char **argv)
 	break;
 
       case 'y': /* My special hack mode */
-	flags |= M_SELECT;
+	flags |= MUTT_SELECT;
 	break;
 
 #ifdef USE_NNTP
@@ -368,16 +368,16 @@ int main (int argc, char **argv)
 	}
 
       case 'G': /* List of newsgroups */
-	flags |= M_SELECT | M_NEWS;
+	flags |= MUTT_SELECT | MUTT_NEWS;
 	break;
 #endif
 
       case 'z':
-	flags |= M_IGNORE;
+	flags |= MUTT_IGNORE;
 	break;
 
       case 'Z':
-	flags |= M_BUFFY | M_IGNORE;
+	flags |= MUTT_BUFFY | MUTT_IGNORE;
 	break;
 
       default:
@@ -421,7 +421,7 @@ int main (int argc, char **argv)
   }
 
   /* set defaults and read init files */
-  mutt_init (flags & M_NOSYSRC, commands);
+  mutt_init (flags & MUTT_NOSYSRC, commands);
   mutt_free_list (&commands);
 
   /* Initialize crypto backends.  */
@@ -486,7 +486,7 @@ int main (int argc, char **argv)
     if (stat (fpath, &sb) == -1 && errno == ENOENT)
     {
       snprintf (msg, sizeof (msg), _("%s does not exist. Create it?"), Maildir);
-      if (mutt_yesorno (msg, M_YES) == M_YES)
+      if (mutt_yesorno (msg, MUTT_YES) == MUTT_YES)
       {
 	if (mkdir (fpath, 0700) == -1 && errno != EEXIST)
 	  mutt_error ( _("Can't create %s: %s."), Maildir, strerror (errno));
@@ -799,7 +799,7 @@ int main (int argc, char **argv)
   }
   else
   {
-    if (flags & M_BUFFY)
+    if (flags & MUTT_BUFFY)
     {
       if (!mutt_buffy_check (0))
       {
@@ -809,10 +809,10 @@ int main (int argc, char **argv)
       folder[0] = 0;
       mutt_buffy (folder, sizeof (folder));
     }
-    else if (flags & M_SELECT)
+    else if (flags & MUTT_SELECT)
     {
 #ifdef USE_NNTP
-      if (flags & M_NEWS)
+      if (flags & MUTT_NEWS)
       {
 	set_option (OPTNEWS);
 	if(!(CurrentNewsSrv = nntp_select_server (NewsServer, 0)))
@@ -828,7 +828,7 @@ int main (int argc, char **argv)
 	exit (1);
       }
       folder[0] = 0;
-      mutt_select_file (folder, sizeof (folder), M_SEL_FOLDER | M_SEL_BUFFY);
+      mutt_select_file (folder, sizeof (folder), MUTT_SEL_FOLDER | MUTT_SEL_BUFFY);
       if (!folder[0])
       {
 	mutt_endwin (NULL);
@@ -861,7 +861,7 @@ int main (int argc, char **argv)
     mutt_str_replace (&CurrentFolder, folder);
     mutt_str_replace (&LastFolder, folder);
 
-    if (flags & M_IGNORE)
+    if (flags & MUTT_IGNORE)
     {
       /* check to see if there are any messages in the folder */
       switch (mx_check_empty (folder))
@@ -877,7 +877,7 @@ int main (int argc, char **argv)
 
     mutt_folder_hook (folder);
 
-    if((Context = mx_open_mailbox (folder, ((flags & M_RO) || option (OPTREADONLY)) ? M_READONLY : 0, NULL))
+    if((Context = mx_open_mailbox (folder, ((flags & MUTT_RO) || option (OPTREADONLY)) ? MUTT_READONLY : 0, NULL))
        || !explicit_folder)
     {
 #ifdef USE_SIDEBAR
diff --git a/mbox.c b/mbox.c
index 1592870..298b70e 100644
--- a/mbox.c
+++ b/mbox.c
@@ -124,7 +124,7 @@ int mmdf_parse_mailbox (CONTEXT *ctx)
   if (!ctx->quiet)
   {
     snprintf (msgbuf, sizeof (msgbuf), _("Reading %s..."), ctx->path);
-    mutt_progress_init (&progress, msgbuf, M_PROGRESS_MSG, ReadInc, 0);
+    mutt_progress_init (&progress, msgbuf, MUTT_PROGRESS_MSG, ReadInc, 0);
   }
 
   FOREVER
@@ -277,7 +277,7 @@ int mbox_parse_mailbox (CONTEXT *ctx)
   if (!ctx->quiet)
   {
     snprintf (msgbuf, sizeof (msgbuf), _("Reading %s..."), ctx->path);
-    mutt_progress_init (&progress, msgbuf, M_PROGRESS_MSG, ReadInc, 0);
+    mutt_progress_init (&progress, msgbuf, MUTT_PROGRESS_MSG, ReadInc, 0);
   }
 
   loc = ftello (ctx->fp);
@@ -438,9 +438,9 @@ int mbox_open_mailbox (CONTEXT *ctx)
     return (-1);
   }
 
-  if (ctx->magic == M_MBOX)
+  if (ctx->magic == MUTT_MBOX)
     rc = mbox_parse_mailbox (ctx);
-  else if (ctx->magic == M_MMDF)
+  else if (ctx->magic == MUTT_MMDF)
     rc = mmdf_parse_mailbox (ctx);
   else
     rc = -1;
@@ -570,9 +570,9 @@ int mbox_strict_cmp_headers (const HEADER *h1, const HEADER *h2)
 /* check to see if the mailbox has changed on disk.
  *
  * return values:
- *	M_REOPENED	mailbox has been reopened
- *	M_NEW_MAIL	new mail has arrived!
- *	M_LOCKED	couldn't lock the file
+ *	MUTT_REOPENED	mailbox has been reopened
+ *	MUTT_NEW_MAIL	new mail has arrived!
+ *	MUTT_LOCKED	couldn't lock the file
  *	0		no change
  *	-1		error
  */
@@ -608,7 +608,7 @@ int mbox_check_mailbox (CONTEXT *ctx, int *index_hint)
 	   * probably the new mail arrived: no reason to wait till we can
 	   * parse it: we'll get it on the next pass
 	   */
-	  return (M_LOCKED);
+	  return (MUTT_LOCKED);
 	}
 	unlock = 1;
       }
@@ -623,12 +623,12 @@ int mbox_check_mailbox (CONTEXT *ctx, int *index_hint)
 	dprint (1, (debugfile, "mbox_check_mailbox: fseek() failed\n"));
       if (fgets (buffer, sizeof (buffer), ctx->fp) != NULL)
       {
-	if ((ctx->magic == M_MBOX && mutt_strncmp ("From ", buffer, 5) == 0) ||
-	    (ctx->magic == M_MMDF && mutt_strcmp (MMDF_SEP, buffer) == 0))
+	if ((ctx->magic == MUTT_MBOX && mutt_strncmp ("From ", buffer, 5) == 0) ||
+	    (ctx->magic == MUTT_MMDF && mutt_strcmp (MMDF_SEP, buffer) == 0))
 	{
 	  if (fseeko (ctx->fp, ctx->size, SEEK_SET) != 0)
 	    dprint (1, (debugfile, "mbox_check_mailbox: fseek() failed\n"));
-	  if (ctx->magic == M_MBOX)
+	  if (ctx->magic == MUTT_MBOX)
 	    mbox_parse_mailbox (ctx);
 	  else
 	    mmdf_parse_mailbox (ctx);
@@ -644,7 +644,7 @@ int mbox_check_mailbox (CONTEXT *ctx, int *index_hint)
 	    mutt_unblock_signals ();
 	  }
 
-	  return (M_NEW_MAIL); /* signal that new mail arrived */
+	  return (MUTT_NEW_MAIL); /* signal that new mail arrived */
 	}
 	else
 	  modified = 1;
@@ -668,7 +668,7 @@ int mbox_check_mailbox (CONTEXT *ctx, int *index_hint)
 	mbox_unlock_mailbox (ctx);
 	mutt_unblock_signals ();
       }
-      return (M_REOPENED);
+      return (MUTT_REOPENED);
     }
   }
 
@@ -772,7 +772,7 @@ int mbox_sync_mailbox (CONTEXT *ctx, int *index_hint)
   }
 
   /* Check to make sure that the file hasn't changed on disk */
-  if ((i = mbox_check_mailbox (ctx, index_hint)) == M_NEW_MAIL ||  i == M_REOPENED)
+  if ((i = mbox_check_mailbox (ctx, index_hint)) == MUTT_NEW_MAIL ||  i == MUTT_REOPENED)
   {
     /* new mail arrived, or mailbox reopened */
     need_sort = i;
@@ -825,7 +825,7 @@ int mbox_sync_mailbox (CONTEXT *ctx, int *index_hint)
   /* the offset stored in the header does not include the MMDF_SEP, so make
    * sure we seek to the correct location
    */
-  if (ctx->magic == M_MMDF)
+  if (ctx->magic == MUTT_MMDF)
     offset -= (sizeof MMDF_SEP - 1);
   
   /* allocate space for the new offsets */
@@ -835,7 +835,7 @@ int mbox_sync_mailbox (CONTEXT *ctx, int *index_hint)
   if (!ctx->quiet)
   {
     snprintf (msgbuf, sizeof (msgbuf), _("Writing %s..."), ctx->path);
-    mutt_progress_init (&progress, msgbuf, M_PROGRESS_MSG, WriteInc, ctx->msgcount);
+    mutt_progress_init (&progress, msgbuf, MUTT_PROGRESS_MSG, WriteInc, ctx->msgcount);
   }
 
   for (i = first, j = 0; i < ctx->msgcount; i++)
@@ -857,7 +857,7 @@ int mbox_sync_mailbox (CONTEXT *ctx, int *index_hint)
     {
       j++;
 
-      if (ctx->magic == M_MMDF)
+      if (ctx->magic == MUTT_MMDF)
       {
 	if (fputs (MMDF_SEP, fp) == EOF)
 	{
@@ -875,7 +875,7 @@ int mbox_sync_mailbox (CONTEXT *ctx, int *index_hint)
        */
       newOffset[i - first].hdr = ftello (fp) + offset;
 
-      if (mutt_copy_message (fp, ctx, ctx->hdrs[i], M_CM_UPDATE,
+      if (mutt_copy_message (fp, ctx, ctx->hdrs[i], MUTT_CM_UPDATE,
                              CH_FROM | CH_UPDATE | CH_UPDATE_LEN) != 0)
       {
 	mutt_perror (tempfile);
@@ -895,7 +895,7 @@ int mbox_sync_mailbox (CONTEXT *ctx, int *index_hint)
 
       switch(ctx->magic)
       {
-	case M_MMDF: 
+	case MUTT_MMDF: 
 	  if(fputs(MMDF_SEP, fp) == EOF) 
 	  {
 	    mutt_perror (tempfile);
@@ -949,8 +949,8 @@ int mbox_sync_mailbox (CONTEXT *ctx, int *index_hint)
   if (fseeko (ctx->fp, offset, SEEK_SET) != 0 ||  /* seek the append location */
       /* do a sanity check to make sure the mailbox looks ok */
       fgets (buf, sizeof (buf), ctx->fp) == NULL ||
-      (ctx->magic == M_MBOX && mutt_strncmp ("From ", buf, 5) != 0) ||
-      (ctx->magic == M_MMDF && mutt_strcmp (MMDF_SEP, buf) != 0))
+      (ctx->magic == MUTT_MBOX && mutt_strncmp ("From ", buf, 5) != 0) ||
+      (ctx->magic == MUTT_MMDF && mutt_strcmp (MMDF_SEP, buf) != 0))
   {
     dprint (1, (debugfile, "mbox_sync_mailbox: message not in expected position."));
     dprint (1, (debugfile, "\tLINE: %s\n", buf));
@@ -1074,7 +1074,7 @@ bail:  /* Come here in case of disaster */
   if (need_sort)
     /* if the mailbox was reopened, the thread tree will be invalid so make
      * sure to start threading from scratch.  */
-    mutt_sort_headers (ctx, (need_sort == M_REOPENED));
+    mutt_sort_headers (ctx, (need_sort == MUTT_REOPENED));
 
   return rc;
 }
@@ -1159,14 +1159,14 @@ int mutt_reopen_mailbox (CONTEXT *ctx, int *index_hint)
 
   switch (ctx->magic)
   {
-    case M_MBOX:
-    case M_MMDF:
+    case MUTT_MBOX:
+    case MUTT_MMDF:
       cmp_headers = mbox_strict_cmp_headers;
       safe_fclose (&ctx->fp);
       if (!(ctx->fp = safe_fopen (ctx->path, "r")))
 	rc = -1;
       else
-	rc = ((ctx->magic == M_MBOX) ? mbox_parse_mailbox
+	rc = ((ctx->magic == MUTT_MBOX) ? mbox_parse_mailbox
 	                               : mmdf_parse_mailbox) (ctx);
       break;
 
@@ -1237,13 +1237,13 @@ int mutt_reopen_mailbox (CONTEXT *ctx, int *index_hint)
 	   * otherwise, the header may have been modified externally,
 	   * and we don't want to lose _those_ changes
 	   */
-	  mutt_set_flag (ctx, ctx->hdrs[i], M_FLAG, old_hdrs[j]->flagged);
-	  mutt_set_flag (ctx, ctx->hdrs[i], M_REPLIED, old_hdrs[j]->replied);
-	  mutt_set_flag (ctx, ctx->hdrs[i], M_OLD, old_hdrs[j]->old);
-	  mutt_set_flag (ctx, ctx->hdrs[i], M_READ, old_hdrs[j]->read);
+	  mutt_set_flag (ctx, ctx->hdrs[i], MUTT_FLAG, old_hdrs[j]->flagged);
+	  mutt_set_flag (ctx, ctx->hdrs[i], MUTT_REPLIED, old_hdrs[j]->replied);
+	  mutt_set_flag (ctx, ctx->hdrs[i], MUTT_OLD, old_hdrs[j]->old);
+	  mutt_set_flag (ctx, ctx->hdrs[i], MUTT_READ, old_hdrs[j]->read);
 	}
-	mutt_set_flag (ctx, ctx->hdrs[i], M_DELETE, old_hdrs[j]->deleted);
-	mutt_set_flag (ctx, ctx->hdrs[i], M_TAG, old_hdrs[j]->tagged);
+	mutt_set_flag (ctx, ctx->hdrs[i], MUTT_DELETE, old_hdrs[j]->deleted);
+	mutt_set_flag (ctx, ctx->hdrs[i], MUTT_TAG, old_hdrs[j]->tagged);
 
 	/* we don't need this header any more */
 	mutt_free_header (&(old_hdrs[j]));
@@ -1264,7 +1264,7 @@ int mutt_reopen_mailbox (CONTEXT *ctx, int *index_hint)
 
   ctx->quiet = 0;
 
-  return ((ctx->changed || msg_mod) ? M_REOPENED : M_NEW_MAIL);
+  return ((ctx->changed || msg_mod) ? MUTT_REOPENED : MUTT_NEW_MAIL);
 }
 
 /*
diff --git a/menu.c b/menu.c
index 8215bd2..b80017b 100644
--- a/menu.c
+++ b/menu.c
@@ -66,7 +66,7 @@ get_color (int index, unsigned char *s)
 	}
 
 	for (; color; color = color->next)
-		if (mutt_pattern_exec (color->color_pattern, M_MATCH_FULL_ADDRESS,
+		if (mutt_pattern_exec (color->color_pattern, MUTT_MATCH_FULL_ADDRESS,
 		    Context, hdr))
 			return color->pair;
 
@@ -83,15 +83,15 @@ static void print_enriched_string (int index, int attr, unsigned char *s, int do
   memset (&mbstate, 0, sizeof (mbstate));
   while (*s)
   {
-    if (*s < M_TREE_MAX)
+    if (*s < MUTT_TREE_MAX)
     {
       if (do_color)
 	SETCOLOR (MT_COLOR_TREE);
-      while (*s && *s < M_TREE_MAX)
+      while (*s && *s < MUTT_TREE_MAX)
       {
 	switch (*s)
 	{
-	  case M_TREE_LLCORNER:
+	  case MUTT_TREE_LLCORNER:
 	    if (option (OPTASCIICHARS))
 	      addch ('`');
 #ifdef WACS_LLCORNER
@@ -104,7 +104,7 @@ static void print_enriched_string (int index, int attr, unsigned char *s, int do
 	      addch (ACS_LLCORNER);
 #endif
 	    break;
-	  case M_TREE_ULCORNER:
+	  case MUTT_TREE_ULCORNER:
 	    if (option (OPTASCIICHARS))
 	      addch (',');
 #ifdef WACS_ULCORNER
@@ -117,7 +117,7 @@ static void print_enriched_string (int index, int attr, unsigned char *s, int do
 	      addch (ACS_ULCORNER);
 #endif
 	    break;
-	  case M_TREE_LTEE:
+	  case MUTT_TREE_LTEE:
 	    if (option (OPTASCIICHARS))
 	      addch ('|');
 #ifdef WACS_LTEE
@@ -130,7 +130,7 @@ static void print_enriched_string (int index, int attr, unsigned char *s, int do
 	      addch (ACS_LTEE);
 #endif
 	    break;
-	  case M_TREE_HLINE:
+	  case MUTT_TREE_HLINE:
 	    if (option (OPTASCIICHARS))
 	      addch ('-');
 #ifdef WACS_HLINE
@@ -143,7 +143,7 @@ static void print_enriched_string (int index, int attr, unsigned char *s, int do
 	      addch (ACS_HLINE);
 #endif
 	    break;
-	  case M_TREE_VLINE:
+	  case MUTT_TREE_VLINE:
 	    if (option (OPTASCIICHARS))
 	      addch ('|');
 #ifdef WACS_VLINE
@@ -156,7 +156,7 @@ static void print_enriched_string (int index, int attr, unsigned char *s, int do
 	      addch (ACS_VLINE);
 #endif
 	    break;
-	  case M_TREE_TTEE:
+	  case MUTT_TREE_TTEE:
 	    if (option (OPTASCIICHARS))
 	      addch ('-');
 #ifdef WACS_TTEE
@@ -169,7 +169,7 @@ static void print_enriched_string (int index, int attr, unsigned char *s, int do
 	      addch (ACS_TTEE);
 #endif
 	    break;
-	  case M_TREE_BTEE:
+	  case MUTT_TREE_BTEE:
 	    if (option (OPTASCIICHARS))
 	      addch ('-');
 #ifdef WACS_BTEE
@@ -182,22 +182,22 @@ static void print_enriched_string (int index, int attr, unsigned char *s, int do
 	      addch (ACS_BTEE);
 #endif
 	    break;
-	  case M_TREE_SPACE:
+	  case MUTT_TREE_SPACE:
 	    addch (' ');
 	    break;
-	  case M_TREE_RARROW:
+	  case MUTT_TREE_RARROW:
 	    addch ('>');
 	    break;
-	  case M_TREE_STAR:
+	  case MUTT_TREE_STAR:
 	    addch ('*'); /* fake thread indicator */
 	    break;
-	  case M_TREE_HIDDEN:
+	  case MUTT_TREE_HIDDEN:
 	    addch ('&');
 	    break;
-	  case M_TREE_EQUALS:
+	  case MUTT_TREE_EQUALS:
 	    addch ('=');
 	    break;
-	  case M_TREE_MISSING:
+	  case MUTT_TREE_MISSING:
 	    addch ('?');
 	    break;
 	}
@@ -205,7 +205,7 @@ static void print_enriched_string (int index, int attr, unsigned char *s, int do
       }
       if (do_color) ATTRSET(attr);
     }
-    else if (*s == M_SPECIAL_INDEX) {
+    else if (*s == MUTT_SPECIAL_INDEX) {
       s++;
       if (do_color) {
         if (*s == MT_COLOR_INDEX) {
@@ -282,7 +282,7 @@ void menu_redraw_status (MUTTMENU *menu)
 {
   char buf[STRING];
 
-  snprintf (buf, sizeof (buf), M_MODEFMT, menu->title);
+  snprintf (buf, sizeof (buf), MUTT_MODEFMT, menu->title);
   SETCOLOR (MT_COLOR_STATUS);
   mutt_window_move (menu->statuswin, 0, 0);
   mutt_paddstr (menu->statuswin->cols, buf);
@@ -778,8 +778,8 @@ void mutt_menuDestroy (MUTTMENU **p)
   FREE (p);		/* __FREE_CHECKED__ */
 }
 
-#define M_SEARCH_UP   1
-#define M_SEARCH_DOWN 2
+#define MUTT_SEARCH_UP   1
+#define MUTT_SEARCH_DOWN 2
 
 static int menu_search (MUTTMENU *menu, int op)
 {
@@ -796,7 +796,7 @@ static int menu_search (MUTTMENU *menu, int op)
     strfcpy (buf, searchBuf && *searchBuf ? searchBuf : "", sizeof (buf));
     if (mutt_get_field ((op == OP_SEARCH || op == OP_SEARCH_NEXT)
 			? _("Search for: ") : _("Reverse search for: "),
-			buf, sizeof (buf), M_CLEAR) != 0 || !buf[0])
+			buf, sizeof (buf), MUTT_CLEAR) != 0 || !buf[0])
       return (-1);
     if (menu->menu >= 0 && menu->menu < MENU_MAX)
     {
@@ -804,10 +804,10 @@ static int menu_search (MUTTMENU *menu, int op)
       searchBuf = SearchBuffers[menu->menu];
     }
     menu->searchDir = (op == OP_SEARCH || op == OP_SEARCH_NEXT) ?
-		       M_SEARCH_DOWN : M_SEARCH_UP;
+		       MUTT_SEARCH_DOWN : MUTT_SEARCH_UP;
   }
 
-  searchDir = (menu->searchDir == M_SEARCH_UP) ? -1 : 1;
+  searchDir = (menu->searchDir == MUTT_SEARCH_UP) ? -1 : 1;
   if (op == OP_SEARCH_OPPOSITE)
     searchDir = -searchDir;
 
diff --git a/mh.c b/mh.c
index dd15280..5c175ae 100644
--- a/mh.c
+++ b/mh.c
@@ -716,7 +716,7 @@ static void maildir_update_mtime (CONTEXT * ctx)
   struct stat st;
   struct mh_data *data = mh_data (ctx);
 
-  if (ctx->magic == M_MAILDIR)
+  if (ctx->magic == MUTT_MAILDIR)
   {
     snprintf (buf, sizeof (buf), "%s/%s", ctx->path, "cur");
     if (stat (buf, &st) == 0)
@@ -760,7 +760,7 @@ HEADER *maildir_parse_stream (int magic, FILE *f, const char *fname,
 
   h->index = -1;
 
-  if (magic == M_MAILDIR)
+  if (magic == MUTT_MAILDIR)
   {
     /*
      * maildir stores its flags in the filename, so ignore the
@@ -829,8 +829,8 @@ static int maildir_parse_dir (CONTEXT * ctx, struct maildir ***last,
 
   while ((de = readdir (dirp)) != NULL)
   {
-    if ((ctx->magic == M_MH && !mh_valid_message (de->d_name))
-	|| (ctx->magic == M_MAILDIR && *de->d_name == '.'))
+    if ((ctx->magic == MUTT_MH && !mh_valid_message (de->d_name))
+	|| (ctx->magic == MUTT_MAILDIR && *de->d_name == '.'))
       continue;
 
     /* FOO - really ignore the return value? */
@@ -840,7 +840,7 @@ static int maildir_parse_dir (CONTEXT * ctx, struct maildir ***last,
 
     h = mutt_new_header ();
     h->old = is_old;
-    if (ctx->magic == M_MAILDIR)
+    if (ctx->magic == MUTT_MAILDIR)
       maildir_parse_flags (h, de->d_name);
 
     if (count)
@@ -1073,7 +1073,7 @@ static struct maildir* maildir_sort (struct maildir* list, size_t len,
  */
 static void mh_sort_natural (CONTEXT *ctx, struct maildir **md)
 {
-  if (!ctx || !md || !*md || ctx->magic != M_MH || Sort != SORT_ORDER)
+  if (!ctx || !md || !*md || ctx->magic != MUTT_MH || Sort != SORT_ORDER)
     return;
   dprint (4, (debugfile, "maildir: sorting %s into natural order\n",
 	      ctx->path));
@@ -1170,7 +1170,7 @@ static void maildir_delayed_parsing (CONTEXT * ctx, struct maildir **md,
       ret = 0;
     }
 
-    if (ctx->magic == M_MH)
+    if (ctx->magic == MUTT_MH)
       data = mutt_hcache_fetch (hc, p->h->path, strlen);
     else
       data = mutt_hcache_fetch (hc, p->h->path + 3, &maildir_hcache_keylen);
@@ -1179,7 +1179,7 @@ static void maildir_delayed_parsing (CONTEXT * ctx, struct maildir **md,
     if (data != NULL && !ret && lastchanged.st_mtime <= when->tv_sec)
     {
       p->h = mutt_hcache_restore ((unsigned char *)data, &p->h);
-      if (ctx->magic == M_MAILDIR)
+      if (ctx->magic == MUTT_MAILDIR)
 	maildir_parse_flags (p->h, fn);
     }
     else
@@ -1190,10 +1190,10 @@ static void maildir_delayed_parsing (CONTEXT * ctx, struct maildir **md,
     {
       p->header_parsed = 1;
 #if USE_HCACHE
-      if (ctx->magic == M_MH)
-	mutt_hcache_store (hc, p->h->path, p->h, 0, strlen, M_GENERATE_UIDVALIDITY);
+      if (ctx->magic == MUTT_MH)
+	mutt_hcache_store (hc, p->h->path, p->h, 0, strlen, MUTT_GENERATE_UIDVALIDITY);
       else
-	mutt_hcache_store (hc, p->h->path + 3, p->h, 0, &maildir_hcache_keylen, M_GENERATE_UIDVALIDITY);
+	mutt_hcache_store (hc, p->h->path + 3, p->h, 0, &maildir_hcache_keylen, MUTT_GENERATE_UIDVALIDITY);
 #endif
     } else
       mutt_free_header (&p->h);
@@ -1240,7 +1240,7 @@ int mh_read_dir (CONTEXT * ctx, const char *subdir)
   if (!ctx->quiet)
   {
     snprintf (msgbuf, sizeof (msgbuf), _("Scanning %s..."), ctx->path);
-    mutt_progress_init (&progress, msgbuf, M_PROGRESS_MSG, ReadInc, 0);
+    mutt_progress_init (&progress, msgbuf, MUTT_PROGRESS_MSG, ReadInc, 0);
   }
 
   if (!ctx->data)
@@ -1261,11 +1261,11 @@ int mh_read_dir (CONTEXT * ctx, const char *subdir)
   if (!ctx->quiet)
   {
     snprintf (msgbuf, sizeof (msgbuf), _("Reading %s..."), ctx->path);
-    mutt_progress_init (&progress, msgbuf, M_PROGRESS_MSG, ReadInc, count);
+    mutt_progress_init (&progress, msgbuf, MUTT_PROGRESS_MSG, ReadInc, count);
   }
   maildir_delayed_parsing (ctx, &md, &progress);
 
-  if (ctx->magic == M_MH)
+  if (ctx->magic == MUTT_MH)
   {
     if (mh_read_sequences (&mhs, ctx->path) < 0)
       return -1;
@@ -1487,7 +1487,7 @@ int maildir_commit_message (CONTEXT * ctx, MESSAGE * msg, HEADER * hdr)
       }
 
 #ifdef USE_NOTMUCH
-      if (ctx->magic == M_NOTMUCH)
+      if (ctx->magic == MUTT_NOTMUCH)
 	nm_update_filename(ctx, hdr->path, full, hdr);
 #endif
       if (hdr)
@@ -1621,12 +1621,12 @@ static int mh_rewrite_message (CONTEXT * ctx, int msgno)
     return -1;
 
   if ((rc = mutt_copy_message (dest->fp, ctx, h,
-			       M_CM_UPDATE, CH_UPDATE | CH_UPDATE_LEN)) == 0)
+			       MUTT_CM_UPDATE, CH_UPDATE | CH_UPDATE_LEN)) == 0)
   {
     snprintf (oldpath, _POSIX_PATH_MAX, "%s/%s", ctx->path, h->path);
     strfcpy (partpath, h->path, _POSIX_PATH_MAX);
 
-    if (ctx->magic == M_MAILDIR)
+    if (ctx->magic == MUTT_MAILDIR)
       rc = maildir_commit_message (ctx, dest, h);
     else
       rc = _mh_commit_message (ctx, dest, h, 0);
@@ -1654,7 +1654,7 @@ static int mh_rewrite_message (CONTEXT * ctx, int msgno)
      * lose flag modifications.
      */
 
-    if (ctx->magic == M_MH && rc == 0)
+    if (ctx->magic == MUTT_MH && rc == 0)
     {
       snprintf (newpath, _POSIX_PATH_MAX, "%s/%s", ctx->path, h->path);
       if ((rc = safe_rename (newpath, oldpath)) == 0)
@@ -1759,23 +1759,23 @@ int mh_sync_mailbox_message (CONTEXT * ctx, int msgno)
     char path[_POSIX_PATH_MAX], tmp[_POSIX_PATH_MAX];
     HEADER *h = ctx->hdrs[msgno];
 
-    if (h->deleted && (ctx->magic != M_MAILDIR || !option (OPTMAILDIRTRASH)))
+    if (h->deleted && (ctx->magic != MUTT_MAILDIR || !option (OPTMAILDIRTRASH)))
     {
       snprintf (path, sizeof (path), "%s/%s", ctx->path, h->path);
-      if (ctx->magic == M_MAILDIR
-	  || (option (OPTMHPURGE) && ctx->magic == M_MH))
+      if (ctx->magic == MUTT_MAILDIR
+	  || (option (OPTMHPURGE) && ctx->magic == MUTT_MH))
       {
 #if USE_HCACHE
 	if (hc) {
-           if (ctx->magic == M_MAILDIR)
+           if (ctx->magic == MUTT_MAILDIR)
               mutt_hcache_delete (hc, h->path + 3, &maildir_hcache_keylen);
-	   else if (ctx->magic == M_MH)
+	   else if (ctx->magic == MUTT_MH)
 	      mutt_hcache_delete (hc, h->path, strlen);
 	}
 #endif /* USE_HCACHE */
 	unlink (path);
       }
-      else if (ctx->magic == M_MH)
+      else if (ctx->magic == MUTT_MH)
       {
 	/* MH just moves files out of the way when you delete them */
 	if (*h->path != ',')
@@ -1789,11 +1789,11 @@ int mh_sync_mailbox_message (CONTEXT * ctx, int msgno)
     }
     else if (h->changed || h->attach_del ||
 	     h->label_changed ||
-	     (ctx->magic == M_MAILDIR
+	     (ctx->magic == MUTT_MAILDIR
 	      && (option (OPTMAILDIRTRASH) || h->trash)
 	      && (h->deleted != h->trash)))
     {
-      if (ctx->magic == M_MAILDIR)
+      if (ctx->magic == MUTT_MAILDIR)
       {
 	if (maildir_sync_message (ctx, msgno) == -1)
 	  return -1;
@@ -1808,10 +1808,10 @@ int mh_sync_mailbox_message (CONTEXT * ctx, int msgno)
 #if USE_HCACHE
     if (hc && h->changed)
     {
-      if (ctx->magic == M_MAILDIR)
-	mutt_hcache_store (hc, h->path + 3, h, 0, &maildir_hcache_keylen, M_GENERATE_UIDVALIDITY);
-      else if (ctx->magic == M_MH)
-	mutt_hcache_store (hc, h->path, h, 0, strlen, M_GENERATE_UIDVALIDITY);
+      if (ctx->magic == MUTT_MAILDIR)
+	mutt_hcache_store (hc, h->path + 3, h, 0, &maildir_hcache_keylen, MUTT_GENERATE_UIDVALIDITY);
+      else if (ctx->magic == MUTT_MH)
+	mutt_hcache_store (hc, h->path, h, 0, strlen, MUTT_GENERATE_UIDVALIDITY);
     }
 #endif
 
@@ -1827,7 +1827,7 @@ int mh_sync_mailbox (CONTEXT * ctx, int *index_hint)
   char msgbuf[STRING];
   progress_t progress;
 
-  if (ctx->magic == M_MH)
+  if (ctx->magic == MUTT_MH)
     i = mh_check_mailbox (ctx, index_hint);
   else
     i = maildir_check_mailbox (ctx, index_hint);
@@ -1836,14 +1836,14 @@ int mh_sync_mailbox (CONTEXT * ctx, int *index_hint)
     return i;
 
 #if USE_HCACHE
-  if (ctx->magic == M_MAILDIR || ctx->magic == M_MH)
+  if (ctx->magic == MUTT_MAILDIR || ctx->magic == MUTT_MH)
     hc = mutt_hcache_open(HeaderCache, ctx->path, NULL);
 #endif /* USE_HCACHE */
 
   if (!ctx->quiet)
   {
     snprintf (msgbuf, sizeof (msgbuf), _("Writing %s..."), ctx->path);
-    mutt_progress_init (&progress, msgbuf, M_PROGRESS_MSG, WriteInc, ctx->msgcount);
+    mutt_progress_init (&progress, msgbuf, MUTT_PROGRESS_MSG, WriteInc, ctx->msgcount);
   }
 
   for (i = 0; i < ctx->msgcount; i++)
@@ -1861,11 +1861,11 @@ int mh_sync_mailbox (CONTEXT * ctx, int *index_hint)
   }
 
 #if USE_HCACHE
-  if (ctx->magic == M_MAILDIR || ctx->magic == M_MH)
+  if (ctx->magic == MUTT_MAILDIR || ctx->magic == MUTT_MH)
     mutt_hcache_close (hc);
 #endif /* USE_HCACHE */
 
-  if (ctx->magic == M_MH)
+  if (ctx->magic == MUTT_MH)
     mh_update_sequences (ctx);
 
   /* XXX race condition? */
@@ -1879,7 +1879,7 @@ int mh_sync_mailbox (CONTEXT * ctx, int *index_hint)
     for (i = 0, j = 0; i < ctx->msgcount; i++)
     {
       if (!ctx->hdrs[i]->deleted
-	  || (ctx->magic == M_MAILDIR && option (OPTMAILDIRTRASH)))
+	  || (ctx->magic == MUTT_MAILDIR && option (OPTMAILDIRTRASH)))
 	ctx->hdrs[i]->index = j++;
     }
   }
@@ -1888,7 +1888,7 @@ int mh_sync_mailbox (CONTEXT * ctx, int *index_hint)
 
 err:
 #if USE_HCACHE
-  if (ctx->magic == M_MAILDIR || ctx->magic == M_MH)
+  if (ctx->magic == MUTT_MAILDIR || ctx->magic == MUTT_MH)
     mutt_hcache_close (hc);
 #endif /* USE_HCACHE */
   return -1;
@@ -1949,13 +1949,13 @@ void maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n)
    * bits are already properly set, but it is still faster not to pass
    * through it */
   if (o->flagged != n->flagged)
-    mutt_set_flag (ctx, o, M_FLAG, n->flagged);
+    mutt_set_flag (ctx, o, MUTT_FLAG, n->flagged);
   if (o->replied != n->replied)
-    mutt_set_flag (ctx, o, M_REPLIED, n->replied);
+    mutt_set_flag (ctx, o, MUTT_REPLIED, n->replied);
   if (o->read != n->read)
-    mutt_set_flag (ctx, o, M_READ, n->read);
+    mutt_set_flag (ctx, o, MUTT_READ, n->read);
   if (o->old != n->old)
-    mutt_set_flag (ctx, o, M_OLD, n->old);
+    mutt_set_flag (ctx, o, MUTT_OLD, n->old);
 
   /* mutt_set_flag() will set this, but we don't need to
    * sync the changes we made because we just updated the
@@ -2113,7 +2113,7 @@ int maildir_check_mailbox (CONTEXT * ctx, int *index_hint)
   /* Incorporate new messages */
   have_new = maildir_move_to_context (ctx, &md);
 
-  return occult ? M_REOPENED : (have_new ? M_NEW_MAIL : 0);
+  return occult ? MUTT_REOPENED : (have_new ? MUTT_NEW_MAIL : 0);
 }
 
 /* 
@@ -2226,7 +2226,7 @@ int mh_check_mailbox (CONTEXT * ctx, int *index_hint)
   /* Incorporate new messages */
   have_new = maildir_move_to_context (ctx, &md);
 
-  return occult ? M_REOPENED : (have_new ? M_NEW_MAIL : 0);
+  return occult ? MUTT_REOPENED : (have_new ? MUTT_NEW_MAIL : 0);
 }
 
 
diff --git a/mutt.h b/mutt.h
index aa6a2ee..0674107 100644
--- a/mutt.h
+++ b/mutt.h
@@ -93,28 +93,28 @@
 #include "mutt_regex.h"
 
 /* flags for mutt_enter_string() */
-#define  M_ALIAS   1      /* do alias "completion" by calling up the alias-menu */
-#define  M_FILE    (1<<1) /* do file completion */
-#define  M_EFILE   (1<<2) /* do file completion, plus incoming folders */
-#define  M_CMD     (1<<3) /* do completion on previous word */
-#define  M_PASS    (1<<4) /* password mode (no echo) */
-#define  M_CLEAR   (1<<5) /* clear input if printable character is pressed */
-#define  M_COMMAND (1<<6) /* do command completion */
-#define  M_PATTERN (1<<7) /* pattern mode - only used for history classes */
-#define  M_LABEL   (1<<8) /* do label completion */
+#define  MUTT_ALIAS   1      /* do alias "completion" by calling up the alias-menu */
+#define  MUTT_FILE    (1<<1) /* do file completion */
+#define  MUTT_EFILE   (1<<2) /* do file completion, plus incoming folders */
+#define  MUTT_CMD     (1<<3) /* do completion on previous word */
+#define  MUTT_PASS    (1<<4) /* password mode (no echo) */
+#define  MUTT_CLEAR   (1<<5) /* clear input if printable character is pressed */
+#define  MUTT_COMMAND (1<<6) /* do command completion */
+#define  MUTT_PATTERN (1<<7) /* pattern mode - only used for history classes */
+#define  MUTT_LABEL   (1<<8) /* do label completion */
 #if USE_NOTMUCH
-#define  M_NM_QUERY (1<<9) /* Notmuch query mode. */
-#define  M_NM_TAG   (1<<10) /* Notmuch tag +/- mode. */
+#define  MUTT_NM_QUERY (1<<9) /* Notmuch query mode. */
+#define  MUTT_NM_TAG   (1<<10) /* Notmuch tag +/- mode. */
 #endif
 
 /* flags for mutt_get_token() */
-#define M_TOKEN_EQUAL		1	/* treat '=' as a special */
-#define M_TOKEN_CONDENSE	(1<<1)	/* ^(char) to control chars (macros) */
-#define M_TOKEN_SPACE		(1<<2)  /* don't treat whitespace as a term */
-#define M_TOKEN_QUOTE		(1<<3)	/* don't interpret quotes */
-#define M_TOKEN_PATTERN		(1<<4)	/* !)|~ are terms (for patterns) */
-#define M_TOKEN_COMMENT		(1<<5)	/* don't reap comments */
-#define M_TOKEN_SEMICOLON	(1<<6)	/* don't treat ; as special */
+#define MUTT_TOKEN_EQUAL		1	/* treat '=' as a special */
+#define MUTT_TOKEN_CONDENSE	(1<<1)	/* ^(char) to control chars (macros) */
+#define MUTT_TOKEN_SPACE		(1<<2)  /* don't treat whitespace as a term */
+#define MUTT_TOKEN_QUOTE		(1<<3)	/* don't interpret quotes */
+#define MUTT_TOKEN_PATTERN		(1<<4)	/* !)|~ are terms (for patterns) */
+#define MUTT_TOKEN_COMMENT		(1<<5)	/* don't reap comments */
+#define MUTT_TOKEN_SEMICOLON	(1<<6)	/* don't treat ; as special */
 
 typedef struct
 {
@@ -131,157 +131,157 @@ typedef struct
 } event_t;
 
 /* flags for _mutt_system() */
-#define M_DETACH_PROCESS	1	/* detach subprocess from group */
+#define MUTT_DETACH_PROCESS	1	/* detach subprocess from group */
 
 /* flags for mutt_FormatString() */
 typedef enum
 {
-  M_FORMAT_FORCESUBJ	= (1<<0), /* print the subject even if unchanged */
-  M_FORMAT_TREE		= (1<<1), /* draw the thread tree */
-  M_FORMAT_MAKEPRINT	= (1<<2), /* make sure that all chars are printable */
-  M_FORMAT_OPTIONAL	= (1<<3),
-  M_FORMAT_STAT_FILE	= (1<<4), /* used by mutt_attach_fmt */
-  M_FORMAT_ARROWCURSOR	= (1<<5), /* reserve space for arrow_cursor */
-  M_FORMAT_INDEX	= (1<<6), /* this is a main index entry */
-  M_FORMAT_NOFILTER	= (1<<7)  /* do not allow filtering on this pass */
+  MUTT_FORMAT_FORCESUBJ	= (1<<0), /* print the subject even if unchanged */
+  MUTT_FORMAT_TREE		= (1<<1), /* draw the thread tree */
+  MUTT_FORMAT_MAKEPRINT	= (1<<2), /* make sure that all chars are printable */
+  MUTT_FORMAT_OPTIONAL	= (1<<3),
+  MUTT_FORMAT_STAT_FILE	= (1<<4), /* used by mutt_attach_fmt */
+  MUTT_FORMAT_ARROWCURSOR	= (1<<5), /* reserve space for arrow_cursor */
+  MUTT_FORMAT_INDEX	= (1<<6), /* this is a main index entry */
+  MUTT_FORMAT_NOFILTER	= (1<<7)  /* do not allow filtering on this pass */
 } format_flag;
 
 /* types for mutt_add_hook() */
-#define M_FOLDERHOOK	1
-#define M_MBOXHOOK	(1<<1)
-#define M_SENDHOOK	(1<<2)
-#define M_FCCHOOK	(1<<3)
-#define M_SAVEHOOK	(1<<4)
-#define M_CHARSETHOOK	(1<<5)
-#define M_ICONVHOOK 	(1<<6)
-#define M_MESSAGEHOOK	(1<<7)
-#define M_CRYPTHOOK	(1<<8)
-#define M_ACCOUNTHOOK	(1<<9)
-#define M_REPLYHOOK	(1<<10)
-#define M_SEND2HOOK     (1<<11)
+#define MUTT_FOLDERHOOK	1
+#define MUTT_MBOXHOOK	(1<<1)
+#define MUTT_SENDHOOK	(1<<2)
+#define MUTT_FCCHOOK	(1<<3)
+#define MUTT_SAVEHOOK	(1<<4)
+#define MUTT_CHARSETHOOK	(1<<5)
+#define MUTT_ICONVHOOK 	(1<<6)
+#define MUTT_MESSAGEHOOK	(1<<7)
+#define MUTT_CRYPTHOOK	(1<<8)
+#define MUTT_ACCOUNTHOOK	(1<<9)
+#define MUTT_REPLYHOOK	(1<<10)
+#define MUTT_SEND2HOOK     (1<<11)
 #ifdef USE_COMPRESSED
-#define M_OPENHOOK	(1<<12)
-#define M_APPENDHOOK	(1<<13)
-#define M_CLOSEHOOK	(1<<14)
+#define MUTT_OPENHOOK	(1<<12)
+#define MUTT_APPENDHOOK	(1<<13)
+#define MUTT_CLOSEHOOK	(1<<14)
 #endif
 
 /* tree characters for linearize_tree and print_enriched_string */
-#define M_TREE_LLCORNER		1
-#define M_TREE_ULCORNER		2
-#define M_TREE_LTEE		3
-#define M_TREE_HLINE		4
-#define M_TREE_VLINE		5
-#define M_TREE_SPACE		6
-#define M_TREE_RARROW		7
-#define M_TREE_STAR		8
-#define M_TREE_HIDDEN		9
-#define M_TREE_EQUALS		10
-#define M_TREE_TTEE		11
-#define M_TREE_BTEE		12
-#define M_TREE_MISSING		13
-#define M_TREE_MAX		14
-
-#define M_SPECIAL_INDEX		M_TREE_MAX
-
-#define M_THREAD_COLLAPSE	(1<<0)
-#define M_THREAD_UNCOLLAPSE	(1<<1)
-#define M_THREAD_GET_HIDDEN	(1<<2)
-#define M_THREAD_UNREAD		(1<<3)
-#define M_THREAD_NEXT_UNREAD	(1<<4)
+#define MUTT_TREE_LLCORNER		1
+#define MUTT_TREE_ULCORNER		2
+#define MUTT_TREE_LTEE		3
+#define MUTT_TREE_HLINE		4
+#define MUTT_TREE_VLINE		5
+#define MUTT_TREE_SPACE		6
+#define MUTT_TREE_RARROW		7
+#define MUTT_TREE_STAR		8
+#define MUTT_TREE_HIDDEN		9
+#define MUTT_TREE_EQUALS		10
+#define MUTT_TREE_TTEE		11
+#define MUTT_TREE_BTEE		12
+#define MUTT_TREE_MISSING		13
+#define MUTT_TREE_MAX		14
+
+#define MUTT_SPECIAL_INDEX		MUTT_TREE_MAX
+
+#define MUTT_THREAD_COLLAPSE	(1<<0)
+#define MUTT_THREAD_UNCOLLAPSE	(1<<1)
+#define MUTT_THREAD_GET_HIDDEN	(1<<2)
+#define MUTT_THREAD_UNREAD		(1<<3)
+#define MUTT_THREAD_NEXT_UNREAD	(1<<4)
 
 enum
 {
   /* modes for mutt_view_attachment() */
-  M_REGULAR = 1,
-  M_MAILCAP,
-  M_AS_TEXT,
+  MUTT_REGULAR = 1,
+  MUTT_MAILCAP,
+  MUTT_AS_TEXT,
 
   /* action codes used by mutt_set_flag() and mutt_pattern_function() */
-  M_ALL,
-  M_NONE,
-  M_NEW,
-  M_OLD,
-  M_REPLIED,
-  M_READ,
-  M_UNREAD,
-  M_DELETE,
-  M_UNDELETE,
-  M_DELETED,
-  M_APPENDED,
-  M_PURGED,
-  M_FLAG,
-  M_TAG,
-  M_UNTAG,
-  M_LIMIT,
-  M_EXPIRED,
-  M_SUPERSEDED,
+  MUTT_ALL,
+  MUTT_NONE,
+  MUTT_NEW,
+  MUTT_OLD,
+  MUTT_REPLIED,
+  MUTT_READ,
+  MUTT_UNREAD,
+  MUTT_DELETE,
+  MUTT_UNDELETE,
+  MUTT_DELETED,
+  MUTT_APPENDED,
+  MUTT_PURGED,
+  MUTT_FLAG,
+  MUTT_TAG,
+  MUTT_UNTAG,
+  MUTT_LIMIT,
+  MUTT_EXPIRED,
+  MUTT_SUPERSEDED,
 
   /* actions for mutt_pattern_comp/mutt_pattern_exec */
-  M_AND,
-  M_OR,
-  M_THREAD,
-  M_TO,
-  M_CC,
-  M_COLLAPSED,
-  M_SUBJECT,
-  M_FROM,
-  M_DATE,
-  M_DATE_RECEIVED,
-  M_DUPLICATED,
-  M_UNREFERENCED,
-  M_ID,
-  M_BODY,
-  M_HEADER,
-  M_HORMEL,
-  M_WHOLE_MSG,
-  M_SENDER,
-  M_MESSAGE,
-  M_SCORE,
-  M_SIZE,
-  M_REFERENCE,
-  M_RECIPIENT,
-  M_LIST,
-  M_SUBSCRIBED_LIST,
-  M_PERSONAL_RECIP,
-  M_PERSONAL_FROM,
-  M_ADDRESS,
-  M_CRYPT_SIGN,
-  M_CRYPT_VERIFIED,
-  M_CRYPT_ENCRYPT,
-  M_PGP_KEY,
-  M_XLABEL,
+  MUTT_AND,
+  MUTT_OR,
+  MUTT_THREAD,
+  MUTT_TO,
+  MUTT_CC,
+  MUTT_COLLAPSED,
+  MUTT_SUBJECT,
+  MUTT_FROM,
+  MUTT_DATE,
+  MUTT_DATE_RECEIVED,
+  MUTT_DUPLICATED,
+  MUTT_UNREFERENCED,
+  MUTT_ID,
+  MUTT_BODY,
+  MUTT_HEADER,
+  MUTT_HORMEL,
+  MUTT_WHOLE_MSG,
+  MUTT_SENDER,
+  MUTT_MESSAGE,
+  MUTT_SCORE,
+  MUTT_SIZE,
+  MUTT_REFERENCE,
+  MUTT_RECIPIENT,
+  MUTT_LIST,
+  MUTT_SUBSCRIBED_LIST,
+  MUTT_PERSONAL_RECIP,
+  MUTT_PERSONAL_FROM,
+  MUTT_ADDRESS,
+  MUTT_CRYPT_SIGN,
+  MUTT_CRYPT_VERIFIED,
+  MUTT_CRYPT_ENCRYPT,
+  MUTT_PGP_KEY,
+  MUTT_XLABEL,
 #ifdef USE_NOTMUCH
-  M_NOTMUCH_LABEL,
+  MUTT_NOTMUCH_LABEL,
 #endif
-  M_MIMEATTACH,
+  MUTT_MIMEATTACH,
 #ifdef USE_NNTP
-  M_NEWSGROUPS,
+  MUTT_NEWSGROUPS,
 #endif
   
   /* Options for Mailcap lookup */
-  M_EDIT,
-  M_COMPOSE,
-  M_PRINT,
-  M_AUTOVIEW,
+  MUTT_EDIT,
+  MUTT_COMPOSE,
+  MUTT_PRINT,
+  MUTT_AUTOVIEW,
 
   /* options for socket code */
-  M_NEW_SOCKET,
+  MUTT_NEW_SOCKET,
 #ifdef USE_SSL_OPENSSL
-  M_NEW_SSL_SOCKET,
+  MUTT_NEW_SSL_SOCKET,
 #endif
 
   /* Options for mutt_save_attachment */
-  M_SAVE_APPEND,
-  M_SAVE_OVERWRITE
+  MUTT_SAVE_APPEND,
+  MUTT_SAVE_OVERWRITE
 };
 
 /* possible arguments to set_quadoption() */
 enum
 {
-  M_NO,
-  M_YES,
-  M_ASKNO,
-  M_ASKYES
+  MUTT_NO,
+  MUTT_YES,
+  MUTT_ASKNO,
+  MUTT_ASKYES
 };
 
 /* quad-option vars */
@@ -339,23 +339,23 @@ enum
 #define SENDNEWS	(1<<12)
 
 /* flags for mutt_compose_menu() */
-#define M_COMPOSE_NOFREEHEADER (1<<0)
+#define MUTT_COMPOSE_NOFREEHEADER (1<<0)
 
 /* flags to _mutt_select_file() */
-#define M_SEL_BUFFY	(1<<0)
-#define M_SEL_MULTI	(1<<1)
-#define M_SEL_FOLDER	(1<<2)
-#define M_SEL_VFOLDER	(1<<3)
+#define MUTT_SEL_BUFFY	(1<<0)
+#define MUTT_SEL_MULTI	(1<<1)
+#define MUTT_SEL_FOLDER	(1<<2)
+#define MUTT_SEL_VFOLDER	(1<<3)
 
 /* flags for parse_spam_list */
-#define M_SPAM          1
-#define M_NOSPAM        2
+#define MUTT_SPAM          1
+#define MUTT_NOSPAM        2
 
 /* flags for keywords headers */
-#define M_X_LABEL         (1<<0)  /* introduced to mutt in 2000 */
-#define M_X_KEYWORDS      (1<<1)  /* used in c-client, dovecot */
-#define M_X_MOZILLA_KEYS  (1<<2)  /* tbird */
-#define M_KEYWORDS        (1<<3)  /* rfc2822 */
+#define MUTT_X_LABEL         (1<<0)  /* introduced to mutt in 2000 */
+#define MUTT_X_KEYWORDS      (1<<1)  /* used in c-client, dovecot */
+#define MUTT_X_MOZILLA_KEYS  (1<<2)  /* tbird */
+#define MUTT_KEYWORDS        (1<<3)  /* rfc2822 */
 
 /* boolean vars */
 enum
@@ -907,10 +907,10 @@ struct mutt_thread
 
 
 /* flag to mutt_pattern_comp() */
-#define M_FULL_MSG	(1<<0)	/* enable body and header matching */
+#define MUTT_FULL_MSG	(1<<0)	/* enable body and header matching */
 
 typedef enum {
-  M_MATCH_FULL_ADDRESS = 1
+  MUTT_MATCH_FULL_ADDRESS = 1
 } pattern_exec_flag;
 
 typedef struct group_t
@@ -949,17 +949,17 @@ typedef struct pattern_t
 /* ACL Rights */
 enum
 {
-  M_ACL_LOOKUP = 0,
-  M_ACL_READ,
-  M_ACL_SEEN,
-  M_ACL_WRITE,
-  M_ACL_INSERT,
-  M_ACL_POST,
-  M_ACL_CREATE,
-  M_ACL_DELMX,
-  M_ACL_DELETE,
-  M_ACL_EXPUNGE,
-  M_ACL_ADMIN,
+  MUTT_ACL_LOOKUP = 0,
+  MUTT_ACL_READ,
+  MUTT_ACL_SEEN,
+  MUTT_ACL_WRITE,
+  MUTT_ACL_INSERT,
+  MUTT_ACL_POST,
+  MUTT_ACL_CREATE,
+  MUTT_ACL_DELMX,
+  MUTT_ACL_DELETE,
+  MUTT_ACL_EXPUNGE,
+  MUTT_ACL_ADMIN,
 
   RIGHTSMAX
 };
@@ -1041,17 +1041,17 @@ typedef struct
 } ENTER_STATE;
 
 /* flags for the STATE struct */
-#define M_DISPLAY	(1<<0) /* output is displayed to the user */
-#define M_VERIFY	(1<<1) /* perform signature verification */
-#define M_PENDINGPREFIX (1<<2) /* prefix to write, but character must follow */
-#define M_WEED          (1<<3) /* weed headers even when not in display mode */
-#define M_CHARCONV	(1<<4) /* Do character set conversions */
-#define M_PRINTING	(1<<5) /* are we printing? - M_DISPLAY "light" */
-#define M_REPLYING	(1<<6) /* are we replying? */
-#define M_FIRSTDONE	(1<<7) /* the first attachment has been done */
-
-#define state_set_prefix(s) ((s)->flags |= M_PENDINGPREFIX)
-#define state_reset_prefix(s) ((s)->flags &= ~M_PENDINGPREFIX)
+#define MUTT_DISPLAY	(1<<0) /* output is displayed to the user */
+#define MUTT_VERIFY	(1<<1) /* perform signature verification */
+#define MUTT_PENDINGPREFIX (1<<2) /* prefix to write, but character must follow */
+#define MUTT_WEED          (1<<3) /* weed headers even when not in display mode */
+#define MUTT_CHARCONV	(1<<4) /* Do character set conversions */
+#define MUTT_PRINTING	(1<<5) /* are we printing? - MUTT_DISPLAY "light" */
+#define MUTT_REPLYING	(1<<6) /* are we replying? */
+#define MUTT_FIRSTDONE	(1<<7) /* the first attachment has been done */
+
+#define state_set_prefix(s) ((s)->flags |= MUTT_PENDINGPREFIX)
+#define state_reset_prefix(s) ((s)->flags &= ~MUTT_PENDINGPREFIX)
 #define state_puts(x,y) fputs(x,(y)->fpout)
 #define state_putc(x,y) fputc(x,(y)->fpout)
 
@@ -1071,7 +1071,7 @@ typedef struct
   regex_t minor_rx;
 } ATTACH_MATCH;
 
-#define M_PARTS_TOPLEVEL	(1<<0)	/* is the top-level part */
+#define MUTT_PARTS_TOPLEVEL	(1<<0)	/* is the top-level part */
 
 #include "ascii.h"
 #include "protos.h"
diff --git a/mutt_curses.h b/mutt_curses.h
index 19a1086..35d788e 100644
--- a/mutt_curses.h
+++ b/mutt_curses.h
@@ -37,8 +37,8 @@
  * ncurses and SLang seem to send different characters when the Enter key is
  * pressed, so define some macros to properly detect the Enter key.
  */
-#define M_ENTER_C '\r'
-#define M_ENTER_S "\r"
+#define MUTT_ENTER_C '\r'
+#define MUTT_ENTER_S "\r"
 
 #else /* USE_SLANG_CURSES */
 
@@ -52,8 +52,8 @@
 # include <curses.h>
 #endif
 
-#define M_ENTER_C '\n'
-#define M_ENTER_S "\n"
+#define MUTT_ENTER_C '\n'
+#define MUTT_ENTER_S "\n"
 
 #endif /* USE_SLANG_CURSES */
 
@@ -164,8 +164,8 @@ typedef struct color_line
   struct color_line *next;
 } COLOR_LINE;
 
-#define M_PROGRESS_SIZE		(1<<0)	/* traffic-based progress */
-#define M_PROGRESS_MSG		(1<<1)	/* message-based progress */
+#define MUTT_PROGRESS_SIZE		(1<<0)	/* traffic-based progress */
+#define MUTT_PROGRESS_MSG		(1<<1)	/* message-based progress */
 
 typedef struct
 {
diff --git a/mutt_menu.h b/mutt_menu.h
index 0932df3..d728f57 100644
--- a/mutt_menu.h
+++ b/mutt_menu.h
@@ -39,7 +39,7 @@
 #define REDRAW_SIDEBAR		(1<<8)
 #endif
 
-#define M_MODEFMT "-- Mutt: %s"
+#define MUTT_MODEFMT "-- Mutt: %s"
 
 typedef struct menu_t
 {
diff --git a/mutt_notmuch.c b/mutt_notmuch.c
index 3a25cc1..b41d6fc 100644
--- a/mutt_notmuch.c
+++ b/mutt_notmuch.c
@@ -9,7 +9,7 @@
  *
  * - all exported functions are usable within notmuch context only
  *
- * - all functions have to be covered by "ctx->magic == M_NOTMUCH" check
+ * - all functions have to be covered by "ctx->magic == MUTT_NOTMUCH" check
  *   (it's implemented in get_ctxdata() and init_context() functions).
  *
  * - exception are nm_nonctx_* functions -- these functions use nm_default_uri
@@ -270,7 +270,7 @@ static int deinit_context(CONTEXT *ctx)
 {
 	int i;
 
-	if (!ctx || ctx->magic != M_NOTMUCH)
+	if (!ctx || ctx->magic != MUTT_NOTMUCH)
 		return -1;
 
 	for (i = 0; i < ctx->msgcount; i++) {
@@ -289,7 +289,7 @@ static int deinit_context(CONTEXT *ctx)
 
 static int init_context(CONTEXT *ctx)
 {
-	if (!ctx || ctx->magic != M_NOTMUCH)
+	if (!ctx || ctx->magic != MUTT_NOTMUCH)
 		return -1;
 
 	if (ctx->data)
@@ -361,7 +361,7 @@ char *nm_header_get_fullpath(HEADER *h, char *buf, size_t bufsz)
 
 static struct nm_ctxdata *get_ctxdata(CONTEXT *ctx)
 {
-	if (ctx && ctx->magic == M_NOTMUCH)
+	if (ctx && ctx->magic == MUTT_NOTMUCH)
 		return ctx->data;
 
 	return NULL;
@@ -770,7 +770,7 @@ static int update_message_path(HEADER *h, const char *path)
 	     strncmp(p - 3, "new", 3) == 0 ||
 	     strncmp(p - 3, "tmp", 3) == 0)) {
 
-		data->magic = M_MAILDIR;
+		data->magic = MUTT_MAILDIR;
 
 		FREE(&h->path);
 		FREE(&data->folder);
@@ -932,7 +932,7 @@ static void nm_progress_update(CONTEXT *ctx, notmuch_query_t *q)
 		static char msg[STRING];
 		snprintf(msg, sizeof(msg), _("Reading messages..."));
 
-		mutt_progress_init(&data->progress, msg, M_PROGRESS_MSG,
+		mutt_progress_init(&data->progress, msg, MUTT_PROGRESS_MSG,
 			ReadInc, notmuch_query_count_messages(q));
 		data->progress_ready = 1;
 	}
@@ -975,7 +975,7 @@ static void append_message(CONTEXT *ctx,
 		mx_alloc_memory(ctx);
 	}
 	if (access(path, F_OK) == 0)
-		h = maildir_parse_message(M_MAILDIR, path, 0, NULL);
+		h = maildir_parse_message(MUTT_MAILDIR, path, 0, NULL);
 	else {
 		/* maybe moved try find it... */
 		char *folder = get_folder_from_path(path);
@@ -983,7 +983,7 @@ static void append_message(CONTEXT *ctx,
 		if (folder) {
 			FILE *f = maildir_open_find_message(folder, path, &newpath);
 			if (f) {
-				h = maildir_parse_stream(M_MAILDIR, f, newpath, 0, NULL);
+				h = maildir_parse_stream(MUTT_MAILDIR, f, newpath, 0, NULL);
 				fclose(f);
 
 				dprint(1, (debugfile, "nm: not up-to-date: %s -> %s\n",
@@ -1539,7 +1539,7 @@ int nm_sync(CONTEXT *ctx, int *index_hint)
 	if (!ctx->quiet) {
 		/* all is in this function so we don't use data->progress here */
 		snprintf(msgbuf, sizeof (msgbuf), _("Writing %s..."), ctx->path);
-		mutt_progress_init(&progress, msgbuf, M_PROGRESS_MSG,
+		mutt_progress_init(&progress, msgbuf, MUTT_PROGRESS_MSG,
 				   WriteInc, ctx->msgcount);
 	}
 
@@ -1568,7 +1568,7 @@ int nm_sync(CONTEXT *ctx, int *index_hint)
 		rc = mh_sync_mailbox_message(ctx, i);
 #endif
 		ctx->path = uri;
-		ctx->magic = M_NOTMUCH;
+		ctx->magic = MUTT_NOTMUCH;
 
 		if (rc)
 			break;
@@ -1587,7 +1587,7 @@ int nm_sync(CONTEXT *ctx, int *index_hint)
 	}
 
 	ctx->path = uri;
-	ctx->magic = M_NOTMUCH;
+	ctx->magic = MUTT_NOTMUCH;
 
 	if (!is_longrun(data))
 		release_db(data);
@@ -1846,9 +1846,9 @@ done:
 	dprint(1, (debugfile, "nm: ... check done [count=%d, new_flags=%d, occult=%d]\n",
 				ctx->msgcount, new_flags, occult));
 
-	return occult ? M_REOPENED :
-	       ctx->msgcount > data->oldmsgcount ? M_NEW_MAIL :
-	       new_flags ? M_FLAGS : 0;
+	return occult ? MUTT_REOPENED :
+	       ctx->msgcount > data->oldmsgcount ? MUTT_NEW_MAIL :
+	       new_flags ? MUTT_FLAGS : 0;
 }
 
 int nm_record_message(CONTEXT *ctx, char *path, HEADER *h)
diff --git a/mutt_sasl.c b/mutt_sasl.c
index 1da5ea5..ffea2a6 100644
--- a/mutt_sasl.c
+++ b/mutt_sasl.c
@@ -78,7 +78,7 @@ static int getnameinfo_err(int ret)
 /* arbitrary. SASL will probably use a smaller buffer anyway. OTOH it's
  * been a while since I've had access to an SASL server which negotiated
  * a protection buffer. */ 
-#define M_SASL_MAXBUF 65536
+#define MUTT_SASL_MAXBUF 65536
 
 #define IP_PORT_BUFLEN 1024
 
@@ -181,17 +181,17 @@ int mutt_sasl_client_new (CONNECTION* conn, sasl_conn_t** saslconn)
 
   switch (conn->account.type)
   {
-    case M_ACCT_TYPE_IMAP:
+    case MUTT_ACCT_TYPE_IMAP:
       service = "imap";
       break;
-    case M_ACCT_TYPE_POP:
+    case MUTT_ACCT_TYPE_POP:
       service = "pop";
       break;
-    case M_ACCT_TYPE_SMTP:
+    case MUTT_ACCT_TYPE_SMTP:
       service = "smtp";
       break;
 #ifdef USE_NNTP
-    case M_ACCT_TYPE_NNTP:
+    case MUTT_ACCT_TYPE_NNTP:
       service = "nntp";
       break;
 #endif
@@ -238,7 +238,7 @@ int mutt_sasl_client_new (CONNECTION* conn, sasl_conn_t** saslconn)
   memset (&secprops, 0, sizeof (secprops));
   /* Work around a casting bug in the SASL krb4 module */
   secprops.max_ssf = 0x7fff;
-  secprops.maxbufsize = M_SASL_MAXBUF;
+  secprops.maxbufsize = MUTT_SASL_MAXBUF;
   if (sasl_setprop (*saslconn, SASL_SEC_PROPS, &secprops) != SASL_OK)
   {
     mutt_error (_("Error setting SASL security properties"));
diff --git a/mutt_socket.c b/mutt_socket.c
index 6cfcc68..0499ba1 100644
--- a/mutt_socket.c
+++ b/mutt_socket.c
@@ -288,7 +288,7 @@ CONNECTION* mutt_conn_find (const CONNECTION* start, const ACCOUNT* account)
 
   if (Tunnel && *Tunnel)
     mutt_tunnel_socket_setup (conn);
-  else if (account->flags & M_ACCT_SSL) 
+  else if (account->flags & MUTT_ACCT_SSL) 
   {
 #if defined(USE_SSL)
     if (mutt_ssl_socket_setup (conn) < 0)
diff --git a/mutt_socket.h b/mutt_socket.h
index bcc8bd5..b8c535c 100644
--- a/mutt_socket.h
+++ b/mutt_socket.h
@@ -24,9 +24,9 @@
 #include "lib.h"
 
 /* logging levels */
-#define M_SOCK_LOG_CMD  2
-#define M_SOCK_LOG_HDR  3
-#define M_SOCK_LOG_FULL 4
+#define MUTT_SOCK_LOG_CMD  2
+#define MUTT_SOCK_LOG_HDR  3
+#define MUTT_SOCK_LOG_FULL 4
 
 typedef struct _connection
 {
@@ -56,10 +56,10 @@ int mutt_socket_close (CONNECTION* conn);
 int mutt_socket_read (CONNECTION* conn, char* buf, size_t len);
 int mutt_socket_poll (CONNECTION* conn);
 int mutt_socket_readchar (CONNECTION *conn, char *c);
-#define mutt_socket_readln(A,B,C) mutt_socket_readln_d(A,B,C,M_SOCK_LOG_CMD)
+#define mutt_socket_readln(A,B,C) mutt_socket_readln_d(A,B,C,MUTT_SOCK_LOG_CMD)
 int mutt_socket_readln_d (char *buf, size_t buflen, CONNECTION *conn, int dbg);
-#define mutt_socket_write(A,B) mutt_socket_write_d(A,B,-1,M_SOCK_LOG_CMD)
-#define mutt_socket_write_n(A,B,C) mutt_socket_write_d(A,B,C,M_SOCK_LOG_CMD)
+#define mutt_socket_write(A,B) mutt_socket_write_d(A,B,-1,MUTT_SOCK_LOG_CMD)
+#define mutt_socket_write_n(A,B,C) mutt_socket_write_d(A,B,C,MUTT_SOCK_LOG_CMD)
 int mutt_socket_write_d (CONNECTION *conn, const char *buf, int len, int dbg);
 
 /* stupid hack for imap_logout_all */
diff --git a/mutt_ssl.c b/mutt_ssl.c
index d63670f..2a9266f 100644
--- a/mutt_ssl.c
+++ b/mutt_ssl.c
@@ -743,7 +743,7 @@ static int check_certificate_by_digest (X509 *peercert)
   FILE *fp;
 
   /* expiration check */
-  if (option (OPTSSLVERIFYDATES) != M_NO)
+  if (option (OPTSSLVERIFYDATES) != MUTT_NO)
   {
     if (X509_cmp_current_time (X509_get_notBefore (peercert)) >= 0)
     {
@@ -947,7 +947,7 @@ static int ssl_check_preauth (X509 *cert, const char* host)
   }
 
   buf[0] = 0;
-  if (host && option (OPTSSLVERIFYHOST) != M_NO)
+  if (host && option (OPTSSLVERIFYHOST) != MUTT_NO)
   {
     if (!check_host (cert, host, buf, sizeof (buf)))
     {
@@ -1069,7 +1069,7 @@ static int interactive_check_cert (X509 *cert, int idx, int len)
 	    len - idx, len);
   menu->title = title;
   if (SslCertFile
-      && (option (OPTSSLVERIFYDATES) == M_NO
+      && (option (OPTSSLVERIFYDATES) == MUTT_NO
 	  || (X509_cmp_current_time (X509_get_notAfter (cert)) >= 0
 	      && X509_cmp_current_time (X509_get_notBefore (cert)) < 0)))
   {
diff --git a/mutt_ssl_gnutls.c b/mutt_ssl_gnutls.c
index e850fa3..2084ad0 100644
--- a/mutt_ssl_gnutls.c
+++ b/mutt_ssl_gnutls.c
@@ -698,7 +698,7 @@ static int tls_check_preauth (const gnutls_datum_t *certdata,
     return -1;
   }
 
-  if (option (OPTSSLVERIFYDATES) != M_NO)
+  if (option (OPTSSLVERIFYDATES) != MUTT_NO)
   {
     if (gnutls_x509_crt_get_expiration_time (cert) < time(NULL))
       *certerr |= CERTERR_EXPIRED;
@@ -706,7 +706,7 @@ static int tls_check_preauth (const gnutls_datum_t *certdata,
       *certerr |= CERTERR_NOTYETVALID;
   }
 
-  if (chainidx == 0 && option (OPTSSLVERIFYHOST) != M_NO
+  if (chainidx == 0 && option (OPTSSLVERIFYHOST) != MUTT_NO
       && !gnutls_x509_crt_check_hostname (cert, hostname)
       && !tls_check_stored_hostname (certdata, hostname))
     *certerr |= CERTERR_HOSTNAME;
diff --git a/muttlib.c b/muttlib.c
index f665a5a..a972df4 100644
--- a/muttlib.c
+++ b/muttlib.c
@@ -1085,12 +1085,12 @@ int mutt_check_overwrite (const char *attname, const char *path,
     /* L10N:
        Means "The path you specified as the destination file is a directory."
        See the msgid "Save to file: " (alias.c, recvattach.c) */
-    else if ((rc = mutt_yesorno (_("File is a directory, save under it?"), M_YES)) != M_YES)
-      return (rc == M_NO) ? 1 : -1;
+    else if ((rc = mutt_yesorno (_("File is a directory, save under it?"), MUTT_YES)) != MUTT_YES)
+      return (rc == MUTT_NO) ? 1 : -1;
 
     strfcpy (tmp, mutt_basename (NONULL (attname)), sizeof (tmp));
     if (mutt_get_field (_("File under directory: "), tmp, sizeof (tmp),
-                                    M_FILE | M_CLEAR) != 0 || !tmp[0])
+                                    MUTT_FILE | MUTT_CLEAR) != 0 || !tmp[0])
       return (-1);
     mutt_concat_path (fname, path, tmp, flen);
   }
@@ -1106,10 +1106,10 @@ int mutt_check_overwrite (const char *attname, const char *path,
 	return 1;
 
       case 2: /* append */
-        *append = M_SAVE_APPEND;
+        *append = MUTT_SAVE_APPEND;
         break;
       case 1: /* overwrite */
-        *append = M_SAVE_OVERWRITE;
+        *append = MUTT_SAVE_OVERWRITE;
         break;
     }
   }
@@ -1164,10 +1164,10 @@ void mutt_FormatString (char *dest,		/* output buffer */
 
   prefix[0] = '\0';
   destlen--; /* save room for the terminal \0 */
-  wlen = ((flags & M_FORMAT_ARROWCURSOR) && option (OPTARROWCURSOR)) ? 3 : 0;
+  wlen = ((flags & MUTT_FORMAT_ARROWCURSOR) && option (OPTARROWCURSOR)) ? 3 : 0;
   col += wlen;
 
-  if ((flags & M_FORMAT_NOFILTER) == 0)
+  if ((flags & MUTT_FORMAT_NOFILTER) == 0)
   {
     int off = -1;
 
@@ -1214,7 +1214,7 @@ void mutt_FormatString (char *dest,		/* output buffer */
         dprint(3, (debugfile, "fmtpipe %2d: %s\n", i++, word->data));
         mutt_buffer_addch(command, '\'');
         mutt_FormatString(buf, sizeof(buf), 0, cols, word->data, callback, data,
-                          flags | M_FORMAT_NOFILTER);
+                          flags | MUTT_FORMAT_NOFILTER);
         for (p = buf; p && *p; p++)
         {
           if (*p == '\'')
@@ -1234,7 +1234,7 @@ void mutt_FormatString (char *dest,		/* output buffer */
 
       col -= wlen;	/* reset to passed in value */
       wptr = dest;      /* reset write ptr */
-      wlen = ((flags & M_FORMAT_ARROWCURSOR) && option (OPTARROWCURSOR)) ? 3 : 0;
+      wlen = ((flags & MUTT_FORMAT_ARROWCURSOR) && option (OPTARROWCURSOR)) ? 3 : 0;
       if ((pid = mutt_create_filter(command->data, NULL, &filter, NULL)) != -1)
       {
 	int rc;
@@ -1327,7 +1327,7 @@ void mutt_FormatString (char *dest,		/* output buffer */
 
       if (*src == '<')
       {
-	flags |= M_FORMAT_OPTIONAL;
+	flags |= MUTT_FORMAT_OPTIONAL;
 	ch = *(++src); /* save the character to switch on */
 	src++;
 	cp = prefix;
@@ -1340,7 +1340,7 @@ void mutt_FormatString (char *dest,		/* output buffer */
       }
       else
       {
-	flags &= ~M_FORMAT_OPTIONAL;
+	flags &= ~MUTT_FORMAT_OPTIONAL;
 
 	/* eat the format string */
 	cp = prefix;
@@ -1359,7 +1359,7 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	ch = *src++; /* save the character to switch on */
       }
 
-      if (flags & M_FORMAT_OPTIONAL)
+      if (flags & MUTT_FORMAT_OPTIONAL)
       {
 	int lrbalance;
 
@@ -1467,7 +1467,7 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	  }
 	  else if (soft && pad < 0)
 	  {
-	    int offset = ((flags & M_FORMAT_ARROWCURSOR) && option (OPTARROWCURSOR)) ? 3 : 0;
+	    int offset = ((flags & MUTT_FORMAT_ARROWCURSOR) && option (OPTARROWCURSOR)) ? 3 : 0;
             int avail_cols = (cols > offset) ? (cols - offset) : 0;
 	    /* \0-terminate dest for length computation in mutt_wstr_trunc() */
 	    *wptr = 0;
@@ -1611,13 +1611,13 @@ void mutt_FormatString (char *dest,		/* output buffer */
   *wptr = 0;
 
 #if 0
-  if (flags & M_FORMAT_MAKEPRINT)
+  if (flags & MUTT_FORMAT_MAKEPRINT)
   {
     /* Make sure that the string is printable by changing all non-printable
        chars to dots, or spaces for non-printable whitespace */
     for (cp = dest ; *cp ; cp++)
       if (!IsPrint (*cp) &&
-	  !((flags & M_FORMAT_TREE) && (*cp <= M_TREE_MAX)))
+	  !((flags & MUTT_FORMAT_TREE) && (*cp <= MUTT_TREE_MAX)))
 	*cp = isspace ((unsigned char) *cp) ? ' ' : '.';
   }
 #endif
@@ -1670,7 +1670,7 @@ int mutt_save_confirm (const char *s, struct stat *st)
   magic = mx_get_magic (s);
 
 #ifdef USE_POP
-  if (magic == M_POP)
+  if (magic == MUTT_POP)
   {
     mutt_error _("Can't save message to POP mailbox.");
     return 1;
@@ -1684,7 +1684,7 @@ int mutt_save_confirm (const char *s, struct stat *st)
        /* if we're appending to the trash, there's no point in asking */
     {
       snprintf (tmp, sizeof (tmp), _("Append messages to %s?"), s);
-      if ((rc = mutt_yesorno (tmp, M_YES)) == M_NO)
+      if ((rc = mutt_yesorno (tmp, MUTT_YES)) == MUTT_NO)
 	ret = 1;
       else if (rc == -1)
 	ret = -1;
@@ -1692,7 +1692,7 @@ int mutt_save_confirm (const char *s, struct stat *st)
   }
 
 #ifdef USE_NNTP
-  if (magic == M_NNTP)
+  if (magic == MUTT_NNTP)
   {
     mutt_error _("Can't save message to news server.");
     return 0;
@@ -1707,7 +1707,7 @@ int mutt_save_confirm (const char *s, struct stat *st)
       return 1;
     }
   }
-  else if (magic != M_IMAP)
+  else if (magic != MUTT_IMAP)
   {
     st->st_mtime = 0;
     st->st_atime = 0;
@@ -1717,7 +1717,7 @@ int mutt_save_confirm (const char *s, struct stat *st)
       if (option (OPTCONFIRMCREATE))
       {
 	snprintf (tmp, sizeof (tmp), _("Create %s?"), s);
-	if ((rc = mutt_yesorno (tmp, M_YES)) == M_NO)
+	if ((rc = mutt_yesorno (tmp, MUTT_YES)) == MUTT_NO)
 	  ret = 1;
 	else if (rc == -1)
 	  ret = -1;
@@ -1736,7 +1736,7 @@ int mutt_save_confirm (const char *s, struct stat *st)
 
 void state_prefix_putc (char c, STATE *s)
 {
-  if (s->flags & M_PENDINGPREFIX)
+  if (s->flags & MUTT_PENDINGPREFIX)
   {
     state_reset_prefix (s);
     if (s->prefix)
@@ -1763,7 +1763,7 @@ int state_printf (STATE *s, const char *fmt, ...)
 
 void state_mark_attach (STATE *s)
 {
-  if ((s->flags & M_DISPLAY) && !mutt_strcmp (Pager, "builtin"))
+  if ((s->flags & MUTT_DISPLAY) && !mutt_strcmp (Pager, "builtin"))
     state_puts (AttachmentMarker, s);
 }
 
diff --git a/mx.c b/mx.c
index 670a27c..bd10175 100644
--- a/mx.c
+++ b/mx.c
@@ -134,7 +134,7 @@ retry_lock:
       
       snprintf(msg, sizeof(msg), _("Lock count exceeded, remove lock for %s?"),
 	       path);
-      if(retry && mutt_yesorno(msg, M_YES) == M_YES)
+      if(retry && mutt_yesorno(msg, MUTT_YES) == MUTT_YES)
       {
 	flags |= DL_FL_FORCE;
 	retry--;
@@ -405,22 +405,22 @@ int mx_get_magic (const char *path)
 
 #ifdef USE_IMAP
   if(mx_is_imap(path))
-    return M_IMAP;
+    return MUTT_IMAP;
 #endif /* USE_IMAP */
 
 #ifdef USE_POP
   if (mx_is_pop (path))
-    return M_POP;
+    return MUTT_POP;
 #endif /* USE_POP */
 
 #ifdef USE_NNTP
   if (mx_is_nntp (path))
-    return M_NNTP;
+    return MUTT_NNTP;
 #endif /* USE_NNTP */
 
 #ifdef USE_NOTMUCH
   if (mx_is_notmuch(path))
-    return M_NOTMUCH;
+    return MUTT_NOTMUCH;
 #endif
 
   if (stat (path, &st) == -1)
@@ -434,19 +434,19 @@ int mx_get_magic (const char *path)
   {
     /* check for maildir-style mailbox */
     if (mx_is_maildir (path))
-      return M_MAILDIR;
+      return MUTT_MAILDIR;
 
     /* check for mh-style mailbox */
     if (mx_is_mh (path))
-      return M_MH;
+      return MUTT_MH;
   }
   else if (st.st_size == 0)
   {
     /* hard to tell what zero-length files are, so assume the default magic */
-    if (DefaultMagic == M_MBOX || DefaultMagic == M_MMDF)
+    if (DefaultMagic == MUTT_MBOX || DefaultMagic == MUTT_MMDF)
       return (DefaultMagic);
     else
-      return (M_MBOX);
+      return (MUTT_MBOX);
   }
   else if ((f = fopen (path, "r")) != NULL)
   {
@@ -454,9 +454,9 @@ int mx_get_magic (const char *path)
 
     fgets (tmp, sizeof (tmp), f);
     if (mutt_strncmp ("From ", tmp, 5) == 0)
-      magic = M_MBOX;
+      magic = MUTT_MBOX;
     else if (mutt_strcmp (MMDF_SEP, tmp) == 0)
-      magic = M_MMDF;
+      magic = MUTT_MMDF;
     safe_fclose (&f);
 
     if (!option(OPTCHECKMBOXSIZE))
@@ -479,7 +479,7 @@ int mx_get_magic (const char *path)
 
 #ifdef USE_COMPRESSED
   if (magic == 0 && comp_can_read (path))
-    return M_COMPRESSED;
+    return MUTT_COMPRESSED;
 #endif
   return (magic);
 }
@@ -490,13 +490,13 @@ int mx_get_magic (const char *path)
 int mx_set_magic (const char *s)
 {
   if (ascii_strcasecmp (s, "mbox") == 0)
-    DefaultMagic = M_MBOX;
+    DefaultMagic = MUTT_MBOX;
   else if (ascii_strcasecmp (s, "mmdf") == 0)
-    DefaultMagic = M_MMDF;
+    DefaultMagic = MUTT_MMDF;
   else if (ascii_strcasecmp (s, "mh") == 0)
-    DefaultMagic = M_MH;
+    DefaultMagic = MUTT_MH;
   else if (ascii_strcasecmp (s, "maildir") == 0)
-    DefaultMagic = M_MAILDIR;
+    DefaultMagic = MUTT_MAILDIR;
   else
     return (-1);
 
@@ -553,7 +553,7 @@ static int mx_open_mailbox_append (CONTEXT *ctx, int flags)
   {
     ctx->magic = DefaultMagic;
 
-    if (ctx->magic == M_MH || ctx->magic == M_MAILDIR)
+    if (ctx->magic == MUTT_MH || ctx->magic == MUTT_MAILDIR)
     {
       char tmp[_POSIX_PATH_MAX];
 
@@ -563,7 +563,7 @@ static int mx_open_mailbox_append (CONTEXT *ctx, int flags)
 	return (-1);
       }
 
-      if (ctx->magic == M_MAILDIR)
+      if (ctx->magic == MUTT_MAILDIR)
       {
 	snprintf (tmp, sizeof (tmp), "%s/cur", ctx->path);
 	if (mkdir (tmp, S_IRWXU))
@@ -617,9 +617,9 @@ static int mx_open_mailbox_append (CONTEXT *ctx, int flags)
 
   switch (ctx->magic)
   {
-    case M_MBOX:
-    case M_MMDF:
-    if ((ctx->fp = safe_fopen (ctx->path, flags & M_NEWFOLDER ? "w" : "a")) == NULL ||
+    case MUTT_MBOX:
+    case MUTT_MMDF:
+    if ((ctx->fp = safe_fopen (ctx->path, flags & MUTT_NEWFOLDER ? "w" : "a")) == NULL ||
 	  mbox_lock_mailbox (ctx, 1, 1) != 0)
       {
 	if (!ctx->fp)
@@ -634,8 +634,8 @@ static int mx_open_mailbox_append (CONTEXT *ctx, int flags)
       fseek (ctx->fp, 0, 2);
       break;
 
-    case M_MH:
-    case M_MAILDIR:
+    case MUTT_MH:
+    case MUTT_MAILDIR:
       /* nothing to do */
       break;
 
@@ -650,11 +650,11 @@ static int mx_open_mailbox_append (CONTEXT *ctx, int flags)
  * open a mailbox and parse it
  *
  * Args:
- *	flags	M_NOSORT	do not sort mailbox
- *		M_APPEND	open mailbox for appending
- *		M_READONLY	open mailbox in read-only mode
- *		M_QUIET		only print error messages
- *		M_PEEK		revert atime where applicable
+ *	flags	MUTT_NOSORT	do not sort mailbox
+ *		MUTT_APPEND	open mailbox for appending
+ *		MUTT_READONLY	open mailbox in read-only mode
+ *		MUTT_QUIET		only print error messages
+ *		MUTT_PEEK		revert atime where applicable
  *	ctx	if non-null, context struct to use
  */
 CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
@@ -673,16 +673,16 @@ CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
   for (rc=0; rc < RIGHTSMAX; rc++)
     mutt_bit_set(ctx->rights,rc);
 
-  if (flags & M_QUIET)
+  if (flags & MUTT_QUIET)
     ctx->quiet = 1;
-  if (flags & M_READONLY)
+  if (flags & MUTT_READONLY)
     ctx->readonly = 1;
 #ifdef USE_SIDEBAR
-  if (flags & M_PEEK)
+  if (flags & MUTT_PEEK)
     ctx->peekonly = 1;
 #endif
 
-  if (flags & (M_APPEND|M_NEWFOLDER))
+  if (flags & (MUTT_APPEND|MUTT_NEWFOLDER))
   {
     if (mx_open_mailbox_append (ctx, flags) != 0)
     {
@@ -697,7 +697,7 @@ CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
   ctx->magic = mx_get_magic (path);
 
 #ifdef USE_COMPRESSED
-  if (ctx->magic == M_COMPRESSED)
+  if (ctx->magic == MUTT_COMPRESSED)
     comp_open_read (ctx);
 #endif
 
@@ -727,39 +727,39 @@ CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
 
   switch (ctx->magic)
   {
-    case M_MH:
+    case MUTT_MH:
       rc = mh_read_dir (ctx, NULL);
       break;
 
-    case M_MAILDIR:
+    case MUTT_MAILDIR:
       rc = maildir_read_dir (ctx);
       break;
 
-    case M_MMDF:
-    case M_MBOX:
+    case MUTT_MMDF:
+    case MUTT_MBOX:
       rc = mbox_open_mailbox (ctx);
       break;
 
 #ifdef USE_IMAP
-    case M_IMAP:
+    case MUTT_IMAP:
       rc = imap_open_mailbox (ctx);
       break;
 #endif /* USE_IMAP */
 
 #ifdef USE_POP
-    case M_POP:
+    case MUTT_POP:
       rc = pop_open_mailbox (ctx);
       break;
 #endif /* USE_POP */
 
 #ifdef USE_NNTP
-    case M_NNTP:
+    case MUTT_NNTP:
       rc = nntp_open_mailbox (ctx);
       break;
 #endif /* USE_NNTP */
 
 #ifdef USE_NOTMUCH
-    case M_NOTMUCH:
+    case MUTT_NOTMUCH:
       rc = nm_read_query (ctx);
       break;
 #endif /* USE_IMAP */
@@ -771,7 +771,7 @@ CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
 
   if (rc == 0)
   {
-    if ((flags & M_NOSORT) == 0)
+    if ((flags & MUTT_NOSORT) == 0)
     {
       /* avoid unnecessary work since the mailbox is completely unthreaded
 	 to begin with */
@@ -857,39 +857,39 @@ static int sync_mailbox (CONTEXT *ctx, int *index_hint)
 
   switch (ctx->magic)
   {
-    case M_MBOX:
-    case M_MMDF:
+    case MUTT_MBOX:
+    case MUTT_MMDF:
       rc = mbox_sync_mailbox (ctx, index_hint);
       if (option(OPTCHECKMBOXSIZE))
 	tmp = mutt_find_mailbox (ctx->path);
       break;
       
-    case M_MH:
-    case M_MAILDIR:
+    case MUTT_MH:
+    case MUTT_MAILDIR:
       rc = mh_sync_mailbox (ctx, index_hint);
       break;
       
 #ifdef USE_IMAP
-    case M_IMAP:
+    case MUTT_IMAP:
       /* extra argument means EXPUNGE */
       rc = imap_sync_mailbox (ctx, 1, index_hint);
       break;
 #endif /* USE_IMAP */
 
 #ifdef USE_POP
-    case M_POP:
+    case MUTT_POP:
       rc = pop_sync_mailbox (ctx, index_hint);
       break;
 #endif /* USE_POP */
 
 #ifdef USE_NNTP
-    case M_NNTP:
+    case MUTT_NNTP:
       rc = nntp_sync_mailbox (ctx);
       break;
 #endif /* USE_NNTP */
 
 #ifdef USE_NOTMUCH
-    case M_NOTMUCH:
+    case MUTT_NOTMUCH:
       rc = nm_sync (ctx, index_hint);
       break;
 #endif /* USE_NOTMUCH */
@@ -924,7 +924,7 @@ static int trash_append (CONTEXT *ctx)
 	struct stat st, stc;
 
 	if (!TrashPath || !ctx->deleted ||
-	   ((ctx->magic == M_MAILDIR) && option (OPTMAILDIRTRASH))) {
+	   ((ctx->magic == MUTT_MAILDIR) && option (OPTMAILDIRTRASH))) {
 		return 0;
 	}
 
@@ -949,7 +949,7 @@ static int trash_append (CONTEXT *ctx)
 		return 0;
 #endif
 
-	if ((ctx_trash = mx_open_mailbox (TrashPath, M_APPEND, NULL)) != NULL) {
+	if ((ctx_trash = mx_open_mailbox (TrashPath, MUTT_APPEND, NULL)) != NULL) {
 		for (i = 0 ; i < ctx->msgcount ; i++) {
 			if (ctx->hdrs[i]->deleted && !ctx->hdrs[i]->appended
 			    && !ctx->hdrs[i]->purged
@@ -992,7 +992,7 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
   if (ctx->append)
   {
     /* mailbox was opened in write-mode */
-    if (ctx->magic == M_MBOX || ctx->magic == M_MMDF)
+    if (ctx->magic == MUTT_MBOX || ctx->magic == MUTT_MMDF)
       mbox_close_mailbox (ctx);
     else
       mx_fastclose_mailbox (ctx);
@@ -1000,7 +1000,7 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
   }
 
 #ifdef USE_NNTP
-  if (ctx->unread && ctx->magic == M_NNTP)
+  if (ctx->unread && ctx->magic == MUTT_NNTP)
   {
     NNTP_DATA *nntp_data = ctx->data;
 
@@ -1012,7 +1012,7 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
 	ctx->closing = 0;
 	return -1;
       }
-      else if (rc == M_YES)
+      else if (rc == MUTT_YES)
 	mutt_newsgroup_catchup (nntp_data->nserv, nntp_data->group);
     }
   }
@@ -1033,15 +1033,15 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
 
 #ifdef USE_NNTP
   /* don't need to move articles from newsgroup */
-  if (ctx->magic == M_NNTP)
+  if (ctx->magic == MUTT_NNTP)
     read_msgs = 0;
 #endif
 
-  if (read_msgs && quadoption (OPT_MOVE) != M_NO)
+  if (read_msgs && quadoption (OPT_MOVE) != MUTT_NO)
   {
     char *p;
 
-    if ((p = mutt_find_hook (M_MBOXHOOK, ctx->path)))
+    if ((p = mutt_find_hook (MUTT_MBOXHOOK, ctx->path)))
     {
       isSpool = 1;
       strfcpy (mbox, p, sizeof (mbox));
@@ -1068,7 +1068,7 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
    * There is no point in asking whether or not to purge if we are
    * just marking messages as "trash".
    */
-  if (ctx->deleted && !(ctx->magic == M_MAILDIR && option (OPTMAILDIRTRASH)))
+  if (ctx->deleted && !(ctx->magic == MUTT_MAILDIR && option (OPTMAILDIRTRASH)))
   {
     snprintf (buf, sizeof (buf), ctx->deleted == 1
 	     ? _("Purge %d deleted message?") : _("Purge %d deleted messages?"),
@@ -1085,7 +1085,7 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
     for (i = 0; i < ctx->msgcount; i++)
     {
       if (!ctx->hdrs[i]->deleted && !ctx->hdrs[i]->old && !ctx->hdrs[i]->read)
-	mutt_set_flag (ctx, ctx->hdrs[i], M_OLD, 1);
+	mutt_set_flag (ctx, ctx->hdrs[i], MUTT_OLD, 1);
     }
   }
 
@@ -1098,7 +1098,7 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
     /* try to use server-side copy first */
     i = 1;
     
-    if (ctx->magic == M_IMAP && mx_is_imap (mbox))
+    if (ctx->magic == MUTT_IMAP && mx_is_imap (mbox))
     {
       /* tag messages for moving, and clear old tags, if any */
       for (i = 0; i < ctx->msgcount; i++)
@@ -1121,7 +1121,7 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
     else /* use regular append-copy mode */
 #endif
     {
-      if (mx_open_mailbox (mbox, M_APPEND, &f) == NULL)
+      if (mx_open_mailbox (mbox, MUTT_APPEND, &f) == NULL)
       {
 	ctx->closing = 0;
 	return -1;
@@ -1134,8 +1134,8 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
         {
 	  if (mutt_append_message (&f, ctx, ctx->hdrs[i], 0, CH_UPDATE_LEN) == 0)
 	  {
-	    mutt_set_flag (ctx, ctx->hdrs[i], M_DELETE, 1);
-	    mutt_set_flag (ctx, ctx->hdrs[i], M_APPENDED, 1);
+	    mutt_set_flag (ctx, ctx->hdrs[i], MUTT_DELETE, 1);
+	    mutt_set_flag (ctx, ctx->hdrs[i], MUTT_APPENDED, 1);
 	  }
 	  else
 	  {
@@ -1154,7 +1154,7 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
   {
     if (!ctx->quiet)
       mutt_message _("Mailbox is unchanged.");
-    if (ctx->magic == M_MBOX || ctx->magic == M_MMDF)
+    if (ctx->magic == MUTT_MBOX || ctx->magic == MUTT_MMDF)
       mbox_reset_atime (ctx, NULL);
     mx_fastclose_mailbox (ctx);
     return 0;
@@ -1170,7 +1170,7 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
 
 #ifdef USE_IMAP
   /* allow IMAP to preserve the deleted flag across sessions */
-  if (ctx->magic == M_IMAP)
+  if (ctx->magic == MUTT_IMAP)
   {
     if ((check = imap_sync_mailbox (ctx, purge, index_hint)) != 0)
     {
@@ -1209,7 +1209,7 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
   }
 
   if (ctx->msgcount == ctx->deleted &&
-      (ctx->magic == M_MMDF || ctx->magic == M_MBOX) &&
+      (ctx->magic == MUTT_MMDF || ctx->magic == MUTT_MBOX) &&
       !mutt_is_spool(ctx->path) && !option (OPTSAVEEMPTY))
     mx_unlink_empty (ctx->path);
 
@@ -1244,7 +1244,7 @@ void mx_update_tables(CONTEXT *ctx, int committing)
   {
     if (!ctx->hdrs[i]->quasi_deleted &&
 	((committing && (!ctx->hdrs[i]->deleted ||
-			(ctx->magic == M_MAILDIR && option (OPTMAILDIRTRASH)))) ||
+			(ctx->magic == MUTT_MAILDIR && option (OPTMAILDIRTRASH)))) ||
 	(!committing && ctx->hdrs[i]->active)))
     {
       if (i != j)
@@ -1266,7 +1266,7 @@ void mx_update_tables(CONTEXT *ctx, int committing)
       else if (ctx->hdrs[j]->changed)
 	ctx->changed++;
       
-      if (!committing || (ctx->magic == M_MAILDIR && option (OPTMAILDIRTRASH)))
+      if (!committing || (ctx->magic == MUTT_MAILDIR && option (OPTMAILDIRTRASH)))
       {
 	if (ctx->hdrs[j]->deleted)
 	  ctx->deleted++;
@@ -1287,7 +1287,7 @@ void mx_update_tables(CONTEXT *ctx, int committing)
     }
     else
     {
-      if (ctx->magic == M_MH || ctx->magic == M_MAILDIR)
+      if (ctx->magic == MUTT_MH || ctx->magic == MUTT_MAILDIR)
 	ctx->size -= (ctx->hdrs[i]->content->length +
 		      ctx->hdrs[i]->content->offset -
 		      ctx->hdrs[i]->content->hdr_offset);
@@ -1357,12 +1357,12 @@ int mx_sync_mailbox (CONTEXT *ctx, int *index_hint)
 	      ctx->deleted);
     if ((purge = query_quadoption (OPT_DELETE, buf)) < 0)
       return (-1);
-    else if (purge == M_NO)
+    else if (purge == MUTT_NO)
     {
       if (!ctx->changed)
 	return 0; /* nothing to do! */
       /* let IMAP servers hold on to D flags */
-      if (ctx->magic != M_IMAP)
+      if (ctx->magic != MUTT_IMAP)
       {
         for (i = 0 ; i < ctx->msgcount ; i++)
           ctx->hdrs[i]->deleted = 0;
@@ -1385,7 +1385,7 @@ int mx_sync_mailbox (CONTEXT *ctx, int *index_hint)
   }
 
 #ifdef USE_IMAP
-  if (ctx->magic == M_IMAP)
+  if (ctx->magic == MUTT_IMAP)
     rc = imap_sync_mailbox (ctx, purge, index_hint);
   else
 #endif
@@ -1393,7 +1393,7 @@ int mx_sync_mailbox (CONTEXT *ctx, int *index_hint)
   if (rc == 0)
   {
 #ifdef USE_IMAP
-    if (ctx->magic == M_IMAP && !purge)
+    if (ctx->magic == MUTT_IMAP && !purge)
     {
       if (!ctx->quiet)
         mutt_message _("Mailbox checkpointed.");
@@ -1409,7 +1409,7 @@ int mx_sync_mailbox (CONTEXT *ctx, int *index_hint)
     mutt_sleep (0);
     
     if (ctx->msgcount == ctx->deleted &&
-	(ctx->magic == M_MBOX || ctx->magic == M_MMDF) &&
+	(ctx->magic == MUTT_MBOX || ctx->magic == MUTT_MMDF) &&
 	!mutt_is_spool (ctx->path) && !option (OPTSAVEEMPTY))
     {
       unlink (ctx->path);
@@ -1424,10 +1424,10 @@ int mx_sync_mailbox (CONTEXT *ctx, int *index_hint)
      * MH and maildir are safe.  mbox-style seems to need re-sorting,
      * at least with the new threading code.
      */
-    if (purge || (ctx->magic != M_MAILDIR && ctx->magic != M_MH))
+    if (purge || (ctx->magic != MUTT_MAILDIR && ctx->magic != MUTT_MH))
     {
       /* IMAP does this automatically after handling EXPUNGE */
-      if (ctx->magic != M_IMAP)
+      if (ctx->magic != MUTT_IMAP)
       {
 	mx_update_tables (ctx, 1);
 	mutt_sort_headers (ctx, 1); /* rethread from scratch */
@@ -1476,18 +1476,18 @@ MESSAGE *mx_open_new_message (CONTEXT *dest, HEADER *hdr, int flags)
 
   switch (dest->magic)
   {
-    case M_MMDF:
-    case M_MBOX:
+    case MUTT_MMDF:
+    case MUTT_MBOX:
       func = mbox_open_new_message;
       break;
-    case M_MAILDIR:
+    case MUTT_MAILDIR:
       func = maildir_open_new_message;
       break;
-    case M_MH:
+    case MUTT_MH:
       func = mh_open_new_message;
       break;
 #ifdef USE_IMAP
-    case M_IMAP:
+    case MUTT_IMAP:
       func = imap_open_new_message;
       break;
 #endif
@@ -1506,7 +1506,7 @@ MESSAGE *mx_open_new_message (CONTEXT *dest, HEADER *hdr, int flags)
     msg->flags.flagged = hdr->flagged;
     msg->flags.replied = hdr->replied;
     msg->flags.read    = hdr->read;
-    msg->flags.draft   = (flags & M_SET_DRAFT) ? 1 : 0;
+    msg->flags.draft   = (flags & MUTT_SET_DRAFT) ? 1 : 0;
     msg->received = hdr->received;
   }
 
@@ -1515,11 +1515,11 @@ MESSAGE *mx_open_new_message (CONTEXT *dest, HEADER *hdr, int flags)
   
   if (func (msg, dest, hdr) == 0)
   {
-    if (dest->magic == M_MMDF)
+    if (dest->magic == MUTT_MMDF)
       fputs (MMDF_SEP, msg->fp);
 
-    if ((msg->magic == M_MBOX || msg->magic ==  M_MMDF) &&
-	flags & M_ADD_FROM)
+    if ((msg->magic == MUTT_MBOX || msg->magic ==  MUTT_MMDF) &&
+	flags & MUTT_ADD_FROM)
     {
       if (hdr)
       {
@@ -1556,8 +1556,8 @@ int mx_check_mailbox (CONTEXT *ctx, int *index_hint, int lock)
 
     switch (ctx->magic)
     {
-      case M_MBOX:
-      case M_MMDF:
+      case MUTT_MBOX:
+      case MUTT_MMDF:
 
 	if (lock)
 	{
@@ -1565,7 +1565,7 @@ int mx_check_mailbox (CONTEXT *ctx, int *index_hint, int lock)
 	  if (mbox_lock_mailbox (ctx, 0, 0) == -1)
 	  {
 	    mutt_unblock_signals ();
-	    return M_LOCKED;
+	    return MUTT_LOCKED;
 	  }
 	}
 	
@@ -1580,13 +1580,13 @@ int mx_check_mailbox (CONTEXT *ctx, int *index_hint, int lock)
 	return rc;
 
 
-      case M_MH:
+      case MUTT_MH:
 	return (mh_check_mailbox (ctx, index_hint));
-      case M_MAILDIR:
+      case MUTT_MAILDIR:
 	return (maildir_check_mailbox (ctx, index_hint));
 
 #ifdef USE_IMAP
-      case M_IMAP:
+      case MUTT_IMAP:
 	/* caller expects that mailbox may change */
         imap_allow_reopen (ctx);
 	rc = imap_check_mailbox (ctx, index_hint, 0);
@@ -1595,17 +1595,17 @@ int mx_check_mailbox (CONTEXT *ctx, int *index_hint, int lock)
 #endif /* USE_IMAP */
 
 #ifdef USE_POP
-      case M_POP:
+      case MUTT_POP:
 	return (pop_check_mailbox (ctx, index_hint));
 #endif /* USE_POP */
 
 #ifdef USE_NNTP
-      case M_NNTP:
+      case MUTT_NNTP:
 	return (nntp_check_mailbox (ctx, 0));
 #endif /* USE_NNTP */
 
 #ifdef USE_NOTMUCH
-      case M_NOTMUCH:
+      case MUTT_NOTMUCH:
 	return nm_check_database(ctx, index_hint);
 #endif
 }
@@ -1623,22 +1623,22 @@ MESSAGE *mx_open_message (CONTEXT *ctx, int msgno)
   msg = safe_calloc (1, sizeof (MESSAGE));
   switch (msg->magic = ctx->magic)
   {
-    case M_MBOX:
-    case M_MMDF:
+    case MUTT_MBOX:
+    case MUTT_MMDF:
       msg->fp = ctx->fp;
       break;
 
-    case M_MH:
-    case M_MAILDIR:
+    case MUTT_MH:
+    case MUTT_MAILDIR:
 #ifdef USE_NOTMUCH
-    case M_NOTMUCH:
+    case MUTT_NOTMUCH:
 #endif
     {
       HEADER *cur = ctx->hdrs[msgno];
       char path[_POSIX_PATH_MAX];
       char *folder = ctx->path;
 #ifdef USE_NOTMUCH
-      if (ctx->magic == M_NOTMUCH) {
+      if (ctx->magic == MUTT_NOTMUCH) {
 	msg->magic = nm_header_get_magic(cur);
 	folder = nm_header_get_folder(cur);
       }
@@ -1646,7 +1646,7 @@ MESSAGE *mx_open_message (CONTEXT *ctx, int msgno)
       snprintf (path, sizeof (path), "%s/%s", folder, cur->path);
 
       if ((msg->fp = fopen (path, "r")) == NULL && errno == ENOENT &&
-	  (ctx->magic == M_MAILDIR || ctx->magic == M_NOTMUCH))
+	  (ctx->magic == MUTT_MAILDIR || ctx->magic == MUTT_NOTMUCH))
 	msg->fp = maildir_open_find_message (folder, cur->path, NULL);
       
       if (msg->fp == NULL)
@@ -1660,7 +1660,7 @@ MESSAGE *mx_open_message (CONTEXT *ctx, int msgno)
     break;
     
 #ifdef USE_IMAP
-    case M_IMAP:
+    case MUTT_IMAP:
     {
       if (imap_fetch_message (msg, ctx, msgno) != 0)
 	FREE (&msg);
@@ -1669,7 +1669,7 @@ MESSAGE *mx_open_message (CONTEXT *ctx, int msgno)
 #endif /* USE_IMAP */
 
 #ifdef USE_POP
-    case M_POP:
+    case MUTT_POP:
     {
       if (pop_fetch_message (msg, ctx, msgno) != 0)
 	FREE (&msg);
@@ -1678,7 +1678,7 @@ MESSAGE *mx_open_message (CONTEXT *ctx, int msgno)
 #endif /* USE_POP */
 
 #ifdef USE_NNTP
-    case M_NNTP:
+    case MUTT_NNTP:
     {
       if (nntp_fetch_message (msg, ctx, msgno) != 0)
 	FREE (&msg);
@@ -1709,14 +1709,14 @@ int mx_commit_message (MESSAGE *msg, CONTEXT *ctx)
 
   switch (msg->magic)
   {
-    case M_MMDF:
+    case MUTT_MMDF:
     {
       if (fputs (MMDF_SEP, msg->fp) == EOF)
 	r = -1;
       break;
     }
     
-    case M_MBOX:
+    case MUTT_MBOX:
     {
       if (fputc ('\n', msg->fp) == EOF)
 	r = -1;
@@ -1724,7 +1724,7 @@ int mx_commit_message (MESSAGE *msg, CONTEXT *ctx)
     }
 
 #ifdef USE_IMAP
-    case M_IMAP:
+    case MUTT_IMAP:
     {
       if ((r = safe_fclose (&msg->fp)) == 0)
 	r = imap_append_message (ctx, msg);
@@ -1732,24 +1732,24 @@ int mx_commit_message (MESSAGE *msg, CONTEXT *ctx)
     }
 #endif
 
-    case M_MAILDIR:
+    case MUTT_MAILDIR:
     {
       r = maildir_commit_message (ctx, msg, NULL);
       break;
     }
 
-    case M_NOTMUCH:
+    case MUTT_NOTMUCH:
       mutt_perror _("Can't write to virtual folder.");
       break;
 
-    case M_MH:
+    case MUTT_MH:
     {
       r = mh_commit_message (ctx, msg, NULL);
       break;
     }
   }
   
-  if (r == 0 && (ctx->magic == M_MBOX || ctx->magic == M_MMDF)
+  if (r == 0 && (ctx->magic == MUTT_MBOX || ctx->magic == MUTT_MMDF)
       && (fflush (msg->fp) == EOF || fsync (fileno (msg->fp)) == -1))
   {
     mutt_perror _("Can't write message");
@@ -1764,12 +1764,12 @@ int mx_close_message (MESSAGE **msg)
 {
   int r = 0;
 
-  if ((*msg)->magic == M_MH || (*msg)->magic == M_MAILDIR
+  if ((*msg)->magic == MUTT_MH || (*msg)->magic == MUTT_MAILDIR
 #ifdef USE_NNTP
-      || (*msg)->magic == M_NNTP
+      || (*msg)->magic == MUTT_NNTP
 #endif
-      || (*msg)->magic == M_IMAP || (*msg)->magic == M_POP
-      || (*msg)->magic == M_NOTMUCH)
+      || (*msg)->magic == MUTT_IMAP || (*msg)->magic == MUTT_POP
+      || (*msg)->magic == MUTT_NOTMUCH)
   {
     r = safe_fclose (&(*msg)->fp);
   }
@@ -1779,7 +1779,7 @@ int mx_close_message (MESSAGE **msg)
   dprint (2, (debugfile, "mx_close_message (): close: path=%s, commited=%s\n",
 	(*msg)->path, (*msg)->commited_path));
 
-  if ((*msg)->path && (*msg)->magic != M_NOTMUCH)
+  if ((*msg)->path && (*msg)->magic != MUTT_NOTMUCH)
   {
     dprint (1, (debugfile, "mx_close_message (): unlinking %s\n",
 		(*msg)->path));
@@ -1900,12 +1900,12 @@ int mx_check_empty (const char *path)
 {
   switch (mx_get_magic (path))
   {
-    case M_MBOX:
-    case M_MMDF:
+    case MUTT_MBOX:
+    case MUTT_MMDF:
       return mbox_check_empty (path);
-    case M_MH:
+    case MUTT_MH:
       return mh_check_empty (path);
-    case M_MAILDIR:
+    case MUTT_MAILDIR:
       return maildir_check_empty (path);
     default:
       errno = EINVAL;
diff --git a/mx.h b/mx.h
index a0275e0..e17566c 100644
--- a/mx.h
+++ b/mx.h
@@ -31,22 +31,22 @@
 /* supported mailbox formats */
 enum
 {
-  M_MBOX = 1,
-  M_MMDF,
-  M_MH,
-  M_MAILDIR,
+  MUTT_MBOX = 1,
+  MUTT_MMDF,
+  MUTT_MH,
+  MUTT_MAILDIR,
 #ifdef USE_NNTP
-  M_NNTP,
+  MUTT_NNTP,
 #endif
-  M_IMAP,
-  M_NOTMUCH,
-  M_POP
+  MUTT_IMAP,
+  MUTT_NOTMUCH,
+  MUTT_POP
 #ifdef USE_COMPRESSED
-  , M_COMPRESSED
+  , MUTT_COMPRESSED
 #endif
 };
 
-WHERE short DefaultMagic INITVAL (M_MBOX);
+WHERE short DefaultMagic INITVAL (MUTT_MBOX);
 
 #define MMDF_SEP "\001\001\001\001\n"
 #define MAXLOCKATTEMPT 5
diff --git a/newsrc.c b/newsrc.c
index d2123bc..066d4c7 100644
--- a/newsrc.c
+++ b/newsrc.c
@@ -826,7 +826,7 @@ nntp_format_str (char *dest, size_t destlen, size_t col, int cols, char op, cons
       break;
     case 'P':
       *dest = '\0';
-      if (acct->flags & M_ACCT_PORT)
+      if (acct->flags & MUTT_ACCT_PORT)
       {
 	snprintf (tmp, sizeof (tmp), "%%%su", fmt);
 	snprintf (dest, destlen, tmp, acct->port);
@@ -881,7 +881,7 @@ NNTP_SERVER *nntp_select_server (char *server, int leave_lock)
   /* create account from news server url */
   acct.flags = 0;
   acct.port = NNTP_PORT;
-  acct.type = M_ACCT_TYPE_NNTP;
+  acct.type = MUTT_ACCT_TYPE_NNTP;
   snprintf (file, sizeof (file), "%s%s",
 	    strstr (server, "://") ? "" : "news://", server);
   if (url_parse_ciss (&url, file) < 0 ||
@@ -895,7 +895,7 @@ NNTP_SERVER *nntp_select_server (char *server, int leave_lock)
   }
   if (url.scheme == U_NNTPS)
   {
-    acct.flags |= M_ACCT_SSL;
+    acct.flags |= MUTT_ACCT_SSL;
     acct.port = NNTP_SSL_PORT;
   }
 
@@ -903,9 +903,9 @@ NNTP_SERVER *nntp_select_server (char *server, int leave_lock)
   conn = mutt_conn_find (NULL, &acct);
   if (!conn)
     return NULL;
-  if (!(conn->account.flags & M_ACCT_USER) && acct.flags & M_ACCT_USER)
+  if (!(conn->account.flags & MUTT_ACCT_USER) && acct.flags & MUTT_ACCT_USER)
   {
-    conn->account.flags |= M_ACCT_USER;
+    conn->account.flags |= MUTT_ACCT_USER;
     conn->account.user[0] = '\0';
   }
 
@@ -1196,7 +1196,7 @@ NNTP_DATA *mutt_newsgroup_catchup (NNTP_SERVER *nserv, char *group)
     unsigned int i;
 
     for (i = 0; i < Context->msgcount; i++)
-      mutt_set_flag (Context, Context->hdrs[i], M_READ, 1);
+      mutt_set_flag (Context, Context->hdrs[i], MUTT_READ, 1);
   }
   return nntp_data;
 }
@@ -1226,7 +1226,7 @@ NNTP_DATA *mutt_newsgroup_uncatchup (NNTP_SERVER *nserv, char *group)
 
     nntp_data->unread = Context->msgcount;
     for (i = 0; i < Context->msgcount; i++)
-      mutt_set_flag (Context, Context->hdrs[i], M_READ, 0);
+      mutt_set_flag (Context, Context->hdrs[i], MUTT_READ, 0);
   }
   else
     nntp_data->unread = nntp_data->lastMessage - nntp_data->newsrc_ent[0].last;
@@ -1245,7 +1245,7 @@ void nntp_buffy (char *buf, size_t len)
     if (!nntp_data || !nntp_data->subscribed || !nntp_data->unread)
       continue;
 
-    if (Context && Context->magic == M_NNTP &&
+    if (Context && Context->magic == MUTT_NNTP &&
 	!mutt_strcmp (nntp_data->group, ((NNTP_DATA *)Context->data)->group))
     {
       unsigned int i, unread = 0;
diff --git a/nntp.c b/nntp.c
index 9ec5ced..8ba02d7 100644
--- a/nntp.c
+++ b/nntp.c
@@ -393,13 +393,13 @@ static int nntp_auth (NNTP_SERVER *nserv)
 	if (!mutt_strncmp ("381", buf, 3))
 	{
 #ifdef DEBUG
-	  if (debuglevel < M_SOCK_LOG_FULL)
-	    dprint (M_SOCK_LOG_CMD, (debugfile,
+	  if (debuglevel < MUTT_SOCK_LOG_FULL)
+	    dprint (MUTT_SOCK_LOG_CMD, (debugfile,
 		    "%d> AUTHINFO PASS *\n", conn->fd));
 #endif
 	  snprintf (buf, sizeof (buf), "AUTHINFO PASS %s\r\n",
 		    conn->account.pass);
-	  if (mutt_socket_write_d (conn, buf, -1, M_SOCK_LOG_FULL) < 0 ||
+	  if (mutt_socket_write_d (conn, buf, -1, MUTT_SOCK_LOG_FULL) < 0 ||
 	      mutt_socket_readln (buf, sizeof (buf), conn) < 0)
 	  break;
 
@@ -457,7 +457,7 @@ static int nntp_auth (NNTP_SERVER *nserv)
 	  if (client_len)
 	  {
 #ifdef DEBUG
-	    if (debuglevel >= M_SOCK_LOG_FULL)
+	    if (debuglevel >= MUTT_SOCK_LOG_FULL)
 	    {
 	      char tmp[LONG_STRING];
 	      memcpy (tmp, client_out, client_len);
@@ -485,33 +485,33 @@ static int nntp_auth (NNTP_SERVER *nserv)
 
 	  safe_strcat (buf, sizeof (buf), "\r\n");
 #ifdef DEBUG
-	  if (debuglevel < M_SOCK_LOG_FULL)
+	  if (debuglevel < MUTT_SOCK_LOG_FULL)
 	  {
 	    if (strchr (buf, ' '))
-	      dprint (M_SOCK_LOG_CMD, (debugfile, "%d> AUTHINFO SASL %s%s\n",
+	      dprint (MUTT_SOCK_LOG_CMD, (debugfile, "%d> AUTHINFO SASL %s%s\n",
 		      conn->fd, method, client_len ? " sasl_data" : ""));
 	    else
-	      dprint (M_SOCK_LOG_CMD, (debugfile, "%d> sasl_data\n", conn->fd));
+	      dprint (MUTT_SOCK_LOG_CMD, (debugfile, "%d> sasl_data\n", conn->fd));
 	  }
 #endif
 	  client_len = 0;
-	  if (mutt_socket_write_d (conn, buf, -1, M_SOCK_LOG_FULL) < 0 ||
-	      mutt_socket_readln_d (inbuf, sizeof (inbuf), conn, M_SOCK_LOG_FULL) < 0)
+	  if (mutt_socket_write_d (conn, buf, -1, MUTT_SOCK_LOG_FULL) < 0 ||
+	      mutt_socket_readln_d (inbuf, sizeof (inbuf), conn, MUTT_SOCK_LOG_FULL) < 0)
 	    break;
 	  if (mutt_strncmp (inbuf, "283 ", 4) &&
 	      mutt_strncmp (inbuf, "383 ", 4))
 	  {
 #ifdef DEBUG
-	    if (debuglevel < M_SOCK_LOG_FULL)
-	      dprint (M_SOCK_LOG_CMD, (debugfile, "%d< %s\n", conn->fd, inbuf));
+	    if (debuglevel < MUTT_SOCK_LOG_FULL)
+	      dprint (MUTT_SOCK_LOG_CMD, (debugfile, "%d< %s\n", conn->fd, inbuf));
 #endif
 	    break;
 	  }
 #ifdef DEBUG
-	  if (debuglevel < M_SOCK_LOG_FULL)
+	  if (debuglevel < MUTT_SOCK_LOG_FULL)
 	  {
 	    inbuf[3] = '\0';
-	    dprint (M_SOCK_LOG_CMD, (debugfile,
+	    dprint (MUTT_SOCK_LOG_CMD, (debugfile,
 		    "%d< %s sasl_data\n", conn->fd, inbuf));
 	  }
 #endif
@@ -526,7 +526,7 @@ static int nntp_auth (NNTP_SERVER *nserv)
 	    break;
 	  }
 #ifdef DEBUG
-	  else if (debuglevel >= M_SOCK_LOG_FULL)
+	  else if (debuglevel >= MUTT_SOCK_LOG_FULL)
 	  {
 	    char tmp[LONG_STRING];
 	    memcpy (tmp, buf, len);
@@ -675,7 +675,7 @@ int nntp_open_connection (NNTP_SERVER *nserv)
     if (nserv->use_tls == 0)
       nserv->use_tls = option (OPTSSLFORCETLS) ||
 			query_quadoption (OPT_SSLSTARTTLS,
-			_("Secure connection with TLS?")) == M_YES ? 2 : 1;
+			_("Secure connection with TLS?")) == MUTT_YES ? 2 : 1;
     if (nserv->use_tls == 2)
     {
       if (mutt_socket_write (conn, "STARTTLS\r\n") < 0 ||
@@ -708,7 +708,7 @@ int nntp_open_connection (NNTP_SERVER *nserv)
 #endif
 
   /* authentication required? */
-  if (conn->account.flags & M_ACCT_USER)
+  if (conn->account.flags & MUTT_ACCT_USER)
   {
     if (!conn->account.user[0])
       auth = 0;
@@ -786,7 +786,7 @@ static int nntp_query (NNTP_DATA *nntp_data, char *line, size_t linelen)
 
       snprintf (buf, sizeof (buf), _("Connection to %s lost. Reconnect?"),
 		nserv->conn->account.host);
-      if (mutt_yesorno (buf, M_YES) != M_YES)
+      if (mutt_yesorno (buf, MUTT_YES) != MUTT_YES)
       {
 	nserv->status = NNTP_BYE;
 	return -1;
@@ -830,7 +830,7 @@ static int nntp_fetch_lines (NNTP_DATA *nntp_data, char *query, size_t qlen,
     progress_t progress;
 
     if (msg)
-      mutt_progress_init (&progress, msg, M_PROGRESS_MSG, ReadInc, -1);
+      mutt_progress_init (&progress, msg, MUTT_PROGRESS_MSG, ReadInc, -1);
 
     strfcpy (buf, query, sizeof (buf));
     if (nntp_query (nntp_data, buf, sizeof (buf)) < 0)
@@ -848,7 +848,7 @@ static int nntp_fetch_lines (NNTP_DATA *nntp_data, char *query, size_t qlen,
     {
       char *p;
       int chunk = mutt_socket_readln_d (buf, sizeof (buf),
-		  nntp_data->nserv->conn, M_SOCK_LOG_HDR);
+		  nntp_data->nserv->conn, MUTT_SOCK_LOG_HDR);
       if (chunk < 0)
       {
 	nntp_data->nserv->status = NNTP_NONE;
@@ -1147,7 +1147,7 @@ static int parse_overview_line (char *line, void *data)
     {
       dprint (2, (debugfile,
 		  "parse_overview_line: mutt_hcache_store %s\n", buf));
-      mutt_hcache_store (fc->hc, buf, hdr, 0, strlen, M_GENERATE_UIDVALIDITY);
+      mutt_hcache_store (fc->hc, buf, hdr, 0, strlen, MUTT_GENERATE_UIDVALIDITY);
     }
   }
 #endif
@@ -1261,7 +1261,7 @@ static int nntp_fetch_headers (CONTEXT *ctx, void *hc,
   /* fetching header from cache or server, or fallback to fetch overview */
   if (!ctx->quiet)
     mutt_progress_init (&fc.progress, _("Fetching message headers..."),
-			M_PROGRESS_MSG, ReadInc, last - first + 1);
+			MUTT_PROGRESS_MSG, ReadInc, last - first + 1);
   for (current = first; current <= last && rc == 0; current++)
   {
     if (!ctx->quiet)
@@ -1462,7 +1462,7 @@ int nntp_open_mailbox (CONTEXT *ctx)
     return -1;
   }
 
-  mutt_bit_unset (ctx->rights, M_ACL_INSERT);
+  mutt_bit_unset (ctx->rights, MUTT_ACL_INSERT);
   if (!nntp_data->newsrc_ent && !nntp_data->subscribed &&
       !option (OPTSAVEUNSUB))
     ctx->readonly = 1;
@@ -1546,8 +1546,8 @@ int nntp_open_mailbox (CONTEXT *ctx)
 #endif
   if (!hc)
   {
-    mutt_bit_unset (ctx->rights, M_ACL_WRITE);
-    mutt_bit_unset (ctx->rights, M_ACL_DELETE);
+    mutt_bit_unset (ctx->rights, MUTT_ACL_WRITE);
+    mutt_bit_unset (ctx->rights, MUTT_ACL_DELETE);
   }
   nntp_newsrc_close (nserv);
   rc = nntp_fetch_headers (ctx, hc, first, nntp_data->lastMessage, 0);
@@ -1691,7 +1691,7 @@ int nntp_post (const char *msg) {
   char buf[LONG_STRING];
   size_t len;
 
-  if (Context && Context->magic == M_NNTP)
+  if (Context && Context->magic == MUTT_NNTP)
     nntp_data = Context->data;
   else
   {
@@ -1733,14 +1733,14 @@ int nntp_post (const char *msg) {
       buf[len] = '\0';
     }
     if (mutt_socket_write_d (nntp_data->nserv->conn,
-	buf[1] == '.' ? buf : buf + 1, -1, M_SOCK_LOG_HDR) < 0)
+	buf[1] == '.' ? buf : buf + 1, -1, MUTT_SOCK_LOG_HDR) < 0)
       return nntp_connect_error (nntp_data->nserv);
   }
   fclose (fp);
 
   if ((buf[strlen (buf) - 1] != '\n' &&
-      mutt_socket_write_d (nntp_data->nserv->conn, "\r\n", -1, M_SOCK_LOG_HDR) < 0) ||
-      mutt_socket_write_d (nntp_data->nserv->conn, ".\r\n", -1, M_SOCK_LOG_HDR) < 0 ||
+      mutt_socket_write_d (nntp_data->nserv->conn, "\r\n", -1, MUTT_SOCK_LOG_HDR) < 0) ||
+      mutt_socket_write_d (nntp_data->nserv->conn, ".\r\n", -1, MUTT_SOCK_LOG_HDR) < 0 ||
       mutt_socket_readln (buf, sizeof (buf), nntp_data->nserv->conn) < 0)
     return nntp_connect_error (nntp_data->nserv);
   if (buf[0] != '2')
@@ -1790,7 +1790,7 @@ int nntp_sync_mailbox (CONTEXT *ctx)
       if (hdr->deleted && !hdr->read)
 	nntp_data->unread--;
       dprint (2, (debugfile, "nntp_sync_mailbox: mutt_hcache_store %s\n", buf));
-      mutt_hcache_store (hc, buf, hdr, 0, strlen, M_GENERATE_UIDVALIDITY);
+      mutt_hcache_store (hc, buf, hdr, 0, strlen, MUTT_GENERATE_UIDVALIDITY);
     }
 #endif
   }
@@ -1953,8 +1953,8 @@ static int nntp_group_poll (NNTP_DATA *nntp_data, int update_stat)
 }
 
 /* Check current newsgroup for new articles:
- *  M_REOPENED	- articles have been renumbered or removed from server
- *  M_NEW_MAIL	- new articles found
+ *  MUTT_REOPENED	- articles have been renumbered or removed from server
+ *  MUTT_NEW_MAIL	- new articles found
  *  0		- no change
  * -1		- lost connection */
 int nntp_check_mailbox (CONTEXT *ctx, int leave_lock)
@@ -1998,7 +1998,7 @@ int nntp_check_mailbox (CONTEXT *ctx, int leave_lock)
 	  NntpContext)
 	nntp_data->lastLoaded = nntp_data->lastMessage - NntpContext;
     }
-    ret = M_REOPENED;
+    ret = MUTT_REOPENED;
   }
 
   /* .newsrc has been externally modified */
@@ -2051,7 +2051,7 @@ int nntp_check_mailbox (CONTEXT *ctx, int leave_lock)
 	  /* header marked as deleted, removing from context */
 	  if (deleted)
 	  {
-	    mutt_set_flag (ctx, ctx->hdrs[i], M_TAG, 0);
+	    mutt_set_flag (ctx, ctx->hdrs[i], MUTT_TAG, 0);
 	    mutt_free_header (&ctx->hdrs[i]);
 	    continue;
 	  }
@@ -2119,11 +2119,11 @@ int nntp_check_mailbox (CONTEXT *ctx, int leave_lock)
 #endif
 
     nserv->newsrc_modified = 0;
-    ret = M_REOPENED;
+    ret = MUTT_REOPENED;
   }
 
   /* some headers were removed, context must be updated */
-  if (ret == M_REOPENED)
+  if (ret == MUTT_REOPENED)
   {
     if (ctx->subj_hash)
       hash_destroy (&ctx->subj_hash, NULL);
@@ -2161,7 +2161,7 @@ int nntp_check_mailbox (CONTEXT *ctx, int leave_lock)
     if (rc >= 0)
       nntp_data->lastLoaded = nntp_data->lastMessage;
     if (ret == 0 && ctx->msgcount > oldmsgcount)
-      ret = M_NEW_MAIL;
+      ret = MUTT_NEW_MAIL;
   }
 
 #ifdef USE_HCACHE
@@ -2208,7 +2208,7 @@ int nntp_check_new_groups (NNTP_SERVER *nserv)
       }
     }
     /* select current newsgroup */
-    if (Context && Context->magic == M_NNTP)
+    if (Context && Context->magic == MUTT_NNTP)
     {
       buf[0] = '\0';
       if (nntp_query ((NNTP_DATA *)Context->data, buf, sizeof (buf)) < 0)
@@ -2223,7 +2223,7 @@ int nntp_check_new_groups (NNTP_SERVER *nserv)
   if (nntp_date (nserv, &now) < 0)
     return -1;
   nntp_data.nserv = nserv;
-  if (Context && Context->magic == M_NNTP)
+  if (Context && Context->magic == MUTT_NNTP)
     nntp_data.group = ((NNTP_DATA *)Context->data)->group;
   else
     nntp_data.group = NULL;
@@ -2257,7 +2257,7 @@ int nntp_check_new_groups (NNTP_SERVER *nserv)
       progress_t progress;
 
       mutt_progress_init (&progress, _("Loading descriptions..."),
-			  M_PROGRESS_MSG, ReadInc, nserv->groups_num - i);
+			  MUTT_PROGRESS_MSG, ReadInc, nserv->groups_num - i);
       for (; i < nserv->groups_num; i++)
       {
 	NNTP_DATA *nntp_data = nserv->groups_list[i];
diff --git a/pager.c b/pager.c
index f66ab04..71e81f9 100644
--- a/pager.c
+++ b/pager.c
@@ -199,14 +199,14 @@ resolve_color (struct line_t *lineInfo, int n, int cnt, int flags, int special,
   }
   else
     m = n;
-  if (!(flags & M_SHOWCOLOR))
+  if (!(flags & MUTT_SHOWCOLOR))
     def_color = ColorDefs[MT_COLOR_NORMAL];
   else if (lineInfo[m].type == MT_COLOR_HEADER)
     def_color = (lineInfo[m].syntax)[0].color;
   else
     def_color = ColorDefs[lineInfo[m].type];
 
-  if ((flags & M_SHOWCOLOR) && lineInfo[m].type == MT_COLOR_QUOTED)
+  if ((flags & MUTT_SHOWCOLOR) && lineInfo[m].type == MT_COLOR_QUOTED)
   {
     struct q_class_t *class = lineInfo[m].quote;
 
@@ -223,7 +223,7 @@ resolve_color (struct line_t *lineInfo, int n, int cnt, int flags, int special,
   }
 
   color = def_color;
-  if (flags & M_SHOWCOLOR)
+  if (flags & MUTT_SHOWCOLOR)
   {
     for (i = 0; i < lineInfo[m].chunks; i++)
     {
@@ -242,7 +242,7 @@ resolve_color (struct line_t *lineInfo, int n, int cnt, int flags, int special,
     }
   }
 
-  if (flags & M_SEARCH)
+  if (flags & MUTT_SEARCH)
   {
     for (i = 0; i < lineInfo[m].search_cnt; i++)
     {
@@ -1040,7 +1040,7 @@ fill_buffer (FILE *f, LOFF_T *last_pos, LOFF_T offset, unsigned char **buf,
   {
     if (offset != *last_pos)
       fseeko (f, offset, 0);
-    if ((*buf = (unsigned char *) mutt_read_line ((char *) *buf, blen, f, &l, M_EOL)) == NULL)
+    if ((*buf = (unsigned char *) mutt_read_line ((char *) *buf, blen, f, &l, MUTT_EOL)) == NULL)
     {
       fmt[0] = 0;
       return (-1);
@@ -1109,7 +1109,7 @@ static int format_line (struct line_t **lineInfo, int n, unsigned char *buf,
   int ch, vch, last_special = -1, special = 0, t;
   wchar_t wc;
   mbstate_t mbstate;
-  int wrap_cols = mutt_window_wrap_cols (pager_window, (flags & M_PAGER_NOWRAP) ? 0 : Wrap);
+  int wrap_cols = mutt_window_wrap_cols (pager_window, (flags & MUTT_PAGER_NOWRAP) ? 0 : Wrap);
 
   if (check_attachment_marker ((char *)buf) == 0)
     wrap_cols = pager_window->cols;
@@ -1211,7 +1211,7 @@ static int format_line (struct line_t **lineInfo, int n, unsigned char *buf,
     }
 
     if (pa &&
-	((flags & (M_SHOWCOLOR | M_SEARCH | M_PAGER_MARKER)) ||
+	((flags & (MUTT_SHOWCOLOR | MUTT_SEARCH | MUTT_PAGER_MARKER)) ||
 	 special || last_special || pa->attr))
     {
       resolve_color (*lineInfo, n, vch, flags, special, pa);
@@ -1284,14 +1284,14 @@ static int format_line (struct line_t **lineInfo, int n, unsigned char *buf,
 
 /*
  * Args:
- *	flags	M_SHOWFLAT, show characters (used for displaying help)
- *		M_SHOWCOLOR, show characters in color
+ *	flags	MUTT_SHOWFLAT, show characters (used for displaying help)
+ *		MUTT_SHOWCOLOR, show characters in color
  *			otherwise don't show characters
- *		M_HIDE, don't show quoted text
- *		M_SEARCH, resolve search patterns
- *		M_TYPES, compute line's type
- *		M_PAGER_NSKIP, keeps leading whitespace
- *		M_PAGER_MARKER, eventually show markers
+ *		MUTT_HIDE, don't show quoted text
+ *		MUTT_SEARCH, resolve search patterns
+ *		MUTT_TYPES, compute line's type
+ *		MUTT_PAGER_NSKIP, keeps leading whitespace
+ *		MUTT_PAGER_MARKER, eventually show markers
  *
  * Return values:
  *	-1	EOF was reached
@@ -1338,7 +1338,7 @@ display_line (FILE *f, LOFF_T *last_pos, struct line_t **lineInfo, int n,
   }
 
   /* only do color hiliting if we are viewing a message */
-  if (flags & (M_SHOWCOLOR | M_TYPES))
+  if (flags & (MUTT_SHOWCOLOR | MUTT_TYPES))
   {
     if ((*lineInfo)[n].type == -1)
     {
@@ -1351,7 +1351,7 @@ display_line (FILE *f, LOFF_T *last_pos, struct line_t **lineInfo, int n,
       }
 
       resolve_types ((char *) fmt, (char *) buf, *lineInfo, n, *last,
-		      QuoteList, q_level, force_redraw, flags & M_SHOWCOLOR);
+		      QuoteList, q_level, force_redraw, flags & MUTT_SHOWCOLOR);
 
       /* avoid race condition for continuation lines when scrolling up */
       for (m = n + 1; m < *last && (*lineInfo)[m].offset && (*lineInfo)[m].continuation; m++)
@@ -1359,17 +1359,17 @@ display_line (FILE *f, LOFF_T *last_pos, struct line_t **lineInfo, int n,
     }
 
     /* this also prevents searching through the hidden lines */
-    if ((flags & M_HIDE) && (*lineInfo)[n].type == MT_COLOR_QUOTED)
-      flags = 0; /* M_NOSHOW */
+    if ((flags & MUTT_HIDE) && (*lineInfo)[n].type == MT_COLOR_QUOTED)
+      flags = 0; /* MUTT_NOSHOW */
   }
 
   /* At this point, (*lineInfo[n]).quote may still be undefined. We 
-   * don't want to compute it every time M_TYPES is set, since this
+   * don't want to compute it every time MUTT_TYPES is set, since this
    * would slow down the "bottom" function unacceptably. A compromise
    * solution is hence to call regexec() again, just to find out the
    * length of the quote prefix.
    */
-  if ((flags & M_SHOWCOLOR) && !(*lineInfo)[n].continuation &&
+  if ((flags & MUTT_SHOWCOLOR) && !(*lineInfo)[n].continuation &&
       (*lineInfo)[n].type == MT_COLOR_QUOTED && (*lineInfo)[n].quote == NULL)
   {
     if (fill_buffer (f, last_pos, (*lineInfo)[n].offset, &buf, &fmt, &buflen, &buf_ready) < 0)
@@ -1385,7 +1385,7 @@ display_line (FILE *f, LOFF_T *last_pos, struct line_t **lineInfo, int n,
 			    force_redraw, q_level);
   }
 
-  if ((flags & M_SEARCH) && !(*lineInfo)[n].continuation && (*lineInfo)[n].search_cnt == -1) 
+  if ((flags & MUTT_SEARCH) && !(*lineInfo)[n].continuation && (*lineInfo)[n].search_cnt == -1) 
   {
     if (fill_buffer (f, last_pos, (*lineInfo)[n].offset, &buf, &fmt, &buflen, &buf_ready) < 0)
     {
@@ -1417,13 +1417,13 @@ display_line (FILE *f, LOFF_T *last_pos, struct line_t **lineInfo, int n,
     }
   }
 
-  if (!(flags & M_SHOW) && (*lineInfo)[n+1].offset > 0)
+  if (!(flags & MUTT_SHOW) && (*lineInfo)[n+1].offset > 0)
   {
     /* we've already scanned this line, so just exit */
     rc = 0;
     goto out;
   }
-  if ((flags & M_SHOWCOLOR) && *force_redraw && (*lineInfo)[n+1].offset > 0)
+  if ((flags & MUTT_SHOWCOLOR) && *force_redraw && (*lineInfo)[n+1].offset > 0)
   {
     /* no need to try to display this line... */
     rc = 1;
@@ -1456,7 +1456,7 @@ display_line (FILE *f, LOFF_T *last_pos, struct line_t **lineInfo, int n,
 	while (ch && (buf[ch] == ' ' || buf[ch] == '\t' || buf[ch] == '\r'))
 	  ch--;
         /* a very long word with leading spaces causes infinite wrapping */
-        if ((!ch) && (flags & M_PAGER_NSKIP))
+        if ((!ch) && (flags & MUTT_PAGER_NSKIP))
           buf_ptr = buf + cnt;
         else
           cnt = ch + 1;
@@ -1464,7 +1464,7 @@ display_line (FILE *f, LOFF_T *last_pos, struct line_t **lineInfo, int n,
       else
 	buf_ptr = buf + cnt; /* a very long word... */
     }
-    if (!(flags & M_PAGER_NSKIP))
+    if (!(flags & MUTT_PAGER_NSKIP))
       /* skip leading blanks on the next line too */
       while (*buf_ptr == ' ' || *buf_ptr == '\t') 
 	buf_ptr++;
@@ -1480,7 +1480,7 @@ display_line (FILE *f, LOFF_T *last_pos, struct line_t **lineInfo, int n,
   (*lineInfo)[n+1].offset = (*lineInfo)[n].offset + (long) (buf_ptr - buf);
 
   /* if we don't need to display the line we are done */
-  if (!(flags & M_SHOW))
+  if (!(flags & MUTT_SHOW))
   {
     rc = 0;
     goto out;
@@ -1500,7 +1500,7 @@ display_line (FILE *f, LOFF_T *last_pos, struct line_t **lineInfo, int n,
 #endif
 
   /* end the last color pattern (needed by S-Lang) */
-  if (special || (col != pager_window->cols && (flags & (M_SHOWCOLOR | M_SEARCH))))
+  if (special || (col != pager_window->cols && (flags & (MUTT_SHOWCOLOR | MUTT_SEARCH))))
     resolve_color (*lineInfo, n, vch, flags, 0, &a);
           
   /*
@@ -1508,7 +1508,7 @@ display_line (FILE *f, LOFF_T *last_pos, struct line_t **lineInfo, int n,
    * ncurses does an implicit clrtoeol() when you do addch('\n') so we have
    * to make sure to reset the color *after* that
    */
-  if (flags & M_SHOWCOLOR)
+  if (flags & MUTT_SHOWCOLOR)
   {
     m = ((*lineInfo)[n].continuation) ? ((*lineInfo)[n].syntax)[0].first : n;
     if ((*lineInfo)[m].type == MT_COLOR_HEADER)
@@ -1527,11 +1527,11 @@ display_line (FILE *f, LOFF_T *last_pos, struct line_t **lineInfo, int n,
    * clrtoeol, otherwise the color for this line will not be
    * filled to the right margin.
    */
-  if (flags & M_SHOWCOLOR)
+  if (flags & MUTT_SHOWCOLOR)
     NORMAL_COLOR;
 
   /* build a return code */
-  if (!(flags & M_SHOW))
+  if (!(flags & MUTT_SHOW))
     flags = 0;
 
   rc = flags;
@@ -1606,7 +1606,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
   struct stat sb;
   regex_t SearchRE;
   int SearchCompiled = 0, SearchFlag = 0, SearchBack = 0;
-  int has_types = (IsHeader(extra) || (flags & M_SHOWCOLOR)) ? M_TYPES : 0; /* main message or rfc822 attachment */
+  int has_types = (IsHeader(extra) || (flags & MUTT_SHOWCOLOR)) ? MUTT_TYPES : 0; /* main message or rfc822 attachment */
 
   mutt_window_t *index_status_window = NULL;
   mutt_window_t *index_window = NULL;
@@ -1623,8 +1623,8 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
   char *followup_to;
 #endif
 
-  if (!(flags & M_SHOWCOLOR))
-    flags |= M_SHOWFLAT;
+  if (!(flags & MUTT_SHOWCOLOR))
+    flags |= MUTT_SHOWFLAT;
 
   if ((fp = fopen (fname, "r")) == NULL)
   {
@@ -1645,7 +1645,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
   if (IsHeader (extra) && !extra->hdr->read)
   {
     Context->msgnotreadyet = extra->hdr->msgno;
-    mutt_set_flag (Context, extra->hdr, M_READ, 1);
+    mutt_set_flag (Context, extra->hdr, MUTT_READ, 1);
   }
 
   lineInfo = safe_malloc (sizeof (struct line_t) * (maxLine = LINES));
@@ -1664,7 +1664,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
     strfcpy (tmphelp, helpstr, sizeof (tmphelp));
     mutt_compile_help (buffer, sizeof (buffer), MENU_PAGER,
 #ifdef USE_NNTP
-	(Context && (Context->magic == M_NNTP)) ? PagerNewsHelpExtra :
+	(Context && (Context->magic == MUTT_NNTP)) ? PagerNewsHelpExtra :
 #endif
 	PagerHelpExtra);
     snprintf (helpstr, sizeof (helpstr), "%s %s", tmphelp, buffer);
@@ -1748,7 +1748,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 	{
 	  REGCOMP
 	    (&SearchRE, searchbuf, REG_NEWLINE | mutt_which_case (searchbuf));
-	  SearchFlag = M_SEARCH;
+	  SearchFlag = MUTT_SEARCH;
 	  SearchBack = Resize->SearchBack;
 	}
 	lines = Resize->line;
@@ -1795,7 +1795,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       i = -1;
       j = -1;
       while (display_line (fp, &last_pos, &lineInfo, ++i, &lastLine, &maxLine,
-	     has_types | SearchFlag | (flags & M_PAGER_NOWRAP), &QuoteList, &q_level, &force_redraw,
+	     has_types | SearchFlag | (flags & MUTT_PAGER_NOWRAP), &QuoteList, &q_level, &force_redraw,
              &SearchRE, pager_window) == 0)
 	if (!lineInfo[i].continuation && ++j == lines)
 	{
@@ -1817,7 +1817,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 	{
 	  if (display_line (fp, &last_pos, &lineInfo, curline, &lastLine, 
 			    &maxLine,
-			    (flags & M_DISPLAYFLAGS) | hideQuoted | SearchFlag | (flags & M_PAGER_NOWRAP),
+			    (flags & MUTT_DISPLAYFLAGS) | hideQuoted | SearchFlag | (flags & MUTT_PAGER_NOWRAP),
 			    &QuoteList, &q_level, &force_redraw, &SearchRE,
                             pager_window) > 0)
 	    lines++;
@@ -1866,7 +1866,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 	size_t l1 = pager_status_window->cols * MB_LEN_MAX;
 	size_t l2 = sizeof (buffer);
 	hfi.hdr = (IsHeader (extra)) ? extra->hdr : extra->bdy->hdr;
-	mutt_make_string_info (buffer, l1 < l2 ? l1 : l2, NONULL (PagerFmt), &hfi, M_FORMAT_MAKEPRINT);
+	mutt_make_string_info (buffer, l1 < l2 ? l1 : l2, NONULL (PagerFmt), &hfi, MUTT_FORMAT_MAKEPRINT);
 	mutt_draw_statusline (pager_status_window->cols, buffer);
       }
       else
@@ -1954,7 +1954,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 	if (!lineInfo[i].continuation)
 	  lines++;
 
-      if (flags & M_PAGER_RETWINCH)
+      if (flags & MUTT_PAGER_RETWINCH)
       {
 	Resize = safe_malloc (sizeof (struct resize));
 
@@ -2010,10 +2010,10 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 	break;
 
       case OP_QUIT:
-	if (query_quadoption (OPT_QUIT, _("Quit Mutt?")) == M_YES)
+	if (query_quadoption (OPT_QUIT, _("Quit Mutt?")) == MUTT_YES)
 	{
 	  /* avoid prompting again in the index menu */
-	  set_quadoption (OPT_QUIT, M_YES);
+	  set_quadoption (OPT_QUIT, MUTT_YES);
 	  ch = -1;
 	}
 	break;
@@ -2158,7 +2158,7 @@ search_next:
 
 	  if (lineInfo[topline].search_cnt > 0)
 	  {
-	    SearchFlag = M_SEARCH;
+	    SearchFlag = MUTT_SEARCH;
 	    /* give some context for search results */
 	    if (topline - searchctx > 0)
 	      topline -= searchctx;
@@ -2174,7 +2174,7 @@ search_next:
 	if (mutt_get_field ((ch == OP_SEARCH || ch == OP_SEARCH_NEXT) ?
 			    _("Search for: ") : _("Reverse search for: "),
 			    buffer, sizeof (buffer),
-			    M_CLEAR) != 0)
+			    MUTT_CLEAR) != 0)
 	  break;
 
 	if (!strcmp (buffer, searchbuf))
@@ -2234,7 +2234,7 @@ search_next:
 	  /* update the search pointers */
 	  i = 0;
 	  while (display_line (fp, &last_pos, &lineInfo, i, &lastLine, 
-				&maxLine, M_SEARCH | (flags & M_PAGER_NSKIP) | (flags & M_PAGER_NOWRAP),
+				&maxLine, MUTT_SEARCH | (flags & MUTT_PAGER_NSKIP) | (flags & MUTT_PAGER_NOWRAP),
 				&QuoteList, &q_level,
                                &force_redraw, &SearchRE, pager_window) == 0)
 	    i++;
@@ -2271,7 +2271,7 @@ search_next:
 	  }
 	  else
 	  {
-	    SearchFlag = M_SEARCH;
+	    SearchFlag = MUTT_SEARCH;
 	    /* give some context for search results */
 	    if (SearchContext > 0 && SearchContext < pager_window->rows)
 	      searchctx = SearchContext;
@@ -2288,7 +2288,7 @@ search_next:
       case OP_SEARCH_TOGGLE:
 	if (SearchCompiled)
 	{
-	  SearchFlag ^= M_SEARCH;
+	  SearchFlag ^= MUTT_SEARCH;
 	  redraw = REDRAW_BODY;
 	}
 	break;
@@ -2309,7 +2309,7 @@ search_next:
       case OP_PAGER_HIDE_QUOTED:
 	if (has_types)
 	{
-	  hideQuoted ^= M_HIDE;
+	  hideQuoted ^= MUTT_HIDE;
 	  if (hideQuoted && lineInfo[topline].type == MT_COLOR_QUOTED)
 	    topline = upNLines (1, lineInfo, topline, hideQuoted);
 	  else
@@ -2325,7 +2325,7 @@ search_next:
 
 	  while (((new_topline + SkipQuotedOffset) < lastLine ||
 		  (0 == (dretval = display_line (fp, &last_pos, &lineInfo,
-			 new_topline, &lastLine, &maxLine, M_TYPES | (flags & M_PAGER_NOWRAP),
+			 new_topline, &lastLine, &maxLine, MUTT_TYPES | (flags & MUTT_PAGER_NOWRAP),
                          &QuoteList, &q_level, &force_redraw, &SearchRE, pager_window))))
 		 && lineInfo[new_topline].type != MT_COLOR_QUOTED)
 	    new_topline++;
@@ -2338,7 +2338,7 @@ search_next:
 
 	  while (((new_topline + SkipQuotedOffset) < lastLine ||
 		  (0 == (dretval = display_line (fp, &last_pos, &lineInfo,
-			 new_topline, &lastLine, &maxLine, M_TYPES | (flags & M_PAGER_NOWRAP),
+			 new_topline, &lastLine, &maxLine, MUTT_TYPES | (flags & MUTT_PAGER_NOWRAP),
                          &QuoteList, &q_level, &force_redraw, &SearchRE, pager_window))))
 		 && lineInfo[new_topline].type == MT_COLOR_QUOTED)
 	    new_topline++;
@@ -2358,7 +2358,7 @@ search_next:
 	  i = curline;
 	  /* make sure the types are defined to the end of file */
 	  while (display_line (fp, &last_pos, &lineInfo, i, &lastLine, 
-				&maxLine, has_types | (flags & M_PAGER_NOWRAP),
+				&maxLine, has_types | (flags & MUTT_PAGER_NOWRAP),
 				&QuoteList, &q_level, &force_redraw,
                                &SearchRE, pager_window) == 0)
 	    i++;
@@ -2430,13 +2430,13 @@ search_next:
 	CHECK_MODE(IsHeader (extra));
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_DELETE, _("Cannot delete message"));
+	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot delete message"));
 
-	mutt_set_flag (Context, extra->hdr, M_DELETE, 1);
-	mutt_set_flag (Context, extra->hdr, M_PURGED,
+	mutt_set_flag (Context, extra->hdr, MUTT_DELETE, 1);
+	mutt_set_flag (Context, extra->hdr, MUTT_PURGED,
 		       ch != OP_PURGE_MESSAGE ? 0 : 1);
         if (option (OPTDELETEUNTAG))
-	  mutt_set_flag (Context, extra->hdr, M_TAG, 0);
+	  mutt_set_flag (Context, extra->hdr, MUTT_TAG, 0);
 	redraw = REDRAW_STATUS | REDRAW_INDEX;
 	if (option (OPTRESOLVE))
 	{
@@ -2464,15 +2464,15 @@ search_next:
 	CHECK_MODE(IsHeader (extra));
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_DELETE, _("Cannot delete message(s)"));
+	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot delete message(s)"));
 
-	r = mutt_thread_set_flag (extra->hdr, M_DELETE, 1,
+	r = mutt_thread_set_flag (extra->hdr, MUTT_DELETE, 1,
 				  ch == OP_DELETE_THREAD ? 0 : 1);
 
 	if (r != -1)
 	{
 	  if (option (OPTDELETEUNTAG))
-	    mutt_thread_set_flag (extra->hdr, M_TAG, 0,
+	    mutt_thread_set_flag (extra->hdr, MUTT_TAG, 0,
 				  ch == OP_DELETE_THREAD ? 0 : 1);
 	  if (option (OPTRESOLVE))
 	  {
@@ -2520,7 +2520,7 @@ search_next:
 	if (option (OPTWRAP) != old_smart_wrap || 
 	    option (OPTMARKERS) != old_markers)
 	{
-	  if (flags & M_PAGER_RETWINCH)
+	  if (flags & MUTT_PAGER_RETWINCH)
 	  {
 	    ch = -1;
 	    rc = OP_REFORMAT_WINCH;
@@ -2562,7 +2562,7 @@ search_next:
 	  lastLine = 0;
 	  while (j > 0 && display_line (fp, &last_pos, &lineInfo, topline, 
 					&lastLine, &maxLine,
-					(has_types ? M_TYPES : 0) | (flags & M_PAGER_NOWRAP),
+					(has_types ? MUTT_TYPES : 0) | (flags & MUTT_PAGER_NOWRAP),
 					&QuoteList, &q_level, &force_redraw,
 					&SearchRE, pager_window) == 0)
 	  {
@@ -2589,9 +2589,9 @@ search_next:
 	CHECK_MODE(IsHeader (extra));
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_WRITE, "Cannot flag message");
+	CHECK_ACL(MUTT_ACL_WRITE, "Cannot flag message");
 
-	mutt_set_flag (Context, extra->hdr, M_FLAG, !extra->hdr->flagged);
+	mutt_set_flag (Context, extra->hdr, MUTT_FLAG, !extra->hdr->flagged);
 	redraw = REDRAW_STATUS | REDRAW_INDEX;
 	if (option (OPTRESOLVE))
 	{
@@ -2628,9 +2628,9 @@ search_next:
       case OP_POST:
 	CHECK_MODE(IsHeader (extra) && !IsAttach (extra));
 	CHECK_ATTACH;
-	if (extra->ctx && extra->ctx->magic == M_NNTP &&
+	if (extra->ctx && extra->ctx->magic == MUTT_NNTP &&
 	    !((NNTP_DATA *)extra->ctx->data)->allowed &&
-	    query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != M_YES)
+	    query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != MUTT_YES)
 	  break;
 	ci_send_message (SENDNEWS, NULL, NULL, extra->ctx, NULL);
 	redraw = REDRAW_FULL;
@@ -2639,9 +2639,9 @@ search_next:
       case OP_FORWARD_TO_GROUP:
 	CHECK_MODE(IsHeader (extra) || IsMsgAttach (extra));
 	CHECK_ATTACH;
-	if (extra->ctx && extra->ctx->magic == M_NNTP &&
+	if (extra->ctx && extra->ctx->magic == MUTT_NNTP &&
 	    !((NNTP_DATA *)extra->ctx->data)->allowed &&
-	    query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != M_YES)
+	    query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != MUTT_YES)
 	  break;
 	if (IsMsgAttach (extra))
 	  mutt_attach_forward (extra->fp, extra->hdr, extra->idx,
@@ -2661,11 +2661,11 @@ search_next:
 	  followup_to = extra->hdr->env->followup_to;
 
 	if (!followup_to || mutt_strcasecmp (followup_to, "poster") ||
-	    query_quadoption (OPT_FOLLOWUPTOPOSTER,_("Reply by mail as poster prefers?")) != M_YES)
+	    query_quadoption (OPT_FOLLOWUPTOPOSTER,_("Reply by mail as poster prefers?")) != MUTT_YES)
 	{
-	  if (extra->ctx && extra->ctx->magic == M_NNTP &&
+	  if (extra->ctx && extra->ctx->magic == MUTT_NNTP &&
 	      !((NNTP_DATA *)extra->ctx->data)->allowed &&
-	      query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != M_YES)
+	      query_quadoption (OPT_TOMODERATED,_("Posting to this group not allowed, may be moderated. Continue?")) != MUTT_YES)
 	    break;
 	  if (IsMsgAttach (extra))
 	    mutt_attach_reply (extra->fp, extra->hdr, extra->idx,
@@ -2782,7 +2782,7 @@ search_next:
 
       case OP_TAG:
 	CHECK_MODE(IsHeader (extra));
-	mutt_set_flag (Context, extra->hdr, M_TAG, !extra->hdr->tagged);
+	mutt_set_flag (Context, extra->hdr, MUTT_TAG, !extra->hdr->tagged);
 
 	Context->last_tag = extra->hdr->tagged ? extra->hdr :
 	  ((Context->last_tag == extra->hdr && !extra->hdr->tagged)
@@ -2800,12 +2800,12 @@ search_next:
 	CHECK_MODE(IsHeader (extra));
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_SEEN, _("Cannot toggle new"));
+	CHECK_ACL(MUTT_ACL_SEEN, _("Cannot toggle new"));
 
 	if (extra->hdr->read || extra->hdr->old)
-	  mutt_set_flag (Context, extra->hdr, M_NEW, 1);
+	  mutt_set_flag (Context, extra->hdr, MUTT_NEW, 1);
 	else if (!first)
-	  mutt_set_flag (Context, extra->hdr, M_READ, 1);
+	  mutt_set_flag (Context, extra->hdr, MUTT_READ, 1);
 	first = 0;
         Context->msgnotreadyet = -1;
 	redraw = REDRAW_STATUS | REDRAW_INDEX;
@@ -2820,10 +2820,10 @@ search_next:
 	CHECK_MODE(IsHeader (extra));
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_DELETE, _("Cannot undelete message"));
+	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot undelete message"));
 
-	mutt_set_flag (Context, extra->hdr, M_DELETE, 0);
-	mutt_set_flag (Context, extra->hdr, M_PURGED, 0);
+	mutt_set_flag (Context, extra->hdr, MUTT_DELETE, 0);
+	mutt_set_flag (Context, extra->hdr, MUTT_PURGED, 0);
 	redraw = REDRAW_STATUS | REDRAW_INDEX;
 	if (option (OPTRESOLVE))
 	{
@@ -2837,11 +2837,11 @@ search_next:
 	CHECK_MODE(IsHeader (extra));
 	CHECK_READONLY;
         /* L10N: CHECK_ACL */
-	CHECK_ACL(M_ACL_DELETE, _("Cannot undelete message(s)"));
+	CHECK_ACL(MUTT_ACL_DELETE, _("Cannot undelete message(s)"));
 
-	r = mutt_thread_set_flag (extra->hdr, M_DELETE, 0,
+	r = mutt_thread_set_flag (extra->hdr, MUTT_DELETE, 0,
 				  ch == OP_UNDELETE_THREAD ? 0 : 1)
-	  + mutt_thread_set_flag (extra->hdr, M_PURGED, 0,
+	  + mutt_thread_set_flag (extra->hdr, MUTT_PURGED, 0,
 				  ch == OP_UNDELETE_THREAD ? 0 : 1);
 
 	if (r > -1)
@@ -2869,7 +2869,7 @@ search_next:
 	break;
 
       case OP_VIEW_ATTACHMENTS:
-        if (flags & M_PAGER_ATTACHMENT)
+        if (flags & MUTT_PAGER_ATTACHMENT)
         {
 	  ch = -1;
 	  rc = OP_ATTACH_COLLAPSE;
diff --git a/pager.h b/pager.h
index baa1ad4..b73e040 100644
--- a/pager.h
+++ b/pager.h
@@ -19,22 +19,22 @@
 #include "attach.h"
 
 /* dynamic internal flags */
-#define M_SHOWFLAT	(1<<0)
-#define M_SHOWCOLOR	(1<<1)
-#define M_HIDE		(1<<2)
-#define M_SEARCH	(1<<3)
-#define M_TYPES		(1<<4)
-#define M_SHOW		(M_SHOWCOLOR | M_SHOWFLAT)
+#define MUTT_SHOWFLAT	(1<<0)
+#define MUTT_SHOWCOLOR	(1<<1)
+#define MUTT_HIDE		(1<<2)
+#define MUTT_SEARCH	(1<<3)
+#define MUTT_TYPES		(1<<4)
+#define MUTT_SHOW		(MUTT_SHOWCOLOR | MUTT_SHOWFLAT)
 
 /* exported flags for mutt_(do_)?pager */
-#define M_PAGER_NSKIP		(1<<5)	/* preserve whitespace with smartwrap */
-#define M_PAGER_MARKER		(1<<6)	/* use markers if option is set */
-#define M_PAGER_RETWINCH	(1<<7)	/* need reformatting on SIGWINCH */
-#define M_PAGER_MESSAGE		(M_SHOWCOLOR | M_PAGER_MARKER)
-#define M_PAGER_ATTACHMENT	(1<<8)
-#define M_PAGER_NOWRAP		(1<<9)	/* format for term width, ignore $wrap */
+#define MUTT_PAGER_NSKIP		(1<<5)	/* preserve whitespace with smartwrap */
+#define MUTT_PAGER_MARKER		(1<<6)	/* use markers if option is set */
+#define MUTT_PAGER_RETWINCH	(1<<7)	/* need reformatting on SIGWINCH */
+#define MUTT_PAGER_MESSAGE		(MUTT_SHOWCOLOR | MUTT_PAGER_MARKER)
+#define MUTT_PAGER_ATTACHMENT	(1<<8)
+#define MUTT_PAGER_NOWRAP		(1<<9)	/* format for term width, ignore $wrap */
 
-#define M_DISPLAYFLAGS	(M_SHOW | M_PAGER_NSKIP | M_PAGER_MARKER)
+#define MUTT_DISPLAYFLAGS	(MUTT_SHOW | MUTT_PAGER_NSKIP | MUTT_PAGER_MARKER)
 
 typedef struct
 {
diff --git a/parse.c b/parse.c
index 1850da2..b554d5e 100644
--- a/parse.c
+++ b/parse.c
@@ -1103,7 +1103,7 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
     case 'k':
     if (!ascii_strcasecmp (line+1, "eywords"))
     {
-      kwtype = M_KEYWORDS;
+      kwtype = MUTT_KEYWORDS;
     }
     break;
 
@@ -1307,15 +1307,15 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
     }
     else if (ascii_strcasecmp (line+1, "-label") == 0)
     {
-      kwtype = M_X_LABEL;
+      kwtype = MUTT_X_LABEL;
     }
     else if (!ascii_strcasecmp (line+1, "-keywords"))
     {
-      kwtype = M_X_KEYWORDS;
+      kwtype = MUTT_X_KEYWORDS;
     }
     else if (!ascii_strcasecmp (line+1, "-mozilla-keys"))
     {
-      kwtype = M_X_MOZILLA_KEYS;
+      kwtype = MUTT_X_MOZILLA_KEYS;
     }
 
 #ifdef USE_NNTP
@@ -1365,9 +1365,9 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
     char *text = strdup(p);
     char *sep;
 
-    if (kwtype == M_KEYWORDS)
+    if (kwtype == MUTT_KEYWORDS)
       sep = ",";
-    else if (kwtype == M_X_LABEL)
+    else if (kwtype == MUTT_X_LABEL)
       sep = XlabelDelim;
     else
       sep = " ";
@@ -1664,7 +1664,7 @@ static int count_body_parts (BODY *body, int flags)
 	shallrecurse = 0;
 
       /* Don't count containers if they're top-level. */
-      if (flags & M_PARTS_TOPLEVEL)
+      if (flags & MUTT_PARTS_TOPLEVEL)
 	AT_NOCOUNT("top-level message/*");
     }
     else if (bp->type == TYPEMULTIPART)
@@ -1675,7 +1675,7 @@ static int count_body_parts (BODY *body, int flags)
         shallrecurse = 0;
 
       /* Don't count containers if they're top-level. */
-      if (flags & M_PARTS_TOPLEVEL)
+      if (flags & MUTT_PARTS_TOPLEVEL)
 	AT_NOCOUNT("top-level multipart");
     }
 
@@ -1718,7 +1718,7 @@ static int count_body_parts (BODY *body, int flags)
     if (shallrecurse)
     {
       dprint(5, (debugfile, "cbp: %p pre count = %d\n", (void *)bp, count));
-      bp->attach_count = count_body_parts(bp->parts, flags & ~M_PARTS_TOPLEVEL);
+      bp->attach_count = count_body_parts(bp->parts, flags & ~MUTT_PARTS_TOPLEVEL);
       count += bp->attach_count;
       dprint(5, (debugfile, "cbp: %p post count = %d\n", (void *)bp, count));
     }
@@ -1741,7 +1741,7 @@ int mutt_count_body_parts (CONTEXT *ctx, HEADER *hdr)
     mutt_parse_mime_message (ctx, hdr);
   
   if (AttachAllow || AttachExclude || InlineAllow || InlineExclude)
-    hdr->attach_total = count_body_parts(hdr->content, M_PARTS_TOPLEVEL);
+    hdr->attach_total = count_body_parts(hdr->content, MUTT_PARTS_TOPLEVEL);
   else
     hdr->attach_total = 0;
 
diff --git a/pattern.c b/pattern.c
index 8dc7fb4..82d820f 100644
--- a/pattern.c
+++ b/pattern.c
@@ -60,54 +60,54 @@ static const struct pattern_flags
 }
 Flags[] =
 {
-  { 'A', M_ALL,			0,		NULL },
-  { 'b', M_BODY,		M_FULL_MSG,	eat_regexp },
-  { 'B', M_WHOLE_MSG,		M_FULL_MSG,	eat_regexp },
-  { 'c', M_CC,			0,		eat_regexp },
-  { 'C', M_RECIPIENT,		0,		eat_regexp },
-  { 'd', M_DATE,		0,		eat_date },
-  { 'D', M_DELETED,		0,		NULL },
-  { 'e', M_SENDER,		0,		eat_regexp },
-  { 'E', M_EXPIRED,		0,		NULL },
-  { 'f', M_FROM,		0,		eat_regexp },
-  { 'F', M_FLAG,		0,		NULL },
-  { 'g', M_CRYPT_SIGN,		0,		NULL },
-  { 'G', M_CRYPT_ENCRYPT,	0,		NULL },
-  { 'h', M_HEADER,		M_FULL_MSG,	eat_regexp },
-  { 'H', M_HORMEL,		0,		eat_regexp },
-  { 'i', M_ID,			0,		eat_regexp },
-  { 'k', M_PGP_KEY,		0,		NULL },
-  { 'l', M_LIST,		0,		NULL },
-  { 'L', M_ADDRESS,		0,		eat_regexp },
-  { 'm', M_MESSAGE,		0,		eat_range },
-  { 'n', M_SCORE,		0,		eat_range },
-  { 'N', M_NEW,			0,		NULL },
-  { 'O', M_OLD,			0,		NULL },
-  { 'p', M_PERSONAL_RECIP,	0,		NULL },
-  { 'P', M_PERSONAL_FROM,	0,		NULL },
-  { 'Q', M_REPLIED,		0,		NULL },
-  { 'r', M_DATE_RECEIVED,	0,		eat_date },
-  { 'R', M_READ,		0,		NULL },
-  { 's', M_SUBJECT,		0,		eat_regexp },
-  { 'S', M_SUPERSEDED,		0,		NULL },
-  { 't', M_TO,			0,		eat_regexp },
-  { 'T', M_TAG,			0,		NULL },
-  { 'u', M_SUBSCRIBED_LIST,	0,		NULL },
-  { 'U', M_UNREAD,		0,		NULL },
-  { 'v', M_COLLAPSED,		0,		NULL },
-  { 'V', M_CRYPT_VERIFIED,	0,		NULL },
+  { 'A', MUTT_ALL,			0,		NULL },
+  { 'b', MUTT_BODY,		MUTT_FULL_MSG,	eat_regexp },
+  { 'B', MUTT_WHOLE_MSG,		MUTT_FULL_MSG,	eat_regexp },
+  { 'c', MUTT_CC,			0,		eat_regexp },
+  { 'C', MUTT_RECIPIENT,		0,		eat_regexp },
+  { 'd', MUTT_DATE,		0,		eat_date },
+  { 'D', MUTT_DELETED,		0,		NULL },
+  { 'e', MUTT_SENDER,		0,		eat_regexp },
+  { 'E', MUTT_EXPIRED,		0,		NULL },
+  { 'f', MUTT_FROM,		0,		eat_regexp },
+  { 'F', MUTT_FLAG,		0,		NULL },
+  { 'g', MUTT_CRYPT_SIGN,		0,		NULL },
+  { 'G', MUTT_CRYPT_ENCRYPT,	0,		NULL },
+  { 'h', MUTT_HEADER,		MUTT_FULL_MSG,	eat_regexp },
+  { 'H', MUTT_HORMEL,		0,		eat_regexp },
+  { 'i', MUTT_ID,			0,		eat_regexp },
+  { 'k', MUTT_PGP_KEY,		0,		NULL },
+  { 'l', MUTT_LIST,		0,		NULL },
+  { 'L', MUTT_ADDRESS,		0,		eat_regexp },
+  { 'm', MUTT_MESSAGE,		0,		eat_range },
+  { 'n', MUTT_SCORE,		0,		eat_range },
+  { 'N', MUTT_NEW,			0,		NULL },
+  { 'O', MUTT_OLD,			0,		NULL },
+  { 'p', MUTT_PERSONAL_RECIP,	0,		NULL },
+  { 'P', MUTT_PERSONAL_FROM,	0,		NULL },
+  { 'Q', MUTT_REPLIED,		0,		NULL },
+  { 'r', MUTT_DATE_RECEIVED,	0,		eat_date },
+  { 'R', MUTT_READ,		0,		NULL },
+  { 's', MUTT_SUBJECT,		0,		eat_regexp },
+  { 'S', MUTT_SUPERSEDED,		0,		NULL },
+  { 't', MUTT_TO,			0,		eat_regexp },
+  { 'T', MUTT_TAG,			0,		NULL },
+  { 'u', MUTT_SUBSCRIBED_LIST,	0,		NULL },
+  { 'U', MUTT_UNREAD,		0,		NULL },
+  { 'v', MUTT_COLLAPSED,		0,		NULL },
+  { 'V', MUTT_CRYPT_VERIFIED,	0,		NULL },
 #ifdef USE_NNTP
-  { 'w', M_NEWSGROUPS,		0,		eat_regexp },
+  { 'w', MUTT_NEWSGROUPS,		0,		eat_regexp },
 #endif
-  { 'x', M_REFERENCE,		0,		eat_regexp },
-  { 'X', M_MIMEATTACH,		0,		eat_range },
-  { 'y', M_XLABEL,		0,		eat_regexp },
+  { 'x', MUTT_REFERENCE,		0,		eat_regexp },
+  { 'X', MUTT_MIMEATTACH,		0,		eat_range },
+  { 'y', MUTT_XLABEL,		0,		eat_regexp },
 #ifdef USE_NOTMUCH
-  { 'Y', M_NOTMUCH_LABEL,	0,		eat_regexp },
+  { 'Y', MUTT_NOTMUCH_LABEL,	0,		eat_regexp },
 #endif
-  { 'z', M_SIZE,		0,		eat_range },
-  { '=', M_DUPLICATED,		0,		NULL },
-  { '$', M_UNREFERENCED,	0,		NULL },
+  { 'z', MUTT_SIZE,		0,		eat_range },
+  { '=', MUTT_DUPLICATED,		0,		NULL },
+  { '$', MUTT_UNREFERENCED,	0,		NULL },
   { 0,   0,			0,		NULL }
 };
 
@@ -116,17 +116,17 @@ static char LastSearch[STRING] = { 0 };	/* last pattern searched for */
 static char LastSearchExpn[LONG_STRING] = { 0 }; /* expanded version of
 						    LastSearch */
 
-#define M_MAXRANGE -1
+#define MUTT_MAXRANGE -1
 
 /* constants for parse_date_range() */
-#define M_PDR_NONE	0x0000
-#define M_PDR_MINUS	0x0001
-#define M_PDR_PLUS	0x0002
-#define M_PDR_WINDOW	0x0004
-#define M_PDR_ABSOLUTE	0x0008
-#define M_PDR_DONE	0x0010
-#define M_PDR_ERROR	0x0100
-#define M_PDR_ERRORDONE	(M_PDR_ERROR | M_PDR_DONE)
+#define MUTT_PDR_NONE	0x0000
+#define MUTT_PDR_MINUS	0x0001
+#define MUTT_PDR_PLUS	0x0002
+#define MUTT_PDR_WINDOW	0x0004
+#define MUTT_PDR_ABSOLUTE	0x0008
+#define MUTT_PDR_DONE	0x0010
+#define MUTT_PDR_ERROR	0x0100
+#define MUTT_PDR_ERRORDONE	(MUTT_PDR_ERROR | MUTT_PDR_DONE)
 
 
 /* if no uppercase letters are given, do a case-insensitive search */
@@ -177,7 +177,7 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
       /* decode the header / body */
       memset (&s, 0, sizeof (s));
       s.fpin = msg->fp;
-      s.flags = M_CHARCONV;
+      s.flags = MUTT_CHARCONV;
 #ifdef HAVE_FMEMOPEN
       s.fpout = open_memstream (&temp, &tempsize);
       if (!s.fpout) {
@@ -193,10 +193,10 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
       }
 #endif
 
-      if (pat->op != M_BODY)
+      if (pat->op != MUTT_BODY)
 	mutt_copy_header (msg->fp, h, s.fpout, CH_FROM | CH_DECODE, NULL);
 
-      if (pat->op != M_HEADER)
+      if (pat->op != MUTT_HEADER)
       {
 	mutt_parse_mime_message (ctx, h);
 
@@ -249,14 +249,14 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
     {
       /* raw header / body */
       fp = msg->fp;
-      if (pat->op != M_BODY)
+      if (pat->op != MUTT_BODY)
       {
 	fseeko (fp, h->offset, 0);
 	lng = h->content->offset - h->offset;
       }
-      if (pat->op != M_HEADER)
+      if (pat->op != MUTT_HEADER)
       {
-	if (pat->op == M_BODY)
+	if (pat->op == MUTT_BODY)
 	  fseeko (fp, h->content->offset, 0);
 	lng += h->content->length;
       }
@@ -268,7 +268,7 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
     /* search the file "fp" */
     while (lng > 0)
     {
-      if (pat->op == M_HEADER)
+      if (pat->op == MUTT_HEADER)
       {
 	if (*(buf = mutt_read_rfc822_line (fp, buf, &blen)) == '\0')
 	  break;
@@ -311,7 +311,7 @@ static int eat_regexp (pattern_t *pat, BUFFER *s, BUFFER *err)
 
   mutt_buffer_init (&buf);
   pexpr = s->dptr;
-  if (mutt_extract_token (&buf, s, M_TOKEN_PATTERN | M_TOKEN_COMMENT) != 0 ||
+  if (mutt_extract_token (&buf, s, MUTT_TOKEN_PATTERN | MUTT_TOKEN_COMMENT) != 0 ||
       !buf.data)
   {
     snprintf (err->data, err->dsize, _("Error in expression: %s"), pexpr);
@@ -380,7 +380,7 @@ int eat_range (pattern_t *pat, BUFFER *s, BUFFER *err)
     /* range minimum */
     if (*s->dptr == '>')
     {
-      pat->max = M_MAXRANGE;
+      pat->max = MUTT_MAXRANGE;
       pat->min = strtol (s->dptr + 1, &tmp, 0) + 1; /* exclusive range */
     }
     else
@@ -433,7 +433,7 @@ int eat_range (pattern_t *pat, BUFFER *s, BUFFER *err)
       (pat->max)--;
   }
   else
-    pat->max = M_MAXRANGE;
+    pat->max = MUTT_MAXRANGE;
 
   if (skip_quote && *tmp == '"')
     tmp++;
@@ -545,8 +545,8 @@ static void adjust_date_range (struct tm *min, struct tm *max)
 static const char * parse_date_range (const char* pc, struct tm *min,
     struct tm *max, int haveMin, struct tm *baseMin, BUFFER *err)
 {
-  int flag = M_PDR_NONE;	
-  while (*pc && ((flag & M_PDR_DONE) == 0))
+  int flag = MUTT_PDR_NONE;	
+  while (*pc && ((flag & MUTT_PDR_DONE) == 0))
   {
     const char *pt;
     char ch = *pc++;
@@ -559,31 +559,31 @@ static const char * parse_date_range (const char* pc, struct tm *min,
 	pt = get_offset (min, pc, -1);
 	if (pc == pt)
 	{
-	  if (flag == M_PDR_NONE)
+	  if (flag == MUTT_PDR_NONE)
 	  { /* nothing yet and no offset parsed => absolute date? */
 	    if (!getDate (pc, max, err))
-	      flag |= (M_PDR_ABSOLUTE | M_PDR_ERRORDONE);  /* done bad */
+	      flag |= (MUTT_PDR_ABSOLUTE | MUTT_PDR_ERRORDONE);  /* done bad */
 	    else
 	    {
 	      /* reestablish initial base minimum if not specified */
 	      if (!haveMin)
 		memcpy (min, baseMin, sizeof(struct tm));
-	      flag |= (M_PDR_ABSOLUTE | M_PDR_DONE);  /* done good */
+	      flag |= (MUTT_PDR_ABSOLUTE | MUTT_PDR_DONE);  /* done good */
 	    }
 	  }
 	  else
-	    flag |= M_PDR_ERRORDONE;
+	    flag |= MUTT_PDR_ERRORDONE;
 	}
 	else
 	{
 	  pc = pt;
-	  if (flag == M_PDR_NONE && !haveMin)
+	  if (flag == MUTT_PDR_NONE && !haveMin)
 	  { /* the very first "-3d" without a previous absolute date */
 	    max->tm_year = min->tm_year;
 	    max->tm_mon = min->tm_mon;
 	    max->tm_mday = min->tm_mday;
 	  }
-	  flag |= M_PDR_MINUS;
+	  flag |= MUTT_PDR_MINUS;
 	}
       }
       break;
@@ -591,11 +591,11 @@ static const char * parse_date_range (const char* pc, struct tm *min,
       { /* enlarge plusRange */
 	pt = get_offset (max, pc, 1);
 	if (pc == pt)
-	  flag |= M_PDR_ERRORDONE;
+	  flag |= MUTT_PDR_ERRORDONE;
 	else
 	{
 	  pc = pt;
-	  flag |= M_PDR_PLUS;
+	  flag |= MUTT_PDR_PLUS;
 	}
       }
       break;
@@ -603,24 +603,24 @@ static const char * parse_date_range (const char* pc, struct tm *min,
       { /* enlarge window in both directions */
 	pt = get_offset (min, pc, -1);
 	if (pc == pt)
-	  flag |= M_PDR_ERRORDONE;
+	  flag |= MUTT_PDR_ERRORDONE;
 	else
 	{
 	  pc = get_offset (max, pc, 1);
-	  flag |= M_PDR_WINDOW;
+	  flag |= MUTT_PDR_WINDOW;
 	}
       }
       break;
       default:
-	flag |= M_PDR_ERRORDONE;
+	flag |= MUTT_PDR_ERRORDONE;
     }
     SKIPWS (pc);
   }
-  if ((flag & M_PDR_ERROR) && !(flag & M_PDR_ABSOLUTE))
+  if ((flag & MUTT_PDR_ERROR) && !(flag & MUTT_PDR_ABSOLUTE))
   { /* getDate has its own error message, don't overwrite it here */
     snprintf (err->data, err->dsize, _("Invalid relative date: %s"), pc-1);
   }
-  return ((flag & M_PDR_ERROR) ? NULL : pc);
+  return ((flag & MUTT_PDR_ERROR) ? NULL : pc);
 }
 
 static int eat_date (pattern_t *pat, BUFFER *s, BUFFER *err)
@@ -631,7 +631,7 @@ static int eat_date (pattern_t *pat, BUFFER *s, BUFFER *err)
 
   mutt_buffer_init (&buffer);
   pexpr = s->dptr;
-  if (mutt_extract_token (&buffer, s, M_TOKEN_COMMENT | M_TOKEN_PATTERN) != 0
+  if (mutt_extract_token (&buffer, s, MUTT_TOKEN_COMMENT | MUTT_TOKEN_PATTERN) != 0
       || !buffer.data)
   {
     snprintf (err->data, err->dsize, _("Error in expression: %s"), pexpr);
@@ -868,7 +868,7 @@ pattern_t *mutt_pattern_comp (/* const */ char *s, int flags, BUFFER *err)
 	  {
 	    /* A & B | C == (A & B) | C */
 	    tmp = new_pattern ();
-	    tmp->op = M_AND;
+	    tmp->op = MUTT_AND;
 	    tmp->child = curlist;
 
 	    curlist = tmp;
@@ -902,7 +902,7 @@ pattern_t *mutt_pattern_comp (/* const */ char *s, int flags, BUFFER *err)
 	    return NULL;
 	  }
 	  tmp = new_pattern ();
-	  tmp->op = M_THREAD;
+	  tmp->op = MUTT_THREAD;
 	  if (last)
 	    last->next = tmp;
 	  else
@@ -929,7 +929,7 @@ pattern_t *mutt_pattern_comp (/* const */ char *s, int flags, BUFFER *err)
 	{
 	  /* A | B & C == (A | B) & C */
 	  tmp = new_pattern ();
-	  tmp->op = M_OR;
+	  tmp->op = MUTT_OR;
 	  tmp->child = curlist;
 	  curlist = tmp;
 	  last = tmp;
@@ -1026,7 +1026,7 @@ pattern_t *mutt_pattern_comp (/* const */ char *s, int flags, BUFFER *err)
   if (curlist->next)
   {
     tmp = new_pattern ();
-    tmp->op = or ? M_OR : M_AND;
+    tmp->op = or ? MUTT_OR : MUTT_AND;
     tmp->child = curlist;
     curlist = tmp;
   }
@@ -1146,50 +1146,50 @@ static int match_threadcomplete(struct pattern_t *pat, pattern_exec_flag flags,
 }
 
 /* flags
-   	M_MATCH_FULL_ADDRESS	match both personal and machine address */
+   	MUTT_MATCH_FULL_ADDRESS	match both personal and machine address */
 int
 mutt_pattern_exec (struct pattern_t *pat, pattern_exec_flag flags, CONTEXT *ctx, HEADER *h)
 {
   switch (pat->op)
   {
-    case M_AND:
+    case MUTT_AND:
       return (pat->not ^ (perform_and (pat->child, flags, ctx, h) > 0));
-    case M_OR:
+    case MUTT_OR:
       return (pat->not ^ (perform_or (pat->child, flags, ctx, h) > 0));
-    case M_THREAD:
+    case MUTT_THREAD:
       return (pat->not ^ match_threadcomplete(pat->child, flags, ctx, h->thread, 1, 1, 1, 1));
-    case M_ALL:
+    case MUTT_ALL:
       return (!pat->not);
-    case M_EXPIRED:
+    case MUTT_EXPIRED:
       return (pat->not ^ h->expired);
-    case M_SUPERSEDED:
+    case MUTT_SUPERSEDED:
       return (pat->not ^ h->superseded);
-    case M_FLAG:
+    case MUTT_FLAG:
       return (pat->not ^ h->flagged);
-    case M_TAG:
+    case MUTT_TAG:
       return (pat->not ^ h->tagged);
-    case M_NEW:
+    case MUTT_NEW:
       return (pat->not ? h->old || h->read : !(h->old || h->read));
-    case M_UNREAD:
+    case MUTT_UNREAD:
       return (pat->not ? h->read : !h->read);
-    case M_REPLIED:
+    case MUTT_REPLIED:
       return (pat->not ^ h->replied);
-    case M_OLD:
+    case MUTT_OLD:
       return (pat->not ? (!h->old || h->read) : (h->old && !h->read));
-    case M_READ:
+    case MUTT_READ:
       return (pat->not ^ h->read);
-    case M_DELETED:
+    case MUTT_DELETED:
       return (pat->not ^ h->deleted);
-    case M_MESSAGE:
-      return (pat->not ^ (h->msgno >= pat->min - 1 && (pat->max == M_MAXRANGE ||
+    case MUTT_MESSAGE:
+      return (pat->not ^ (h->msgno >= pat->min - 1 && (pat->max == MUTT_MAXRANGE ||
 						   h->msgno <= pat->max - 1)));
-    case M_DATE:
+    case MUTT_DATE:
       return (pat->not ^ (h->date_sent >= pat->min && h->date_sent <= pat->max));
-    case M_DATE_RECEIVED:
+    case MUTT_DATE_RECEIVED:
       return (pat->not ^ (h->received >= pat->min && h->received <= pat->max));
-    case M_BODY:
-    case M_HEADER:
-    case M_WHOLE_MSG:
+    case MUTT_BODY:
+    case MUTT_HEADER:
+    case MUTT_WHOLE_MSG:
       /*
        * ctx can be NULL in certain cases, such as when replying to a message from the attachment menu and
        * the user has a reply-hook using "~h" (bug #2190).
@@ -1198,68 +1198,68 @@ mutt_pattern_exec (struct pattern_t *pat, pattern_exec_flag flags, CONTEXT *ctx,
 	      return 0;
 #ifdef USE_IMAP
       /* IMAP search sets h->matched at search compile time */
-      if (ctx->magic == M_IMAP && pat->stringmatch)
+      if (ctx->magic == MUTT_IMAP && pat->stringmatch)
 	return (h->matched);
 #endif
       return (pat->not ^ msg_search (ctx, pat, h->msgno));
-    case M_SENDER:
-      return (pat->not ^ match_adrlist (pat, flags & M_MATCH_FULL_ADDRESS, 1,
+    case MUTT_SENDER:
+      return (pat->not ^ match_adrlist (pat, flags & MUTT_MATCH_FULL_ADDRESS, 1,
                                         h->env->sender));
-    case M_FROM:
-      return (pat->not ^ match_adrlist (pat, flags & M_MATCH_FULL_ADDRESS, 1,
+    case MUTT_FROM:
+      return (pat->not ^ match_adrlist (pat, flags & MUTT_MATCH_FULL_ADDRESS, 1,
                                         h->env->from));
-    case M_TO:
-      return (pat->not ^ match_adrlist (pat, flags & M_MATCH_FULL_ADDRESS, 1,
+    case MUTT_TO:
+      return (pat->not ^ match_adrlist (pat, flags & MUTT_MATCH_FULL_ADDRESS, 1,
                                         h->env->to));
-    case M_CC:
-      return (pat->not ^ match_adrlist (pat, flags & M_MATCH_FULL_ADDRESS, 1,
+    case MUTT_CC:
+      return (pat->not ^ match_adrlist (pat, flags & MUTT_MATCH_FULL_ADDRESS, 1,
                                         h->env->cc));
-    case M_SUBJECT:
+    case MUTT_SUBJECT:
       return (pat->not ^ (h->env->subject && patmatch (pat, h->env->subject) == 0));
-    case M_ID:
+    case MUTT_ID:
       return (pat->not ^ (h->env->message_id && patmatch (pat, h->env->message_id) == 0));
-    case M_SCORE:
-      return (pat->not ^ (h->score >= pat->min && (pat->max == M_MAXRANGE ||
+    case MUTT_SCORE:
+      return (pat->not ^ (h->score >= pat->min && (pat->max == MUTT_MAXRANGE ||
 						   h->score <= pat->max)));
-    case M_SIZE:
-      return (pat->not ^ (h->content->length >= pat->min && (pat->max == M_MAXRANGE || h->content->length <= pat->max)));
-    case M_REFERENCE:
+    case MUTT_SIZE:
+      return (pat->not ^ (h->content->length >= pat->min && (pat->max == MUTT_MAXRANGE || h->content->length <= pat->max)));
+    case MUTT_REFERENCE:
       return (pat->not ^ (match_reference (pat, h->env->references) ||
 			  match_reference (pat, h->env->in_reply_to)));
-    case M_ADDRESS:
-      return (pat->not ^ match_adrlist (pat, flags & M_MATCH_FULL_ADDRESS, 4,
+    case MUTT_ADDRESS:
+      return (pat->not ^ match_adrlist (pat, flags & MUTT_MATCH_FULL_ADDRESS, 4,
                                         h->env->from, h->env->sender,
                                         h->env->to, h->env->cc));
-    case M_RECIPIENT:
-           return (pat->not ^ match_adrlist (pat, flags & M_MATCH_FULL_ADDRESS,
+    case MUTT_RECIPIENT:
+           return (pat->not ^ match_adrlist (pat, flags & MUTT_MATCH_FULL_ADDRESS,
                                              2, h->env->to, h->env->cc));
-    case M_LIST:	/* known list, subscribed or not */
+    case MUTT_LIST:	/* known list, subscribed or not */
       return (pat->not ^ mutt_is_list_cc (pat->alladdr, h->env->to, h->env->cc));
-    case M_SUBSCRIBED_LIST:
+    case MUTT_SUBSCRIBED_LIST:
       return (pat->not ^ mutt_is_list_recipient (pat->alladdr, h->env->to, h->env->cc));
-    case M_PERSONAL_RECIP:
+    case MUTT_PERSONAL_RECIP:
       return (pat->not ^ match_user (pat->alladdr, h->env->to, h->env->cc));
-    case M_PERSONAL_FROM:
+    case MUTT_PERSONAL_FROM:
       return (pat->not ^ match_user (pat->alladdr, h->env->from, NULL));
-    case M_COLLAPSED:
+    case MUTT_COLLAPSED:
       return (pat->not ^ (h->collapsed && h->num_hidden > 1));
-   case M_CRYPT_SIGN:
+   case MUTT_CRYPT_SIGN:
      if (!WithCrypto)
        break;
      return (pat->not ^ ((h->security & SIGN) ? 1 : 0));
-   case M_CRYPT_VERIFIED:
+   case MUTT_CRYPT_VERIFIED:
      if (!WithCrypto)
        break;
      return (pat->not ^ ((h->security & GOODSIGN) ? 1 : 0));
-   case M_CRYPT_ENCRYPT:
+   case MUTT_CRYPT_ENCRYPT:
      if (!WithCrypto)
        break;
      return (pat->not ^ ((h->security & ENCRYPT) ? 1 : 0));
-   case M_PGP_KEY:
+   case MUTT_PGP_KEY:
      if (!(WithCrypto & APPLICATION_PGP))
        break;
      return (pat->not ^ ((h->security & APPLICATION_PGP) && (h->security & PGPKEY)));
-    case M_XLABEL:
+    case MUTT_XLABEL:
       {
         LIST *label;
         int result = 0;
@@ -1274,26 +1274,26 @@ mutt_pattern_exec (struct pattern_t *pat, pattern_exec_flag flags, CONTEXT *ctx,
         return pat->not ^ result;
       }
 #ifdef USE_NOTMUCH
-    case M_NOTMUCH_LABEL:
+    case MUTT_NOTMUCH_LABEL:
       {
       char *tags = nm_header_get_tags(h);
       return (pat->not ^ (tags && patmatch (pat, tags) == 0));
       }
 #endif
-    case M_HORMEL:
+    case MUTT_HORMEL:
       return (pat->not ^ (h->env->spam && h->env->spam->data && patmatch (pat, h->env->spam->data) == 0));
-    case M_DUPLICATED:
+    case MUTT_DUPLICATED:
       return (pat->not ^ (h->thread && h->thread->duplicate_thread));
-    case M_MIMEATTACH:
+    case MUTT_MIMEATTACH:
       {
       int count = mutt_count_body_parts (ctx, h);
-      return (pat->not ^ (count >= pat->min && (pat->max == M_MAXRANGE ||
+      return (pat->not ^ (count >= pat->min && (pat->max == MUTT_MAXRANGE ||
                                                 count <= pat->max)));
       }
-    case M_UNREFERENCED:
+    case MUTT_UNREFERENCED:
       return (pat->not ^ (h->thread && !h->thread->child));
 #ifdef USE_NNTP
-    case M_NEWSGROUPS:
+    case MUTT_NEWSGROUPS:
       return (pat->not ^ (h->env->newsgroups && patmatch (pat, h->env->newsgroups) == 0));
 #endif
   }
@@ -1445,8 +1445,8 @@ int mutt_pattern_func (int op, char *prompt)
   progress_t progress;
 
   strfcpy (buf, NONULL (Context->pattern), sizeof (buf));
-  if (prompt || op != M_LIMIT)
-  if (mutt_get_field (prompt, buf, sizeof (buf), M_PATTERN | M_CLEAR) != 0 || !buf[0])
+  if (prompt || op != MUTT_LIMIT)
+  if (mutt_get_field (prompt, buf, sizeof (buf), MUTT_PATTERN | MUTT_CLEAR) != 0 || !buf[0])
     return (-1);
 
   mutt_message _("Compiling search pattern...");
@@ -1457,7 +1457,7 @@ int mutt_pattern_func (int op, char *prompt)
   mutt_buffer_init (&err);
   err.dsize = STRING;
   err.data = safe_malloc(err.dsize);
-  if ((pat = mutt_pattern_comp (buf, M_FULL_MSG, &err)) == NULL)
+  if ((pat = mutt_pattern_comp (buf, MUTT_FULL_MSG, &err)) == NULL)
   {
     FREE (&simple);
     mutt_error ("%s", err.data);
@@ -1466,17 +1466,17 @@ int mutt_pattern_func (int op, char *prompt)
   }
 
 #ifdef USE_IMAP
-  if (Context->magic == M_IMAP && imap_search (Context, pat) < 0)
+  if (Context->magic == MUTT_IMAP && imap_search (Context, pat) < 0)
     return -1;
 #endif
 
   mutt_progress_init (&progress, _("Executing command on matching messages..."),
-		      M_PROGRESS_MSG, ReadInc,
-		      (op == M_LIMIT) ? Context->msgcount : Context->vcount);
+		      MUTT_PROGRESS_MSG, ReadInc,
+		      (op == MUTT_LIMIT) ? Context->msgcount : Context->vcount);
 
 #define THIS_BODY Context->hdrs[i]->content
 
-  if (op == M_LIMIT)
+  if (op == MUTT_LIMIT)
   {
     Context->vcount    = 0;
     Context->vsize     = 0;
@@ -1490,7 +1490,7 @@ int mutt_pattern_func (int op, char *prompt)
       Context->hdrs[i]->limited = 0;
       Context->hdrs[i]->collapsed = 0;
       Context->hdrs[i]->num_hidden = 0;
-      if (mutt_pattern_exec (pat, M_MATCH_FULL_ADDRESS, Context, Context->hdrs[i]))
+      if (mutt_pattern_exec (pat, MUTT_MATCH_FULL_ADDRESS, Context, Context->hdrs[i]))
       {
 	Context->hdrs[i]->virtual = Context->vcount;
 	Context->hdrs[i]->limited = 1;
@@ -1506,20 +1506,20 @@ int mutt_pattern_func (int op, char *prompt)
     for (i = 0; i < Context->vcount; i++)
     {
       mutt_progress_update (&progress, i, -1);
-      if (mutt_pattern_exec (pat, M_MATCH_FULL_ADDRESS, Context, Context->hdrs[Context->v2r[i]]))
+      if (mutt_pattern_exec (pat, MUTT_MATCH_FULL_ADDRESS, Context, Context->hdrs[Context->v2r[i]]))
       {
 	switch (op)
 	{
-	  case M_UNDELETE:
-	    mutt_set_flag (Context, Context->hdrs[Context->v2r[i]], M_PURGED, 0);
-	  case M_DELETE:
-	    mutt_set_flag (Context, Context->hdrs[Context->v2r[i]], M_DELETE, 
-			  (op == M_DELETE));
+	  case MUTT_UNDELETE:
+	    mutt_set_flag (Context, Context->hdrs[Context->v2r[i]], MUTT_PURGED, 0);
+	  case MUTT_DELETE:
+	    mutt_set_flag (Context, Context->hdrs[Context->v2r[i]], MUTT_DELETE, 
+			  (op == MUTT_DELETE));
 	    break;
-	  case M_TAG:
-	  case M_UNTAG:
-	    mutt_set_flag (Context, Context->hdrs[Context->v2r[i]], M_TAG, 
-			   (op == M_TAG));
+	  case MUTT_TAG:
+	  case MUTT_UNTAG:
+	    mutt_set_flag (Context, Context->hdrs[Context->v2r[i]], MUTT_TAG, 
+			   (op == MUTT_TAG));
 	    break;
 	}
       }
@@ -1530,7 +1530,7 @@ int mutt_pattern_func (int op, char *prompt)
 
   mutt_clear_error ();
 
-  if (op == M_LIMIT)
+  if (op == MUTT_LIMIT)
   {
     /* drop previous limit pattern */
     FREE (&Context->pattern);
@@ -1545,7 +1545,7 @@ int mutt_pattern_func (int op, char *prompt)
     {
       Context->pattern = simple;
       simple = NULL; /* don't clobber it */
-      Context->limit_pattern = mutt_pattern_comp (buf, M_FULL_MSG, &err);
+      Context->limit_pattern = mutt_pattern_comp (buf, MUTT_FULL_MSG, &err);
     }
   }
   FREE (&simple);
@@ -1571,7 +1571,7 @@ int mutt_search_command (int cur, int op)
     if (mutt_get_field ((op == OP_SEARCH || op == OP_SEARCH_NEXT) ?
 			_("Search for: ") : _("Reverse search for: "),
 			buf, sizeof (buf),
-		      M_CLEAR | M_PATTERN) != 0 || !buf[0])
+		      MUTT_CLEAR | MUTT_PATTERN) != 0 || !buf[0])
       return (-1);
 
     if (op == OP_SEARCH || op == OP_SEARCH_NEXT)
@@ -1594,7 +1594,7 @@ int mutt_search_command (int cur, int op)
       mutt_pattern_free (&SearchPattern);
       err.dsize = STRING;
       err.data = safe_malloc (err.dsize);
-      if ((SearchPattern = mutt_pattern_comp (temp, M_FULL_MSG, &err)) == NULL)
+      if ((SearchPattern = mutt_pattern_comp (temp, MUTT_FULL_MSG, &err)) == NULL)
       {
 	mutt_error ("%s", err.data);
 	FREE (&err.data);
@@ -1610,7 +1610,7 @@ int mutt_search_command (int cur, int op)
     for (i = 0; i < Context->msgcount; i++)
       Context->hdrs[i]->searched = 0;
 #ifdef USE_IMAP
-    if (Context->magic == M_IMAP && imap_search (Context, SearchPattern) < 0)
+    if (Context->magic == MUTT_IMAP && imap_search (Context, SearchPattern) < 0)
       return -1;
 #endif
     unset_option (OPTSEARCHINVALID);
@@ -1620,7 +1620,7 @@ int mutt_search_command (int cur, int op)
   if (op == OP_SEARCH_OPPOSITE)
     incr = -incr;
 
-  mutt_progress_init (&progress, _("Searching..."), M_PROGRESS_MSG,
+  mutt_progress_init (&progress, _("Searching..."), MUTT_PROGRESS_MSG,
 		      ReadInc, Context->vcount);
 
   for (i = cur + incr, j = 0 ; j != Context->vcount; j++)
@@ -1665,7 +1665,7 @@ int mutt_search_command (int cur, int op)
     {
       /* remember that we've already searched this message */
       h->searched = 1;
-      if ((h->matched = (mutt_pattern_exec (SearchPattern, M_MATCH_FULL_ADDRESS, Context, h) > 0)))
+      if ((h->matched = (mutt_pattern_exec (SearchPattern, MUTT_MATCH_FULL_ADDRESS, Context, h) > 0)))
       {
 	mutt_clear_error();
 	if (msg && *msg)
diff --git a/pgp.c b/pgp.c
index fb7be4c..6a6f3c9 100644
--- a/pgp.c
+++ b/pgp.c
@@ -287,9 +287,9 @@ static void pgp_copy_clearsigned (FILE *fpin, STATE *s, char *charset)
 
   /* fromcode comes from the MIME Content-Type charset label. It might
    * be a wrong label, so we want the ability to do corrections via
-   * charset-hooks. Therefore we set flags to M_ICONV_HOOK_FROM.
+   * charset-hooks. Therefore we set flags to MUTT_ICONV_HOOK_FROM.
    */
-  fc = fgetconv_open (fpin, charset, Charset, M_ICONV_HOOK_FROM);
+  fc = fgetconv_open (fpin, charset, Charset, MUTT_ICONV_HOOK_FROM);
   
   for (complete = 1, armor_header = 1;
        fgetconvs (buf, sizeof (buf), fc) != NULL;
@@ -350,7 +350,7 @@ int pgp_application_pgp_handler (BODY *m, STATE *s)
   char body_charset[STRING];
   mutt_get_body_charset (body_charset, sizeof (body_charset), m);
 
-  rc = 0;	/* silence false compiler warning if (s->flags & M_DISPLAY) */
+  rc = 0;	/* silence false compiler warning if (s->flags & MUTT_DISPLAY) */
 
   fseeko (s->fpin, m->offset, 0);
   last_pos = m->offset;
@@ -389,7 +389,7 @@ int pgp_application_pgp_handler (BODY *m, STATE *s)
 	continue;
       }
 
-      have_any_sigs = have_any_sigs || (clearsign && (s->flags & M_VERIFY));
+      have_any_sigs = have_any_sigs || (clearsign && (s->flags & MUTT_VERIFY));
 
       /* Copy PGP material to temporary file */
       mutt_mktemp (tmpfname, sizeof (tmpfname));
@@ -429,7 +429,7 @@ int pgp_application_pgp_handler (BODY *m, STATE *s)
       fflush (tmpfp);
 
       /* Invoke PGP if needed */
-      if (!clearsign || (s->flags & M_VERIFY))
+      if (!clearsign || (s->flags & MUTT_VERIFY))
       {
 	mutt_mktemp (outfile, sizeof (outfile));
 	if ((pgpout = safe_fopen (outfile, "w+")) == NULL)
@@ -460,7 +460,7 @@ int pgp_application_pgp_handler (BODY *m, STATE *s)
 	  
 	  safe_fclose (&pgpin);
 
-	  if (s->flags & M_DISPLAY)
+	  if (s->flags & MUTT_DISPLAY)
 	  {
 	    crypt_current_time (s, "PGP");
 	    rc = pgp_copy_checksig (pgperr, s->fpout);
@@ -469,7 +469,7 @@ int pgp_application_pgp_handler (BODY *m, STATE *s)
 	  safe_fclose (&pgperr);
 	  rv = mutt_wait_filter (thepid);
 	  
-	  if (s->flags & M_DISPLAY)
+	  if (s->flags & MUTT_DISPLAY)
 	  {
 	    if (rc == 0) have_any_sigs = 1;
 	    /*
@@ -500,7 +500,7 @@ int pgp_application_pgp_handler (BODY *m, STATE *s)
 	  pgp_void_passphrase ();
 	}
 	
-	if (could_not_decrypt && !(s->flags & M_DISPLAY))
+	if (could_not_decrypt && !(s->flags & MUTT_DISPLAY))
 	{
           mutt_error _("Could not decrypt PGP message");
 	  mutt_sleep (1);
@@ -513,7 +513,7 @@ int pgp_application_pgp_handler (BODY *m, STATE *s)
        * Now, copy cleartext to the screen.
        */
 
-      if(s->flags & M_DISPLAY)
+      if(s->flags & MUTT_DISPLAY)
       {
 	if (needpass)
 	  state_attach_puts (_("[-- BEGIN PGP MESSAGE --]\n\n"), s);
@@ -540,7 +540,7 @@ int pgp_application_pgp_handler (BODY *m, STATE *s)
 
 	rewind (pgpout);
 	state_set_prefix (s);
-	fc = fgetconv_open (pgpout, expected_charset, Charset, M_ICONV_HOOK_FROM);
+	fc = fgetconv_open (pgpout, expected_charset, Charset, MUTT_ICONV_HOOK_FROM);
 	while ((c = fgetconv (fc)) != EOF)
 	  state_prefix_putc (c, s);
 	fgetconv_close (&fc);
@@ -558,7 +558,7 @@ int pgp_application_pgp_handler (BODY *m, STATE *s)
 	mutt_unlink (outfile);
       }
 
-      if (s->flags & M_DISPLAY)
+      if (s->flags & MUTT_DISPLAY)
       {
 	state_putc ('\n', s);
 	if (needpass)
@@ -798,7 +798,7 @@ void pgp_extract_keys_from_messages (HEADER *h)
 	  goto bailout;
 	}
 	mutt_copy_message (fpout, Context, Context->hdrs[Context->v2r[i]], 
-			   M_CM_DECODE|M_CM_CHARCONV, 0);
+			   MUTT_CM_DECODE|MUTT_CM_CHARCONV, 0);
       }
     }
   } 
@@ -810,7 +810,7 @@ void pgp_extract_keys_from_messages (HEADER *h)
       safe_fclose (&fpout);
       goto bailout;
     }
-    mutt_copy_message (fpout, Context, h, M_CM_DECODE|M_CM_CHARCONV, 0);
+    mutt_copy_message (fpout, Context, h, MUTT_CM_DECODE|MUTT_CM_CHARCONV, 0);
   }
       
   safe_fclose (&fpout);
@@ -917,7 +917,7 @@ BODY *pgp_decrypt_part (BODY *a, STATE *s, FILE *fpout, BODY *p)
   {
     safe_fclose (&pgperr);
     unlink (pgptmpfile);
-    if (s->flags & M_DISPLAY)
+    if (s->flags & MUTT_DISPLAY)
       state_attach_puts (_("[-- Error: could not create a PGP subprocess! --]\n\n"), s);
     return (NULL);
   }
@@ -954,7 +954,7 @@ BODY *pgp_decrypt_part (BODY *a, STATE *s, FILE *fpout, BODY *p)
     return NULL;
   }
 
-  if (s->flags & M_DISPLAY)
+  if (s->flags & MUTT_DISPLAY)
   {
     rewind (pgperr);
     if (pgp_copy_checksig (pgperr, s->fpout) == 0 && !rv && p)
@@ -1087,16 +1087,16 @@ int pgp_encrypted_handler (BODY *a, STATE *s)
   mutt_mktemp (tempfile, sizeof (tempfile));
   if ((fpout = safe_fopen (tempfile, "w+")) == NULL)
   {
-    if (s->flags & M_DISPLAY)
+    if (s->flags & MUTT_DISPLAY)
       state_attach_puts (_("[-- Error: could not create temporary file! --]\n"), s);
     return -1;
   }
 
-  if (s->flags & M_DISPLAY) crypt_current_time (s, "PGP");
+  if (s->flags & MUTT_DISPLAY) crypt_current_time (s, "PGP");
 
   if ((tattach = pgp_decrypt_part (a, s, fpout, a)) != NULL)
   {
-    if (s->flags & M_DISPLAY)
+    if (s->flags & MUTT_DISPLAY)
       state_attach_puts (_("[-- The following data is PGP/MIME encrypted --]\n\n"), s);
 
     fpin = s->fpin;
@@ -1114,7 +1114,7 @@ int pgp_encrypted_handler (BODY *a, STATE *s)
     if (mutt_is_multipart_signed (tattach) && !tattach->next)
       a->goodsig |= tattach->goodsig;
     
-    if (s->flags & M_DISPLAY)
+    if (s->flags & MUTT_DISPLAY)
     {
       state_puts ("\n", s);
       state_attach_puts (_("[-- End of PGP/MIME encrypted data --]\n"), s);
@@ -1298,13 +1298,13 @@ char *pgp_findKeys (ADDRESS *adrlist, int oppenc_mode)
       if (crypt_hook != NULL)
       {
         keyID = crypt_hook->data;
-        r = M_YES;
+        r = MUTT_YES;
         if (! oppenc_mode && option(OPTCRYPTCONFIRMHOOK))
         {
           snprintf (buf, sizeof (buf), _("Use keyID = \"%s\" for %s?"), keyID, p->mailbox);
-          r = mutt_yesorno (buf, M_YES);
+          r = mutt_yesorno (buf, MUTT_YES);
         }
-        if (r == M_YES)
+        if (r == MUTT_YES)
         {
           if (crypt_is_numerical_keyid (keyID))
           {
@@ -1325,7 +1325,7 @@ char *pgp_findKeys (ADDRESS *adrlist, int oppenc_mode)
             k_info = pgp_getkeybystr (keyID, KEYFLAG_CANENCRYPT, PGP_PUBRING);
           }
         }
-        else if (r == M_NO)
+        else if (r == MUTT_NO)
         {
           if (key_selected || (crypt_hook->next != NULL))
           {
diff --git a/pgpinvoke.c b/pgpinvoke.c
index cf7e6c9..ee76628 100644
--- a/pgpinvoke.c
+++ b/pgpinvoke.c
@@ -70,7 +70,7 @@ const char *_mutt_fmt_pgp_command (char *dest,
 {
   char fmt[16];
   struct pgp_command_context *cctx = (struct pgp_command_context *) data;
-  int optional = (flags & M_FORMAT_OPTIONAL);
+  int optional = (flags & MUTT_FORMAT_OPTIONAL);
   
   switch (op)
   {
@@ -142,7 +142,7 @@ const char *_mutt_fmt_pgp_command (char *dest,
 
   if (optional)
     mutt_FormatString (dest, destlen, col, cols, ifstring, _mutt_fmt_pgp_command, data, 0);
-  else if (flags & M_FORMAT_OPTIONAL)
+  else if (flags & MUTT_FORMAT_OPTIONAL)
     mutt_FormatString (dest, destlen, col, cols, elsestring, _mutt_fmt_pgp_command, data, 0);
 
   return (src);
diff --git a/pgpkey.c b/pgpkey.c
index cdaa036..46661b7 100644
--- a/pgpkey.c
+++ b/pgpkey.c
@@ -136,7 +136,7 @@ static const char *pgp_entry_fmt (char *dest,
   pgp_uid_t *uid;
   pgp_key_t key, pkey;
   int kflags = 0;
-  int optional = (flags & M_FORMAT_OPTIONAL);
+  int optional = (flags & MUTT_FORMAT_OPTIONAL);
 
   entry = (pgp_entry_t *) data;
   uid   = entry->uid;
@@ -280,7 +280,7 @@ static const char *pgp_entry_fmt (char *dest,
 
   if (optional)
     mutt_FormatString (dest, destlen, col, cols, ifstring, mutt_attach_fmt, data, 0);
-  else if (flags & M_FORMAT_OPTIONAL)
+  else if (flags & MUTT_FORMAT_OPTIONAL)
     mutt_FormatString (dest, destlen, col, cols, elsestring, mutt_attach_fmt, data, 0);
   return (src);
 }
@@ -294,7 +294,7 @@ static void pgp_entry (char *s, size_t l, MUTTMENU * menu, int num)
   entry.num = num + 1;
 
   mutt_FormatString (s, l, 0, MuttIndexWindow->cols, NONULL (PgpEntryFormat), pgp_entry_fmt, 
-		     (unsigned long) &entry, M_FORMAT_ARROWCURSOR);
+		     (unsigned long) &entry, MUTT_FORMAT_ARROWCURSOR);
 }
 
 static int _pgp_compare_address (const void *a, const void *b)
@@ -628,7 +628,7 @@ static pgp_key_t pgp_select_key (pgp_key_t keys,
 	snprintf (buff, sizeof (buff), _("%s Do you really want to use the key?"),
 		  _(s));
 
-	if (mutt_yesorno (buff, M_NO) != M_YES)
+	if (mutt_yesorno (buff, MUTT_NO) != MUTT_YES)
 	{
 	  mutt_clear_error ();
 	  break;
@@ -684,7 +684,7 @@ pgp_key_t pgp_ask_for_key (char *tag, char *whatfor,
   FOREVER
   {
     resp[0] = 0;
-    if (mutt_get_field (tag, resp, sizeof (resp), M_CLEAR) != 0)
+    if (mutt_get_field (tag, resp, sizeof (resp), MUTT_CLEAR) != 0)
       return NULL;
 
     if (whatfor)
diff --git a/pop.c b/pop.c
index 11af0ab..e297796 100644
--- a/pop.c
+++ b/pop.c
@@ -279,7 +279,7 @@ static int pop_fetch_headers (CONTEXT *ctx)
 
   if (!ctx->quiet)
     mutt_progress_init (&progress, _("Fetching message headers..."),
-                        M_PROGRESS_MSG, ReadInc, new_count - old_count);
+                        MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);
 
   if (ret == 0)
   {
@@ -333,7 +333,7 @@ static int pop_fetch_headers (CONTEXT *ctx)
 #if USE_HCACHE
       else
       {
-	mutt_hcache_store (hc, ctx->hdrs[i]->data, ctx->hdrs[i], 0, strlen, M_GENERATE_UIDVALIDITY);
+	mutt_hcache_store (hc, ctx->hdrs[i]->data, ctx->hdrs[i], 0, strlen, MUTT_GENERATE_UIDVALIDITY);
       }
 
       FREE(&data);
@@ -436,12 +436,12 @@ int pop_open_mailbox (CONTEXT *ctx)
 
   /* init (hard-coded) ACL rights */
   memset (ctx->rights, 0, sizeof (ctx->rights));
-  mutt_bit_set (ctx->rights, M_ACL_SEEN);
-  mutt_bit_set (ctx->rights, M_ACL_DELETE);
+  mutt_bit_set (ctx->rights, MUTT_ACL_SEEN);
+  mutt_bit_set (ctx->rights, MUTT_ACL_DELETE);
 #if USE_HCACHE
   /* flags are managed using header cache, so it only makes sense to
    * enable them in that case */
-  mutt_bit_set (ctx->rights, M_ACL_WRITE);
+  mutt_bit_set (ctx->rights, MUTT_ACL_WRITE);
 #endif
 
   FOREVER
@@ -570,7 +570,7 @@ int pop_fetch_message (MESSAGE* msg, CONTEXT* ctx, int msgno)
     }
 
     mutt_progress_init (&progressbar, _("Fetching message..."),
-			M_PROGRESS_SIZE, NetInc, h->content->length + h->content->offset - 1);
+			MUTT_PROGRESS_SIZE, NetInc, h->content->length + h->content->offset - 1);
 
     /* see if we can put in body cache; use our cache as fallback */
     if (!(msg->fp = mutt_bcache_put (pop_data->bcache, h->data, 1)))
@@ -676,7 +676,7 @@ int pop_sync_mailbox (CONTEXT *ctx, int *index_hint)
       return -1;
 
     mutt_progress_init (&progress, _("Marking messages deleted..."),
-			M_PROGRESS_MSG, WriteInc, ctx->deleted);
+			MUTT_PROGRESS_MSG, WriteInc, ctx->deleted);
 
 #if USE_HCACHE
     hc = pop_hcache_open (pop_data, ctx->path);
@@ -702,7 +702,7 @@ int pop_sync_mailbox (CONTEXT *ctx, int *index_hint)
 #if USE_HCACHE
       if (ctx->hdrs[i]->changed)
       {
-	mutt_hcache_store (hc, ctx->hdrs[i]->data, ctx->hdrs[i], 0, strlen, M_GENERATE_UIDVALIDITY);
+	mutt_hcache_store (hc, ctx->hdrs[i]->data, ctx->hdrs[i], 0, strlen, MUTT_GENERATE_UIDVALIDITY);
       }
 #endif
 
@@ -762,7 +762,7 @@ int pop_check_mailbox (CONTEXT *ctx, int *index_hint)
     return -1;
 
   if (ret > 0)
-    return M_NEW_MAIL;
+    return MUTT_NEW_MAIL;
 
   return 0;
 }
@@ -850,7 +850,7 @@ void pop_fetch_mail (void)
     goto finish;
   }
 
-  if (mx_open_mailbox (NONULL (Spoolfile), M_APPEND, &ctx) == NULL)
+  if (mx_open_mailbox (NONULL (Spoolfile), MUTT_APPEND, &ctx) == NULL)
     goto finish;
 
   delanswer = query_quadoption (OPT_POPDELETE, _("Delete messages from server?"));
@@ -860,7 +860,7 @@ void pop_fetch_mail (void)
 
   for (i = last + 1 ; i <= msgs ; i++)
   {
-    if ((msg = mx_open_new_message (&ctx, NULL, M_ADD_FROM)) == NULL)
+    if ((msg = mx_open_new_message (&ctx, NULL, MUTT_ADD_FROM)) == NULL)
       ret = -3;
     else
     {
@@ -878,7 +878,7 @@ void pop_fetch_mail (void)
       mx_close_message (&msg);
     }
 
-    if (ret == 0 && delanswer == M_YES)
+    if (ret == 0 && delanswer == MUTT_YES)
     {
       /* delete the message on the server */
       snprintf (buffer, sizeof (buffer), "DELE %d\r\n", i);
diff --git a/pop_auth.c b/pop_auth.c
index 6e69761..8d8650e 100644
--- a/pop_auth.c
+++ b/pop_auth.c
@@ -273,7 +273,7 @@ static pop_auth_res_t pop_auth_user (POP_DATA *pop_data, const char *method)
     ret = pop_query_d (pop_data, buf, sizeof (buf), 
 #ifdef DEBUG
 	/* don't print the password unless we're at the ungodly debugging level */
-	debuglevel < M_SOCK_LOG_FULL ? "PASS *\r\n" :
+	debuglevel < MUTT_SOCK_LOG_FULL ? "PASS *\r\n" :
 #endif
 	NULL);
   }
diff --git a/pop_lib.c b/pop_lib.c
index 94d1f83..023745e 100644
--- a/pop_lib.c
+++ b/pop_lib.c
@@ -44,7 +44,7 @@ int pop_parse_path (const char* path, ACCOUNT* acct)
 
   /* Defaults */
   acct->flags = 0;
-  acct->type = M_ACCT_TYPE_POP;
+  acct->type = MUTT_ACCT_TYPE_POP;
   acct->port = 0;
 
   c = safe_strdup (path);
@@ -60,7 +60,7 @@ int pop_parse_path (const char* path, ACCOUNT* acct)
   }
 
   if (url.scheme == U_POPS)
-    acct->flags |= M_ACCT_SSL;
+    acct->flags |= MUTT_ACCT_SSL;
 
   service = getservbyname (url.scheme == U_POP ? "pop3" : "pop3s", "tcp");
   if (!acct->port) {
@@ -296,7 +296,7 @@ int pop_open_connection (POP_DATA *pop_data)
       if (ret == -1)
 	return -2;
       pop_data->use_stls = 1;
-      if (ret == M_YES)
+      if (ret == MUTT_YES)
 	pop_data->use_stls = 2;
     }
     if (pop_data->use_stls == 2)
@@ -418,7 +418,7 @@ void pop_logout (CONTEXT *ctx)
 */
 int pop_query_d (POP_DATA *pop_data, char *buf, size_t buflen, char *msg)
 {
-  int dbg = M_SOCK_LOG_CMD;
+  int dbg = MUTT_SOCK_LOG_CMD;
   char *c;
 
   if (pop_data->status != POP_CONNECTED)
@@ -428,8 +428,8 @@ int pop_query_d (POP_DATA *pop_data, char *buf, size_t buflen, char *msg)
     /* print msg instead of real command */
     if (msg)
     {
-      dbg = M_SOCK_LOG_FULL;
-      dprint (M_SOCK_LOG_CMD, (debugfile, "> %s", msg));
+      dbg = MUTT_SOCK_LOG_FULL;
+      dprint (MUTT_SOCK_LOG_CMD, (debugfile, "> %s", msg));
     }
 #endif
 
@@ -479,7 +479,7 @@ int pop_fetch_data (POP_DATA *pop_data, char *query, progress_t *progressbar,
 
   FOREVER
   {
-    chunk = mutt_socket_readln_d (buf, sizeof (buf), pop_data->conn, M_SOCK_LOG_HDR);
+    chunk = mutt_socket_readln_d (buf, sizeof (buf), pop_data->conn, MUTT_SOCK_LOG_HDR);
     if (chunk < 0)
     {
       pop_data->status = POP_DISCONNECTED;
@@ -569,7 +569,7 @@ int pop_reconnect (CONTEXT *ctx)
       int i;
 
       mutt_progress_init (&progressbar, _("Verifying message indexes..."),
-			  M_PROGRESS_SIZE, NetInc, 0);
+			  MUTT_PROGRESS_SIZE, NetInc, 0);
 
       for (i = 0; i < ctx->msgcount; i++)
 	ctx->hdrs[i]->refno = -1;
@@ -590,7 +590,7 @@ int pop_reconnect (CONTEXT *ctx)
       return -1;
 
     if (query_quadoption (OPT_POPRECONNECT,
-		_("Connection lost. Reconnect to POP server?")) != M_YES)
+		_("Connection lost. Reconnect to POP server?")) != MUTT_YES)
       return -1;
   }
 }
diff --git a/postpone.c b/postpone.c
index 7c62c96..c8e298f 100644
--- a/postpone.c
+++ b/postpone.c
@@ -136,7 +136,7 @@ int mutt_num_postponed (int force)
     if (optnews)
 	unset_option (OPTNEWS);
 #endif
-    if (mx_open_mailbox (Postponed, M_NOSORT | M_QUIET, &ctx) == NULL)
+    if (mx_open_mailbox (Postponed, MUTT_NOSORT | MUTT_QUIET, &ctx) == NULL)
       PostCount = 0;
     else
       PostCount = ctx.msgcount;
@@ -160,7 +160,7 @@ static void post_entry (char *s, size_t slen, MUTTMENU *menu, int entry)
   CONTEXT *ctx = (CONTEXT *) menu->data;
 
   _mutt_make_string (s, slen, NONULL (HdrFmt), ctx, ctx->hdrs[entry],
-		     M_FORMAT_ARROWCURSOR);
+		     MUTT_FORMAT_ARROWCURSOR);
 }
 
 static HEADER *select_msg (void)
@@ -189,7 +189,7 @@ static HEADER *select_msg (void)
     {
       case OP_DELETE:
       case OP_UNDELETE:
-	mutt_set_flag (PostContext, PostContext->hdrs[menu->current], M_DELETE, (i == OP_DELETE) ? 1 : 0);
+	mutt_set_flag (PostContext, PostContext->hdrs[menu->current], MUTT_DELETE, (i == OP_DELETE) ? 1 : 0);
 	PostCount = PostContext->msgcount - PostContext->deleted;
 	if (option (OPTRESOLVE) && menu->current < menu->max - 1)
 	{
@@ -250,7 +250,7 @@ int mutt_get_postponed (CONTEXT *ctx, HEADER *hdr, HEADER **cur, char *fcc, size
   if (!Postponed)
     return (-1);
 
-  if ((PostContext = mx_open_mailbox (Postponed, M_NOSORT, NULL)) == NULL)
+  if ((PostContext = mx_open_mailbox (Postponed, MUTT_NOSORT, NULL)) == NULL)
   {
     PostCount = 0;
     mutt_error _("No postponed messages.");
@@ -286,17 +286,17 @@ int mutt_get_postponed (CONTEXT *ctx, HEADER *hdr, HEADER **cur, char *fcc, size
   }
 
   /* finished with this message, so delete it. */
-  mutt_set_flag (PostContext, h, M_DELETE, 1);
+  mutt_set_flag (PostContext, h, MUTT_DELETE, 1);
 
   /* and consider it saved, so that it won't be moved to the trash folder */
-  mutt_set_flag (PostContext, h, M_APPENDED, 1);
+  mutt_set_flag (PostContext, h, MUTT_APPENDED, 1);
 
   /* update the count for the status display */
   PostCount = PostContext->msgcount - PostContext->deleted;
 
   /* avoid the "purge deleted messages" prompt */
   opt_delete = quadoption (OPT_DELETE);
-  set_quadoption (OPT_DELETE, M_YES);
+  set_quadoption (OPT_DELETE, MUTT_YES);
   mx_close_mailbox (PostContext, NULL);
   set_quadoption (OPT_DELETE, opt_delete);
 
@@ -678,7 +678,7 @@ int mutt_prepare_template (FILE *fp, CONTEXT *ctx, HEADER *newhdr, HEADER *hdr,
 	b->noconv = 1;
       else
       {
-	s.flags |= M_CHARCONV;
+	s.flags |= MUTT_CHARCONV;
 	b->noconv = 0;
       }
 
diff --git a/protos.h b/protos.h
index 79d877b..71a0cd7 100644
--- a/protos.h
+++ b/protos.h
@@ -59,11 +59,11 @@ int _mutt_system (const char *, int);
 #define mutt_previous_subthread(x) _mutt_aside_thread(x,0,1)
 int _mutt_aside_thread (HEADER *, short, short);
 
-#define mutt_collapse_thread(x,y) _mutt_traverse_thread (x,y,M_THREAD_COLLAPSE)
-#define mutt_uncollapse_thread(x,y) _mutt_traverse_thread (x,y,M_THREAD_UNCOLLAPSE)
-#define mutt_get_hidden(x,y)_mutt_traverse_thread (x,y,M_THREAD_GET_HIDDEN) 
-#define mutt_thread_contains_unread(x,y) _mutt_traverse_thread (x,y,M_THREAD_UNREAD)
-#define mutt_thread_next_unread(x,y) _mutt_traverse_thread(x,y,M_THREAD_NEXT_UNREAD)
+#define mutt_collapse_thread(x,y) _mutt_traverse_thread (x,y,MUTT_THREAD_COLLAPSE)
+#define mutt_uncollapse_thread(x,y) _mutt_traverse_thread (x,y,MUTT_THREAD_UNCOLLAPSE)
+#define mutt_get_hidden(x,y)_mutt_traverse_thread (x,y,MUTT_THREAD_GET_HIDDEN) 
+#define mutt_thread_contains_unread(x,y) _mutt_traverse_thread (x,y,MUTT_THREAD_UNREAD)
+#define mutt_thread_next_unread(x,y) _mutt_traverse_thread(x,y,MUTT_THREAD_NEXT_UNREAD)
 int _mutt_traverse_thread (CONTEXT *ctx, HEADER *hdr, int flag);
 
 
@@ -317,7 +317,7 @@ int mutt_parent_message (CONTEXT *, HEADER *);
 int mutt_prepare_template(FILE*, CONTEXT *, HEADER *, HEADER *, short);
 int mutt_resend_message (FILE *, CONTEXT *, HEADER *);
 #define mutt_enter_fname(A,B,C,D,E) _mutt_enter_fname(A,B,C,D,E,0,NULL,NULL,0)
-#define mutt_enter_vfolder(A,B,C,D,E) _mutt_enter_fname(A,B,C,D,E,0,NULL,NULL,M_SEL_VFOLDER)
+#define mutt_enter_vfolder(A,B,C,D,E) _mutt_enter_fname(A,B,C,D,E,0,NULL,NULL,MUTT_SEL_VFOLDER)
 int _mutt_enter_fname (const char *, char *, size_t, int *, int, int, char ***, int *, int);
 int  mutt_enter_string (char *buf, size_t buflen, int col, int flags);
 int _mutt_enter_string (char *, size_t, int, int, int, char ***, int *, ENTER_STATE *);
@@ -325,7 +325,7 @@ int _mutt_enter_string (char *, size_t, int, int, int, char ***, int *, ENTER_ST
 int _mutt_get_field (const char *, char *, size_t, int, int, char ***, int *);
 int mutt_get_hook_type (const char *);
 int mutt_get_field_unbuffered (char *, char *, size_t, int);
-#define mutt_get_password(A,B,C) mutt_get_field_unbuffered(A,B,C,M_PASS)
+#define mutt_get_password(A,B,C) mutt_get_field_unbuffered(A,B,C,MUTT_PASS)
 int mutt_get_postponed (CONTEXT *, HEADER *, HEADER **, char *, size_t);
 int mutt_get_tmp_attachment (BODY *);
 int mutt_index_menu (void);
@@ -453,7 +453,7 @@ void mutt_pattern_free (pattern_t **pat);
 int getdnsdomainname (char *, size_t);
 
 /* According to SCO support, this is how to detect SCO */
-#if defined (_M_UNIX) || defined (M_OS)
+#if defined (_M_UNIX) || defined (MUTT_OS)
 #define SCO
 #endif
 
diff --git a/query.c b/query.c
index 361b38e..a229a71 100644
--- a/query.c
+++ b/query.c
@@ -193,7 +193,7 @@ static const char * query_format_str (char *dest, size_t destlen, size_t col, in
   QUERY *query = entry->data;
   char tmp[SHORT_STRING];
   char buf2[STRING] = "";
-  int optional = (flags & M_FORMAT_OPTIONAL);
+  int optional = (flags & MUTT_FORMAT_OPTIONAL);
 
   switch (op)
   {
@@ -231,7 +231,7 @@ static const char * query_format_str (char *dest, size_t destlen, size_t col, in
 
   if (optional)
     mutt_FormatString (dest, destlen, col, cols, ifstring, query_format_str, data, 0);
-  else if (flags & M_FORMAT_OPTIONAL)
+  else if (flags & MUTT_FORMAT_OPTIONAL)
     mutt_FormatString (dest, destlen, col, cols, elsestring, query_format_str, data, 0);
 
   return src;
@@ -243,7 +243,7 @@ static void query_entry (char *s, size_t slen, MUTTMENU *m, int num)
 
   entry->data->num = num;
   mutt_FormatString (s, slen, 0, MuttIndexWindow->cols, NONULL (QueryFormat), query_format_str,
-		     (unsigned long) entry, M_FORMAT_ARROWCURSOR);
+		     (unsigned long) entry, MUTT_FORMAT_ARROWCURSOR);
 }
 
 static int query_tag (MUTTMENU *menu, int n, int m)
diff --git a/recvattach.c b/recvattach.c
index 9d1c7b6..bcbab63 100644
--- a/recvattach.c
+++ b/recvattach.c
@@ -72,9 +72,9 @@ void mutt_update_tree (ATTACHPTR **idx, short idxlen)
       if (idx[x]->level)
       {
 	s = buf + 2 * (idx[x]->level - 1);
-	*s++ = (idx[x]->content->next) ? M_TREE_LTEE : M_TREE_LLCORNER;
-	*s++ = M_TREE_HLINE;
-	*s++ = M_TREE_RARROW;
+	*s++ = (idx[x]->content->next) ? MUTT_TREE_LTEE : MUTT_TREE_LLCORNER;
+	*s++ = MUTT_TREE_HLINE;
+	*s++ = MUTT_TREE_RARROW;
       }
       else
 	s = buf;
@@ -186,7 +186,7 @@ const char *mutt_attach_fmt (char *dest,
   char tmp[SHORT_STRING];
   char charset[SHORT_STRING];
   ATTACHPTR *aptr = (ATTACHPTR *) data;
-  int optional = (flags & M_FORMAT_OPTIONAL);
+  int optional = (flags & MUTT_FORMAT_OPTIONAL);
   size_t l;
   
   switch (op)
@@ -228,7 +228,7 @@ const char *mutt_attach_fmt (char *dest,
 	{
 	  char s[SHORT_STRING];
 	  _mutt_make_string (s, sizeof (s), MsgFmt, NULL, aptr->content->hdr,
-			     M_FORMAT_FORCESUBJ | M_FORMAT_MAKEPRINT | M_FORMAT_ARROWCURSOR);
+			     MUTT_FORMAT_FORCESUBJ | MUTT_FORMAT_MAKEPRINT | MUTT_FORMAT_ARROWCURSOR);
 	  if (*s)
 	  {
 	    mutt_format_s (dest, destlen, prefix, s);
@@ -316,7 +316,7 @@ const char *mutt_attach_fmt (char *dest,
       }
       break;
     case 's':
-      if (flags & M_FORMAT_STAT_FILE)
+      if (flags & MUTT_FORMAT_STAT_FILE)
       {
 	struct stat st;
 	stat (aptr->content->filename, &st);
@@ -367,14 +367,14 @@ const char *mutt_attach_fmt (char *dest,
   
   if (optional)
     mutt_FormatString (dest, destlen, col, cols, ifstring, mutt_attach_fmt, data, 0);
-  else if (flags & M_FORMAT_OPTIONAL)
+  else if (flags & MUTT_FORMAT_OPTIONAL)
     mutt_FormatString (dest, destlen, col, cols, elsestring, mutt_attach_fmt, data, 0);
   return (src);
 }
 
 static void attach_entry (char *b, size_t blen, MUTTMENU *menu, int num)
 {
-  mutt_FormatString (b, blen, 0, MuttIndexWindow->cols, NONULL (AttachFormat), mutt_attach_fmt, (unsigned long) (((ATTACHPTR **)menu->data)[num]), M_FORMAT_ARROWCURSOR);
+  mutt_FormatString (b, blen, 0, MuttIndexWindow->cols, NONULL (AttachFormat), mutt_attach_fmt, (unsigned long) (((ATTACHPTR **)menu->data)[num]), MUTT_FORMAT_ARROWCURSOR);
 }
 
 int mutt_tag_attach (MUTTMENU *menu, int n, int m)
@@ -441,7 +441,7 @@ static int mutt_query_save_attachment (FILE *fp, BODY *body, HEADER *hdr, char *
   prompt = _("Save to file: ");
   while (prompt)
   {
-    if (mutt_get_field (prompt, buf, sizeof (buf), M_FILE | M_CLEAR) != 0
+    if (mutt_get_field (prompt, buf, sizeof (buf), MUTT_FILE | MUTT_CLEAR) != 0
 	|| !buf[0])
     {
       mutt_clear_error ();
@@ -521,7 +521,7 @@ void mutt_save_attachment_list (FILE *fp, int tag, BODY *top, HEADER *hdr, MUTTM
 	  prepend_curdir (buf, sizeof (buf));
 
 	  if (mutt_get_field (_("Save to file: "), buf, sizeof (buf),
-				    M_FILE | M_CLEAR) != 0 || !buf[0])
+				    MUTT_FILE | MUTT_CLEAR) != 0 || !buf[0])
 	    return;
 	  mutt_expand_path (buf, sizeof (buf));
 	  if (mutt_check_overwrite (top->filename, buf, tfile,
@@ -536,7 +536,7 @@ void mutt_save_attachment_list (FILE *fp, int tag, BODY *top, HEADER *hdr, MUTTM
 	}
 	else
 	{
-	  rc = mutt_save_attachment (fp, top, tfile, M_SAVE_APPEND, hdr);
+	  rc = mutt_save_attachment (fp, top, tfile, MUTT_SAVE_APPEND, hdr);
 	  if (rc == 0 && AttachSep && (fpout = fopen (tfile,"a")) != NULL)
 	  {
 	    fprintf(fpout, "%s", AttachSep);
@@ -590,7 +590,7 @@ mutt_query_pipe_attachment (char *command, FILE *fp, BODY *body, int filter)
     snprintf (warning, sizeof (warning),
 	      _("WARNING!  You are about to overwrite %s, continue?"),
 	      body->filename);
-    if (mutt_yesorno (warning, M_NO) != M_YES) {
+    if (mutt_yesorno (warning, MUTT_NO) != MUTT_YES) {
       mutt_window_clearline (MuttMessageWindow, 0);
       return;
     }
@@ -674,7 +674,7 @@ void mutt_pipe_attachment_list (FILE *fp, int tag, BODY *top, int filter)
   memset (&state, 0, sizeof (STATE));
 
   if (mutt_get_field ((filter ? _("Filter through: ") : _("Pipe to: ")),
-				  buf, sizeof (buf), M_CMD) != 0 || !buf[0])
+				  buf, sizeof (buf), MUTT_CMD) != 0 || !buf[0])
     return;
 
   mutt_expand_path (buf, sizeof (buf));
@@ -701,7 +701,7 @@ static int can_print (BODY *top, int tag)
     snprintf (type, sizeof (type), "%s/%s", TYPE (top), top->subtype);
     if (!tag || top->tagged)
     {
-      if (!rfc1524_mailcap_lookup (top, type, NULL, M_PRINT))
+      if (!rfc1524_mailcap_lookup (top, type, NULL, MUTT_PRINT))
       {
 	if (ascii_strcasecmp ("text/plain", top->subtype) &&
 	    ascii_strcasecmp ("application/postscript", top->subtype))
@@ -732,7 +732,7 @@ static void print_attachment_list (FILE *fp, int tag, BODY *top, STATE *state)
     if (!tag || top->tagged)
     {
       snprintf (type, sizeof (type), "%s/%s", TYPE (top), top->subtype);
-      if (!option (OPTATTACHSPLIT) && !rfc1524_mailcap_lookup (top, type, NULL, M_PRINT))
+      if (!option (OPTATTACHSPLIT) && !rfc1524_mailcap_lookup (top, type, NULL, MUTT_PRINT))
       {
 	if (!ascii_strcasecmp ("text/plain", top->subtype) ||
 	    !ascii_strcasecmp ("application/postscript", top->subtype))
@@ -745,7 +745,7 @@ static void print_attachment_list (FILE *fp, int tag, BODY *top, STATE *state)
 	  FILE *ifp;
 
 	  mutt_mktemp (newfile, sizeof (newfile));
-	  if (mutt_decode_save_attachment (fp, top, newfile, M_PRINTING, 0) == 0)
+	  if (mutt_decode_save_attachment (fp, top, newfile, MUTT_PRINTING, 0) == 0)
 	  {
 	    if ((ifp = fopen (newfile, "r")) != NULL)
 	    {
@@ -773,7 +773,7 @@ void mutt_print_attachment_list (FILE *fp, int tag, BODY *top)
   STATE state;
   
   pid_t thepid;
-  if (query_quadoption (OPT_PRINT, tag ? _("Print tagged attachment(s)?") : _("Print attachment?")) != M_YES)
+  if (query_quadoption (OPT_PRINT, tag ? _("Print tagged attachment(s)?") : _("Print attachment?")) != MUTT_YES)
     return;
 
   if (!option (OPTATTACHSPLIT))
@@ -835,7 +835,7 @@ mutt_attach_display_loop (MUTTMENU *menu, int op, FILE *fp, HEADER *hdr,
 	/* fall through */
 
       case OP_VIEW_ATTACH:
-	op = mutt_view_attachment (fp, idx[menu->current]->content, M_REGULAR,
+	op = mutt_view_attachment (fp, idx[menu->current]->content, MUTT_REGULAR,
 				   hdr, idx, *idxlen);
 	break;
 
@@ -953,7 +953,7 @@ void mutt_view_attachments (HEADER *hdr)
   /* make sure we have parsed this message */
   mutt_parse_mime_message (Context, hdr);
 
-  mutt_message_hook (Context, hdr, M_MESSAGEHOOK);
+  mutt_message_hook (Context, hdr, MUTT_MESSAGEHOOK);
   
   if ((msg = mx_open_message (Context, hdr->msgno)) == NULL)
     return;
@@ -1035,13 +1035,13 @@ void mutt_view_attachments (HEADER *hdr)
     switch (op)
     {
       case OP_ATTACH_VIEW_MAILCAP:
-	mutt_view_attachment (fp, idx[menu->current]->content, M_MAILCAP,
+	mutt_view_attachment (fp, idx[menu->current]->content, MUTT_MAILCAP,
 			      hdr, idx, idxlen);
 	menu->redraw = REDRAW_FULL;
 	break;
 
       case OP_ATTACH_VIEW_TEXT:
-	mutt_view_attachment (fp, idx[menu->current]->content, M_AS_TEXT,
+	mutt_view_attachment (fp, idx[menu->current]->content, MUTT_AS_TEXT,
 			      hdr, idx, idxlen);
 	menu->redraw = REDRAW_FULL;
 	break;
@@ -1113,7 +1113,7 @@ void mutt_view_attachments (HEADER *hdr)
 	CHECK_READONLY;
 
 #ifdef USE_POP
-	if (Context->magic == M_POP)
+	if (Context->magic == MUTT_POP)
 	{
 	  mutt_flushinp ();
 	  mutt_error _("Can't delete attachment from POP server.");
@@ -1122,7 +1122,7 @@ void mutt_view_attachments (HEADER *hdr)
 #endif
 
 #ifdef USE_NNTP
-	if (Context->magic == M_NNTP)
+	if (Context->magic == MUTT_NNTP)
 	{
 	  mutt_flushinp ();
 	  mutt_error _("Can't delete attachment from news server.");
@@ -1241,7 +1241,7 @@ void mutt_view_attachments (HEADER *hdr)
 
 	if (!idx[menu->current]->content->hdr->env->followup_to ||
 	    mutt_strcasecmp (idx[menu->current]->content->hdr->env->followup_to, "poster") ||
-	    query_quadoption (OPT_FOLLOWUPTOPOSTER,_("Reply by mail as poster prefers?")) != M_YES)
+	    query_quadoption (OPT_FOLLOWUPTOPOSTER,_("Reply by mail as poster prefers?")) != MUTT_YES)
 	{
 	  mutt_attach_reply (fp, hdr, idx, idxlen,
 		menu->tagprefix ? NULL : idx[menu->current]->content,
diff --git a/recvcmd.c b/recvcmd.c
index 8ac7cac..7f310be 100644
--- a/recvcmd.c
+++ b/recvcmd.c
@@ -173,7 +173,7 @@ void mutt_attach_bounce (FILE * fp, HEADER * hdr,
     strfcpy (prompt, _("Bounce tagged messages to: "), sizeof (prompt));
 
   buf[0] = '\0';
-  if (mutt_get_field (prompt, buf, sizeof (buf), M_ALIAS) 
+  if (mutt_get_field (prompt, buf, sizeof (buf), MUTT_ALIAS) 
       || buf[0] == '\0')
     return;
 
@@ -213,7 +213,7 @@ void mutt_attach_bounce (FILE * fp, HEADER * hdr,
   else
     safe_strcat (prompt, sizeof (prompt), "?");
 
-  if (query_quadoption (OPT_BOUNCE, prompt) != M_YES)
+  if (query_quadoption (OPT_BOUNCE, prompt) != MUTT_YES)
   {
     rfc822_free_address (&adr);
     mutt_window_clearline (MuttMessageWindow, 0);
@@ -469,7 +469,7 @@ static void attach_forward_bodies (FILE * fp, HEADER * hdr,
 
   if ((!cur || mutt_can_decode (cur)) &&
       (rc = query_quadoption (OPT_MIMEFWD, 
-			      _("Forward as attachments?"))) == M_YES)
+			      _("Forward as attachments?"))) == MUTT_YES)
     mime_fwd_all = 1;
   else if (rc == -1)
     goto bail;
@@ -485,7 +485,7 @@ static void attach_forward_bodies (FILE * fp, HEADER * hdr,
     if ((rc = query_quadoption (OPT_MIMEFWDREST,
 _("Can't decode all tagged attachments.  MIME-forward the others?"))) == -1)
       goto bail;
-    else if (rc == M_NO)
+    else if (rc == MUTT_NO)
       mime_fwd_any = 0;
   }
 
@@ -495,9 +495,9 @@ _("Can't decode all tagged attachments.  MIME-forward the others?"))) == -1)
   
   if (option (OPTFORWQUOTE))
     st.prefix = prefix;
-  st.flags = M_CHARCONV;
+  st.flags = MUTT_CHARCONV;
   if (option (OPTWEED))
-    st.flags |= M_WEED;
+    st.flags |= MUTT_WEED;
   st.fpin = fp;
   st.fpout = tmpfp;
 
@@ -608,7 +608,7 @@ static void attach_forward_msgs (FILE * fp, HEADER * hdr,
   tmpbody[0] = '\0';
 
   if ((rc = query_quadoption (OPT_MIMEFWD, 
-		 _("Forward MIME encapsulated?"))) == M_NO)
+		 _("Forward MIME encapsulated?"))) == MUTT_NO)
   {
     
     /* no MIME encapsulation */
@@ -624,23 +624,23 @@ static void attach_forward_msgs (FILE * fp, HEADER * hdr,
     if (option (OPTFORWQUOTE))
     {
       chflags |= CH_PREFIX;
-      cmflags |= M_CM_PREFIX;
+      cmflags |= MUTT_CM_PREFIX;
     }
 
     if (option (OPTFORWDECODE))
     {
-      cmflags |= M_CM_DECODE | M_CM_CHARCONV;
+      cmflags |= MUTT_CM_DECODE | MUTT_CM_CHARCONV;
       if (option (OPTWEED))
       {
 	chflags |= CH_WEED | CH_REORDER;
-	cmflags |= M_CM_WEED;
+	cmflags |= MUTT_CM_WEED;
       }
     }
     
     
     if (cur)
     {
-      /* mutt_message_hook (cur->hdr, M_MESSAGEHOOK); */ 
+      /* mutt_message_hook (cur->hdr, MUTT_MESSAGEHOOK); */ 
       mutt_forward_intro (tmpfp, cur->hdr);
       _mutt_copy_message (tmpfp, fp, cur->hdr, cur->hdr->content, cmflags, chflags);
       mutt_forward_trailer (tmpfp);
@@ -651,7 +651,7 @@ static void attach_forward_msgs (FILE * fp, HEADER * hdr,
       {
 	if (idx[i]->content->tagged)
 	{
-	  /* mutt_message_hook (idx[i]->content->hdr, M_MESSAGEHOOK); */ 
+	  /* mutt_message_hook (idx[i]->content->hdr, MUTT_MESSAGEHOOK); */ 
 	  mutt_forward_intro (tmpfp, idx[i]->content->hdr);
 	  _mutt_copy_message (tmpfp, fp, idx[i]->content->hdr,
 			      idx[i]->content->hdr->content, cmflags, chflags);
@@ -661,7 +661,7 @@ static void attach_forward_msgs (FILE * fp, HEADER * hdr,
     }
     safe_fclose (&tmpfp);
   }
-  else if (rc == M_YES)	/* do MIME encapsulation - we don't need to do much here */
+  else if (rc == MUTT_YES)	/* do MIME encapsulation - we don't need to do much here */
   {
     last = &tmphdr->content;
     if (cur)
@@ -810,19 +810,19 @@ attach_reply_envelope_defaults (ENVELOPE *env, ATTACHPTR **idx, short idxlen,
 
 static void attach_include_reply (FILE *fp, FILE *tmpfp, HEADER *cur, int flags)
 {
-  int cmflags = M_CM_PREFIX | M_CM_DECODE | M_CM_CHARCONV;
+  int cmflags = MUTT_CM_PREFIX | MUTT_CM_DECODE | MUTT_CM_CHARCONV;
   int chflags = CH_DECODE;
 
-  /* mutt_message_hook (cur, M_MESSAGEHOOK); */ 
+  /* mutt_message_hook (cur, MUTT_MESSAGEHOOK); */ 
   
   mutt_make_attribution (Context, cur, tmpfp);
   
   if (!option (OPTHEADER))
-    cmflags |= M_CM_NOHEADER;
+    cmflags |= MUTT_CM_NOHEADER;
   if (option (OPTWEED))
   {
     chflags |= CH_WEED;
-    cmflags |= M_CM_WEED;
+    cmflags |= MUTT_CM_WEED;
   }
 
   _mutt_copy_message (tmpfp, fp, cur, cur->content, cmflags, chflags);
@@ -866,7 +866,7 @@ void mutt_attach_reply (FILE * fp, HEADER * hdr,
     if ((rc = query_quadoption (OPT_MIMEFWDREST,
       _("Can't decode all tagged attachments.  MIME-encapsulate the others?"))) == -1)
       return;
-    else if (rc == M_YES)
+    else if (rc == MUTT_YES)
       mime_reply_any = 1;
   }
   else if (nattach == 1)
@@ -918,10 +918,10 @@ void mutt_attach_reply (FILE * fp, HEADER * hdr,
       strfcpy (prefix, ">", sizeof (prefix));
 
     st.prefix = prefix;
-    st.flags  = M_CHARCONV;
+    st.flags  = MUTT_CHARCONV;
     
     if (option (OPTWEED)) 
-      st.flags |= M_WEED;
+      st.flags |= MUTT_WEED;
 
     if (option (OPTHEADER))
       include_header (1, fp, parent, tmpfp, prefix);
@@ -963,6 +963,6 @@ void mutt_attach_reply (FILE * fp, HEADER * hdr,
   
   if (ci_send_message (flags, tmphdr, tmpbody, NULL,
 			  parent ? parent : (cur ? cur->hdr : NULL)) == 0)
-    mutt_set_flag (Context, hdr, M_REPLIED, 1);
+    mutt_set_flag (Context, hdr, MUTT_REPLIED, 1);
 }
 
diff --git a/remailer.c b/remailer.c
index 51384f7..8f4e859 100644
--- a/remailer.c
+++ b/remailer.c
@@ -388,7 +388,7 @@ static const char *mix_entry_fmt (char *dest,
 {
   char fmt[16];
   REMAILER *remailer = (REMAILER *) data;
-  int optional = (flags & M_FORMAT_OPTIONAL);
+  int optional = (flags & MUTT_FORMAT_OPTIONAL);
 
   switch (op)
   {
@@ -431,7 +431,7 @@ static const char *mix_entry_fmt (char *dest,
 
   if (optional)
     mutt_FormatString (dest, destlen, col, cols, ifstring, mutt_attach_fmt, data, 0);
-  else if (flags & M_FORMAT_OPTIONAL)
+  else if (flags & MUTT_FORMAT_OPTIONAL)
     mutt_FormatString (dest, destlen, col, cols, elsestring, mutt_attach_fmt, data, 0);
   return (src);
 }
@@ -442,7 +442,7 @@ static void mix_entry (char *b, size_t blen, MUTTMENU *menu, int num)
 {
   REMAILER **type2_list = (REMAILER **) menu->data;
   mutt_FormatString (b, blen, 0, MuttIndexWindow->cols, NONULL (MixEntryFormat), mix_entry_fmt,
-		     (unsigned long) type2_list[num], M_FORMAT_ARROWCURSOR);
+		     (unsigned long) type2_list[num], MUTT_FORMAT_ARROWCURSOR);
 }
 
 static int mix_chain_add (MIXCHAIN *chain, const char *s, 
diff --git a/rfc1524.c b/rfc1524.c
index 5954e0b..330e7ec 100644
--- a/rfc1524.c
+++ b/rfc1524.c
@@ -204,7 +204,7 @@ static int rfc1524_mailcap_parse (BODY *a,
 
   if ((fp = fopen (filename, "r")) != NULL)
   {
-    while (!found && (buf = mutt_read_line (buf, &buflen, fp, &line, M_CONT)) != NULL)
+    while (!found && (buf = mutt_read_line (buf, &buflen, fp, &line, MUTT_CONT)) != NULL)
     {
       /* ignore comments */
       if (*buf == '#')
@@ -309,22 +309,22 @@ static int rfc1524_mailcap_parse (BODY *a,
 	}
       } /* while (ch) */
 
-      if (opt == M_AUTOVIEW)
+      if (opt == MUTT_AUTOVIEW)
       {
 	if (!copiousoutput)
 	  found = FALSE;
       }
-      else if (opt == M_COMPOSE)
+      else if (opt == MUTT_COMPOSE)
       {
 	if (!composecommand)
 	  found = FALSE;
       }
-      else if (opt == M_EDIT)
+      else if (opt == MUTT_EDIT)
       {
 	if (!editcommand)
 	  found = FALSE;
       }
-      else if (opt == M_PRINT)
+      else if (opt == MUTT_PRINT)
       {
 	if (!printcommand)
 	  found = FALSE;
diff --git a/rfc2047.c b/rfc2047.c
index aa02422..505cc91 100644
--- a/rfc2047.c
+++ b/rfc2047.c
@@ -120,7 +120,7 @@ int convert_nonmime_string (char **ps)
   }
   mutt_convert_string (ps,
       (const char *)mutt_get_default_charset (),
-      Charset, M_ICONV_HOOK_FROM);
+      Charset, MUTT_ICONV_HOOK_FROM);
   return -1;
 }
 
@@ -713,7 +713,7 @@ static int rfc2047_decode_word (char *d, const char *s, size_t len)
   }
   
   if (charset)
-    mutt_convert_string (&d0, charset, Charset, M_ICONV_HOOK_FROM);
+    mutt_convert_string (&d0, charset, Charset, MUTT_ICONV_HOOK_FROM);
   mutt_filter_unprintable (&d0);
   strfcpy (d, d0, len);
   rv = 0;
diff --git a/rfc2231.c b/rfc2231.c
index 3a3a8fd..05e81c3 100644
--- a/rfc2231.c
+++ b/rfc2231.c
@@ -130,7 +130,7 @@ void rfc2231_decode_parameters (PARAMETER **headp)
       
       s = rfc2231_get_charset (p->value, charset, sizeof (charset));
       rfc2231_decode_one (p->value, s);
-      mutt_convert_string (&p->value, charset, Charset, M_ICONV_HOOK_FROM);
+      mutt_convert_string (&p->value, charset, Charset, MUTT_ICONV_HOOK_FROM);
       mutt_filter_unprintable (&p->value);
 
       *last = p;
@@ -302,7 +302,7 @@ static void rfc2231_join_continuations (PARAMETER **head,
     if (value)
     {
       if (encoded)
-	mutt_convert_string (&value, charset, Charset, M_ICONV_HOOK_FROM);
+	mutt_convert_string (&value, charset, Charset, MUTT_ICONV_HOOK_FROM);
       *head = mutt_new_parameter ();
       (*head)->attribute = safe_strdup (attribute);
       (*head)->value = value;
diff --git a/rfc3676.c b/rfc3676.c
index 5ce9ffd..529bd31 100644
--- a/rfc3676.c
+++ b/rfc3676.c
@@ -71,7 +71,7 @@ static int space_quotes (STATE *s)
   /* Allow quote spacing in the pager even for OPTTEXTFLOWED,
    * but obviously not when replying.
    */
-  if (option (OPTTEXTFLOWED) && (s->flags & M_REPLYING))
+  if (option (OPTTEXTFLOWED) && (s->flags & MUTT_REPLYING))
     return 0;
 
   return option (OPTREFLOWSPACEQUOTES);
@@ -84,7 +84,7 @@ static int space_quotes (STATE *s)
  */
 static int add_quote_suffix (STATE *s, int ql)
 {
-  if (s->flags & M_REPLYING)
+  if (s->flags & MUTT_REPLYING)
     return 0;
 
   if (space_quotes (s))
@@ -149,7 +149,7 @@ static void flush_par (STATE *s, flowed_state_t *fst)
 static int quote_width (STATE *s, int ql)
 {
   int width = mutt_window_wrap_cols (MuttIndexWindow, ReflowWrap);
-  if (option(OPTTEXTFLOWED) && (s->flags & M_REPLYING))
+  if (option(OPTTEXTFLOWED) && (s->flags & MUTT_REPLYING))
   {
     /* When replying, force a wrap at FLOWED_MAX to comply with RFC3676
      * guidelines */
diff --git a/score.c b/score.c
index 6f952a5..50e9cb8 100644
--- a/score.c
+++ b/score.c
@@ -147,11 +147,11 @@ void mutt_score_message (CONTEXT *ctx, HEADER *hdr, int upd_ctx)
     hdr->score = 0;
   
   if (hdr->score <= ScoreThresholdDelete)
-    _mutt_set_flag (ctx, hdr, M_DELETE, 1, upd_ctx);
+    _mutt_set_flag (ctx, hdr, MUTT_DELETE, 1, upd_ctx);
   if (hdr->score <= ScoreThresholdRead)
-    _mutt_set_flag (ctx, hdr, M_READ, 1, upd_ctx);
+    _mutt_set_flag (ctx, hdr, MUTT_READ, 1, upd_ctx);
   if (hdr->score >= ScoreThresholdFlag)
-    _mutt_set_flag (ctx, hdr, M_FLAG, 1, upd_ctx);
+    _mutt_set_flag (ctx, hdr, MUTT_FLAG, 1, upd_ctx);
 }
 
 int mutt_parse_unscore (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
diff --git a/send.c b/send.c
index a00ccb4..fde4b65 100644
--- a/send.c
+++ b/send.c
@@ -205,7 +205,7 @@ static int edit_address (ADDRESS **a, /* const */ char *field)
     buf[0] = 0;
     mutt_addrlist_to_local (*a);
     rfc822_write_address (buf, sizeof (buf), *a, 0);
-    if (mutt_get_field (field, buf, sizeof (buf), M_ALIAS) != 0)
+    if (mutt_get_field (field, buf, sizeof (buf), MUTT_ALIAS) != 0)
       return (-1);
     rfc822_free_address (a);
     *a = mutt_expand_aliases (mutt_parse_adrlist (NULL, buf));
@@ -290,7 +290,7 @@ static int edit_envelope (ENVELOPE *en, int flags)
   }
   
   if (mutt_get_field ("Subject: ", buf, sizeof (buf), 0) != 0 ||
-      (!buf[0] && query_quadoption (OPT_SUBJECT, _("No subject, abort?")) != M_NO))
+      (!buf[0] && query_quadoption (OPT_SUBJECT, _("No subject, abort?")) != MUTT_NO))
   {
     mutt_message _("No subject, aborting.");
     return (-1);
@@ -429,7 +429,7 @@ static int include_forward (CONTEXT *ctx, HEADER *cur, FILE *out)
   int chflags = CH_DECODE, cmflags = 0;
   
   mutt_parse_mime_message (ctx, cur);
-  mutt_message_hook (ctx, cur, M_MESSAGEHOOK);
+  mutt_message_hook (ctx, cur, MUTT_MESSAGEHOOK);
 
   if (WithCrypto && (cur->security & ENCRYPT) && option (OPTFORWDECODE))
   {
@@ -441,15 +441,15 @@ static int include_forward (CONTEXT *ctx, HEADER *cur, FILE *out)
 
   if (option (OPTFORWDECODE))
   {
-    cmflags |= M_CM_DECODE | M_CM_CHARCONV;
+    cmflags |= MUTT_CM_DECODE | MUTT_CM_CHARCONV;
     if (option (OPTWEED))
     {
       chflags |= CH_WEED | CH_REORDER;
-      cmflags |= M_CM_WEED;
+      cmflags |= MUTT_CM_WEED;
     }
   }
   if (option (OPTFORWQUOTE))
-    cmflags |= M_CM_PREFIX;
+    cmflags |= MUTT_CM_PREFIX;
 
   /* wrapping headers for forwarding is considered a display
    * rather than send action */
@@ -484,7 +484,7 @@ void mutt_make_post_indent (CONTEXT *ctx, HEADER *cur, FILE *out)
 
 static int include_reply (CONTEXT *ctx, HEADER *cur, FILE *out)
 {
-  int cmflags = M_CM_PREFIX | M_CM_DECODE | M_CM_CHARCONV | M_CM_REPLYING;
+  int cmflags = MUTT_CM_PREFIX | MUTT_CM_DECODE | MUTT_CM_CHARCONV | MUTT_CM_REPLYING;
   int chflags = CH_DECODE;
 
   if (WithCrypto && (cur->security & ENCRYPT))
@@ -494,16 +494,16 @@ static int include_reply (CONTEXT *ctx, HEADER *cur, FILE *out)
   }
 
   mutt_parse_mime_message (ctx, cur);
-  mutt_message_hook (ctx, cur, M_MESSAGEHOOK);
+  mutt_message_hook (ctx, cur, MUTT_MESSAGEHOOK);
   
   mutt_make_attribution (ctx, cur, out);
   
   if (!option (OPTHEADER))
-    cmflags |= M_CM_NOHEADER;
+    cmflags |= MUTT_CM_NOHEADER;
   if (option (OPTWEED))
   {
     chflags |= CH_WEED | CH_REORDER;
-    cmflags |= M_CM_WEED;
+    cmflags |= MUTT_CM_WEED;
   }
 
   mutt_copy_message (out, ctx, cur, cmflags, chflags);
@@ -517,7 +517,7 @@ static int default_to (ADDRESS **to, ENVELOPE *env, int flags, int hmfupto)
 {
   char prompt[STRING];
 
-  if (flags && env->mail_followup_to && hmfupto == M_YES) 
+  if (flags && env->mail_followup_to && hmfupto == MUTT_YES) 
   {
     rfc822_append (to, env->mail_followup_to, 1);
     return 0;
@@ -554,7 +554,7 @@ static int default_to (ADDRESS **to, ENVELOPE *env, int flags, int hmfupto)
     }
     else if (!(mutt_addrcmp (env->from, env->reply_to) && 
 	       !env->reply_to->next) &&
-	     quadoption (OPT_REPLYTO) != M_YES)
+	     quadoption (OPT_REPLYTO) != MUTT_YES)
     {
       /* There are quite a few mailing lists which set the Reply-To:
        * header field to the list address, which makes it quite impossible
@@ -569,11 +569,11 @@ static int default_to (ADDRESS **to, ENVELOPE *env, int flags, int hmfupto)
 		env->reply_to->next?",...":"");
       switch (query_quadoption (OPT_REPLYTO, prompt))
       {
-      case M_YES:
+      case MUTT_YES:
 	rfc822_append (to, env->reply_to, 0);
 	break;
 
-      case M_NO:
+      case MUTT_NO:
 	rfc822_append (to, env->from, 0);
 	break;
 
@@ -612,7 +612,7 @@ int mutt_fetch_recips (ENVELOPE *out, ENVELOPE *in, int flags)
     rfc822_append (&out->to, tmp, 0);
     rfc822_free_address (&tmp);
 
-    if (in->mail_followup_to && hmfupto == M_YES &&
+    if (in->mail_followup_to && hmfupto == MUTT_YES &&
         default_to (&out->cc, in, flags & SENDLISTREPLY, hmfupto) == -1)
       return (-1); /* abort */
   }
@@ -621,7 +621,7 @@ int mutt_fetch_recips (ENVELOPE *out, ENVELOPE *in, int flags)
     if (default_to (&out->to, in, flags & SENDGROUPREPLY, hmfupto) == -1)
       return (-1); /* abort */
 
-    if ((flags & SENDGROUPREPLY) && (!in->mail_followup_to || hmfupto != M_YES))
+    if ((flags & SENDGROUPREPLY) && (!in->mail_followup_to || hmfupto != MUTT_YES))
     {
       /* if(!mutt_addr_is_user(in->to)) */
       rfc822_append (&out->cc, in->to, 1);
@@ -844,7 +844,7 @@ generate_body (FILE *tempfp,	/* stream for outgoing message */
     if ((i = query_quadoption (OPT_INCLUDE, _("Include message in reply?"))) == -1)
       return (-1);
 
-    if (i == M_YES)
+    if (i == MUTT_YES)
     {
       mutt_message _("Including quoted message...");
       if (!cur)
@@ -870,7 +870,7 @@ generate_body (FILE *tempfp,	/* stream for outgoing message */
   }
   else if (flags & SENDFORWARD)
   {
-    if ((i = query_quadoption (OPT_MIMEFWD, _("Forward as attachment?"))) == M_YES)
+    if ((i = query_quadoption (OPT_MIMEFWD, _("Forward as attachment?"))) == MUTT_YES)
     {
       BODY *last = msg->content;
 
@@ -1267,7 +1267,7 @@ ci_send_message (int flags,		/* send mode */
     unset_option (OPTNEWSSEND);
 #endif
 
-  if (!flags && !msg && quadoption (OPT_RECALL) != M_NO &&
+  if (!flags && !msg && quadoption (OPT_RECALL) != MUTT_NO &&
       mutt_num_postponed (1))
   {
     /* If the user is composing a new message, check to see if there
@@ -1276,7 +1276,7 @@ ci_send_message (int flags,		/* send mode */
     if ((i = query_quadoption (OPT_RECALL, _("Recall postponed message?"))) == -1)
       return rv;
 
-    if(i == M_YES)
+    if(i == MUTT_YES)
       flags |= SENDPOSTPONED;
   }
   
@@ -1420,7 +1420,7 @@ ci_send_message (int flags,		/* send mode */
       mutt_fix_reply_recipients (msg->env);
 
 #ifdef USE_NNTP
-    if ((flags & SENDNEWS) && ctx && ctx->magic == M_NNTP && !msg->env->newsgroups)
+    if ((flags & SENDNEWS) && ctx && ctx->magic == MUTT_NNTP && !msg->env->newsgroups)
       msg->env->newsgroups = safe_strdup (((NNTP_DATA *)ctx->data)->group);
 #endif
 
@@ -1446,7 +1446,7 @@ ci_send_message (int flags,		/* send mode */
     if ((flags & SENDREPLY) && cur)
     {
       /* change setting based upon message we are replying to */
-      mutt_message_hook (ctx, cur, M_REPLYHOOK);
+      mutt_message_hook (ctx, cur, MUTT_REPLYHOOK);
 
       /*
        * set the replied flag for the message we are generating so that the
@@ -1458,7 +1458,7 @@ ci_send_message (int flags,		/* send mode */
 
     /* change settings based upon recipients */
     
-    mutt_message_hook (NULL, msg, M_SENDHOOK);
+    mutt_message_hook (NULL, msg, MUTT_SENDHOOK);
 
     /*
      * Unset the replied flag from the message we are composing since it is
@@ -1508,7 +1508,7 @@ ci_send_message (int flags,		/* send mode */
    * used for setting the editor, the sendmail path, or the
    * envelope sender.
    */
-  mutt_message_hook (NULL, msg, M_SEND2HOOK);
+  mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
 
   /* wait until now to set the real name portion of our return address so
      that $realname can be set in a send-hook */
@@ -1544,7 +1544,7 @@ ci_send_message (int flags,		/* send mode */
     if (! (flags & SENDKEY) &&
 	((flags & SENDFORWARD) == 0 ||
 	 (option (OPTEDITHDRS) && option (OPTAUTOEDIT)) ||
-	 query_quadoption (OPT_FORWEDIT, _("Edit forwarded message?")) == M_YES))
+	 query_quadoption (OPT_FORWEDIT, _("Edit forwarded message?")) == MUTT_YES))
     {
       /* If the this isn't a text message, look for a mailcap edit command */
       if (mutt_needs_mailcap (msg->content))
@@ -1584,7 +1584,7 @@ ci_send_message (int flags,		/* send mode */
 	  rfc3676_space_stuff (msg);
       }
 
-      mutt_message_hook (NULL, msg, M_SEND2HOOK);
+      mutt_message_hook (NULL, msg, MUTT_SEND2HOOK);
     }
 
     if (! (flags & (SENDPOSTPONED | SENDFORWARD | SENDKEY | SENDRESEND | SENDDRAFTFILE)))
@@ -1593,7 +1593,7 @@ ci_send_message (int flags,		/* send mode */
       {
 	/* if the file was not modified, bail out now */
 	if (mtime == st.st_mtime && !msg->content->next &&
-	    query_quadoption (OPT_ABORT, _("Abort unmodified message?")) == M_YES)
+	    query_quadoption (OPT_ABORT, _("Abort unmodified message?")) == MUTT_YES)
 	{
 	  mutt_message _("Aborted unmodified message.");
 	  goto cleanup;
@@ -1722,7 +1722,7 @@ main_loop:
     fcc_error = 0; /* reset value since we may have failed before */
     mutt_pretty_mailbox (fcc, sizeof (fcc));
     i = mutt_compose_menu (msg, fcc, sizeof (fcc), cur,
-                           (flags & SENDNOFREEHEADER ? M_COMPOSE_NOFREEHEADER : 0));
+                           (flags & SENDNOFREEHEADER ? MUTT_COMPOSE_NOFREEHEADER : 0));
     if (i == -1)
     {
       /* abort */
@@ -1817,10 +1817,10 @@ main_loop:
   }
   
   if (!msg->env->subject && ! (flags & SENDBATCH) &&
-      (i = query_quadoption (OPT_SUBJECT, _("No subject, abort sending?"))) != M_NO)
+      (i = query_quadoption (OPT_SUBJECT, _("No subject, abort sending?"))) != MUTT_NO)
   {
     /* if the abort is automatic, print an error message */
-    if (quadoption (OPT_SUBJECT) == M_YES)
+    if (quadoption (OPT_SUBJECT) == MUTT_YES)
       mutt_error _("No subject specified.");
     goto main_loop;
   }
@@ -1929,7 +1929,7 @@ main_loop:
       msg->content = clear_content;
 
     /* check to see if the user wants copies of all attachments */
-    if (query_quadoption (OPT_FCCATTACH, _("Save attachments in Fcc?")) != M_YES &&
+    if (query_quadoption (OPT_FCCATTACH, _("Save attachments in Fcc?")) != MUTT_YES &&
 	msg->content->type == TYPEMULTIPART)
     {
       if (WithCrypto
@@ -2068,12 +2068,12 @@ full_fcc:
   if (flags & SENDREPLY)
   {
     if (cur && ctx)
-      mutt_set_flag (ctx, cur, M_REPLIED, is_reply (cur, msg));
+      mutt_set_flag (ctx, cur, MUTT_REPLIED, is_reply (cur, msg));
     else if (!(flags & SENDPOSTPONED) && ctx && ctx->tagged)
     {
       for (i = 0; i < ctx->vcount; i++)
 	if (ctx->hdrs[ctx->v2r[i]]->tagged)
-	  mutt_set_flag (ctx, ctx->hdrs[ctx->v2r[i]], M_REPLIED,
+	  mutt_set_flag (ctx, ctx->hdrs[ctx->v2r[i]], MUTT_REPLIED,
 			 is_reply (ctx->hdrs[ctx->v2r[i]], msg));
     }
   }
diff --git a/sendlib.c b/sendlib.c
index cbd04dd..4350f1c 100644
--- a/sendlib.c
+++ b/sendlib.c
@@ -1293,7 +1293,7 @@ BODY *mutt_make_message_attach (CONTEXT *ctx, HEADER *hdr, int attach_msg)
   if (!attach_msg && option (OPTMIMEFORWDECODE))
   {
     chflags |= CH_MIME | CH_TXTPLAIN;
-    cmflags = M_CM_DECODE | M_CM_CHARCONV;
+    cmflags = MUTT_CM_DECODE | MUTT_CM_CHARCONV;
     if ((WithCrypto & APPLICATION_PGP))
       pgp &= ~PGPENCRYPT;
     if ((WithCrypto & APPLICATION_SMIME))
@@ -1306,21 +1306,21 @@ BODY *mutt_make_message_attach (CONTEXT *ctx, HEADER *hdr, int attach_msg)
         && mutt_is_multipart_encrypted (hdr->content))
     {
       chflags |= CH_MIME | CH_NONEWLINE;
-      cmflags = M_CM_DECODE_PGP;
+      cmflags = MUTT_CM_DECODE_PGP;
       pgp &= ~PGPENCRYPT;
     }
     else if ((WithCrypto & APPLICATION_PGP)
              && (mutt_is_application_pgp (hdr->content) & PGPENCRYPT))
     {
       chflags |= CH_MIME | CH_TXTPLAIN;
-      cmflags = M_CM_DECODE | M_CM_CHARCONV;
+      cmflags = MUTT_CM_DECODE | MUTT_CM_CHARCONV;
       pgp &= ~PGPENCRYPT;
     }
     else if ((WithCrypto & APPLICATION_SMIME)
               && mutt_is_application_smime (hdr->content) & SMIMEENCRYPT)
     {
       chflags |= CH_MIME | CH_TXTPLAIN;
-      cmflags = M_CM_DECODE | M_CM_CHARCONV;
+      cmflags = MUTT_CM_DECODE | MUTT_CM_CHARCONV;
       pgp &= ~SMIMEENCRYPT;
     }
   }
@@ -2771,7 +2771,7 @@ int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid,
   if (post)
     set_noconv_flags (hdr->content, 1);
 
-  if (mx_open_mailbox (path, M_APPEND | M_QUIET, &f) == NULL)
+  if (mx_open_mailbox (path, MUTT_APPEND | MUTT_QUIET, &f) == NULL)
   {
     dprint (1, (debugfile, "mutt_write_fcc(): unable to open mailbox %s in append-mode, aborting.\n",
 		path));
@@ -2781,7 +2781,7 @@ int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid,
   /* We need to add a Content-Length field to avoid problems where a line in
    * the message body begins with "From "
    */
-  if (f.magic == M_MMDF || f.magic == M_MBOX)
+  if (f.magic == MUTT_MMDF || f.magic == MUTT_MBOX)
   {
     mutt_mktemp (tempfile, sizeof (tempfile));
     if ((tempfp = safe_fopen (tempfile, "w+")) == NULL)
@@ -2796,9 +2796,9 @@ int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid,
   }
 
   hdr->read = !post; /* make sure to put it in the `cur' directory (maildir) */
-  onm_flags = M_ADD_FROM;
+  onm_flags = MUTT_ADD_FROM;
   if (post)
-    onm_flags |= M_SET_DRAFT;
+    onm_flags |= MUTT_SET_DRAFT;
   if ((msg = mx_open_new_message (&f, hdr, onm_flags)) == NULL)
   {
     mx_close_mailbox (&f, NULL);
@@ -2825,7 +2825,7 @@ int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid,
   if (post && fcc)
     fprintf (msg->fp, "X-Mutt-Fcc: %s\n", fcc);
 
-  if (f.magic == M_MMDF || f.magic == M_MBOX)
+  if (f.magic == MUTT_MMDF || f.magic == MUTT_MBOX)
     fprintf (msg->fp, "Status: RO\n");
 
   /* mutt_write_rfc822_header() only writes out a Date: header with
diff --git a/sidebar.c b/sidebar.c
index bf10cac..6c26fcf 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -161,7 +161,7 @@ find_prev_new (int wrap)
  * @ifstring:    If condition is met, display this string
  * @elsestring:  Otherwise, display this string
  * @data:        Pointer to our sidebar_entry
- * @flags:       Format flags, e.g. M_FORMAT_OPTIONAL
+ * @flags:       Format flags, e.g. MUTT_FORMAT_OPTIONAL
  *
  * cb_format_str is a callback function for mutt_FormatString.  It understands
  * five operators. '%B' : Mailbox name, '%F' : Number of flagged messages,
@@ -190,7 +190,7 @@ cb_format_str (char *dest, size_t destlen, size_t col, int cols, char op, const
 
 	int c = Context && (mutt_strcmp (Context->path, b->path) == 0);
 
-	optional = flags & M_FORMAT_OPTIONAL;
+	optional = flags & MUTT_FORMAT_OPTIONAL;
 
 	switch (op) {
 		case 'B':
@@ -267,7 +267,7 @@ cb_format_str (char *dest, size_t destlen, size_t col, int cols, char op, const
 
 	if (optional)
 		mutt_FormatString (dest, destlen, col, cols, ifstring,   cb_format_str, (unsigned long) sbe, flags);
-	else if (flags & M_FORMAT_OPTIONAL)
+	else if (flags & MUTT_FORMAT_OPTIONAL)
 		mutt_FormatString (dest, destlen, col, cols, elsestring, cb_format_str, (unsigned long) sbe, flags);
 
 	/* We return the format string, unchanged */
@@ -745,7 +745,7 @@ draw_sidebar (int num_rows, int num_cols, int div_width)
 			}
 		}
 #ifdef USE_NOTMUCH
-		else if (b->magic == M_NOTMUCH) {
+		else if (b->magic == MUTT_NOTMUCH) {
 			sidebar_folder_name = b->desc;
 		}
 #endif
diff --git a/smime.c b/smime.c
index 897c9e0..c68f7e8 100644
--- a/smime.c
+++ b/smime.c
@@ -170,7 +170,7 @@ static const char *_mutt_fmt_smime_command (char *dest,
 {
   char fmt[16];
   struct smime_command_context *cctx = (struct smime_command_context *) data;
-  int optional = (flags & M_FORMAT_OPTIONAL);
+  int optional = (flags & MUTT_FORMAT_OPTIONAL);
   
   switch (op)
   {
@@ -287,7 +287,7 @@ static const char *_mutt_fmt_smime_command (char *dest,
   if (optional)
     mutt_FormatString (dest, destlen, col, cols, ifstring, _mutt_fmt_smime_command,
 		       data, 0);
-  else if (flags & M_FORMAT_OPTIONAL)
+  else if (flags & MUTT_FORMAT_OPTIONAL)
     mutt_FormatString (dest, destlen, col, cols, elsestring, _mutt_fmt_smime_command,
 		       data, 0);
 
@@ -477,7 +477,7 @@ static smime_key_t *smime_select_key (smime_key_t *keys, char *query)
           snprintf (buf, sizeof (buf), _("%s Do you really want to use the key?"),
                     _(s));
 
-          if (mutt_yesorno (buf, M_NO) != M_YES)
+          if (mutt_yesorno (buf, MUTT_NO) != MUTT_YES)
           {
             mutt_clear_error ();
             break;
@@ -766,7 +766,7 @@ smime_key_t *smime_ask_for_key(char *prompt, short abilities, short public)
   FOREVER
   {
     resp[0] = 0;
-    if (mutt_get_field (prompt, resp, sizeof (resp), M_CLEAR) != 0)
+    if (mutt_get_field (prompt, resp, sizeof (resp), MUTT_CLEAR) != 0)
       return NULL;
 
     if ((key = smime_get_key_by_str (resp, abilities, public)))
@@ -1283,7 +1283,7 @@ int smime_verify_sender(HEADER *h)
 
   if(h->security & ENCRYPT)
     mutt_copy_message (fpout, Context, h,
-		       M_CM_DECODE_CRYPT & M_CM_DECODE_SMIME,
+		       MUTT_CM_DECODE_CRYPT & MUTT_CM_DECODE_SMIME,
 		       CH_MIME|CH_WEED|CH_NONEWLINE);
   else
     mutt_copy_message (fpout, Context, h, 0, 0);
@@ -1870,7 +1870,7 @@ static BODY *smime_handle_entity (BODY *m, STATE *s, FILE *outFile)
   {
     safe_fclose (&smimeout); smimeout = NULL;
     mutt_unlink (tmpfname);
-    if (s->flags & M_DISPLAY)
+    if (s->flags & MUTT_DISPLAY)
       state_attach_puts (_("[-- Error: unable to create OpenSSL subprocess! --]\n"), s);
     return NULL;
   }
@@ -1881,7 +1881,7 @@ static BODY *smime_handle_entity (BODY *m, STATE *s, FILE *outFile)
   {
     safe_fclose (&smimeout); smimeout = NULL;
     mutt_unlink (tmpfname);
-    if (s->flags & M_DISPLAY)
+    if (s->flags & MUTT_DISPLAY)
       state_attach_puts (_("[-- Error: unable to create OpenSSL subprocess! --]\n"), s);
     return NULL;
   }
@@ -1901,7 +1901,7 @@ static BODY *smime_handle_entity (BODY *m, STATE *s, FILE *outFile)
   mutt_unlink (tmpfname);
   
 
-  if (s->flags & M_DISPLAY)
+  if (s->flags & MUTT_DISPLAY)
   {
     fflush (smimeerr);
     rewind (smimeerr);
@@ -1980,7 +1980,7 @@ static BODY *smime_handle_entity (BODY *m, STATE *s, FILE *outFile)
     fpout = NULL;
   }
 
-  if (s->flags & M_DISPLAY)
+  if (s->flags & MUTT_DISPLAY)
   {
     if (type & ENCRYPT)
       state_attach_puts (_("\n[-- End of S/MIME encrypted data. --]\n"), s);
diff --git a/smtp.c b/smtp.c
index 3622075..1d147a5 100644
--- a/smtp.c
+++ b/smtp.c
@@ -185,7 +185,7 @@ smtp_data (CONNECTION * conn, const char *msgfile)
   }
   stat (msgfile, &st);
   unlink (msgfile);
-  mutt_progress_init (&progress, _("Sending message..."), M_PROGRESS_SIZE,
+  mutt_progress_init (&progress, _("Sending message..."), MUTT_PROGRESS_SIZE,
                       NetInc, st.st_size);
 
   snprintf (buf, sizeof (buf), "DATA\r\n");
@@ -208,13 +208,13 @@ smtp_data (CONNECTION * conn, const char *msgfile)
       snprintf (buf + buflen - 1, sizeof (buf) - buflen + 1, "\r\n");
     if (buf[0] == '.')
     {
-      if (mutt_socket_write_d (conn, ".", -1, M_SOCK_LOG_FULL) == -1)
+      if (mutt_socket_write_d (conn, ".", -1, MUTT_SOCK_LOG_FULL) == -1)
       {
         safe_fclose (&fp);
         return smtp_err_write;
       }
     }
-    if (mutt_socket_write_d (conn, buf, -1, M_SOCK_LOG_FULL) == -1)
+    if (mutt_socket_write_d (conn, buf, -1, MUTT_SOCK_LOG_FULL) == -1)
     {
       safe_fclose (&fp);
       return smtp_err_write;
@@ -222,7 +222,7 @@ smtp_data (CONNECTION * conn, const char *msgfile)
     mutt_progress_update (&progress, ftell (fp), -1);
   }
   if (!term && buflen &&
-      mutt_socket_write_d (conn, "\r\n", -1, M_SOCK_LOG_FULL) == -1)
+      mutt_socket_write_d (conn, "\r\n", -1, MUTT_SOCK_LOG_FULL) == -1)
   {
     safe_fclose (&fp);
     return smtp_err_write;
@@ -372,7 +372,7 @@ static int smtp_fill_account (ACCOUNT* account)
 
   account->flags = 0;
   account->port = 0;
-  account->type = M_ACCT_TYPE_SMTP;
+  account->type = MUTT_ACCT_TYPE_SMTP;
 
   urlstr = safe_strdup (SmtpUrl);
   url_parse_ciss (&url, urlstr);
@@ -387,11 +387,11 @@ static int smtp_fill_account (ACCOUNT* account)
   FREE (&urlstr);
 
   if (url.scheme == U_SMTPS)
-    account->flags |= M_ACCT_SSL;
+    account->flags |= MUTT_ACCT_SSL;
 
   if (!account->port)
   {
-    if (account->flags & M_ACCT_SSL)
+    if (account->flags & MUTT_ACCT_SSL)
       account->port = SMTPS_PORT;
     else
     {
@@ -421,10 +421,10 @@ static int smtp_helo (CONNECTION* conn)
   if (!Esmtp)
   {
     /* if TLS or AUTH are requested, use EHLO */
-    if (conn->account.flags & M_ACCT_USER)
+    if (conn->account.flags & MUTT_ACCT_USER)
       Esmtp = 1;
 #ifdef USE_SSL
-    if (option (OPTSSLFORCETLS) || quadoption (OPT_SSLSTARTTLS) != M_NO)
+    if (option (OPTSSLFORCETLS) || quadoption (OPT_SSLSTARTTLS) != MUTT_NO)
       Esmtp = 1;
 #endif
   }
@@ -458,15 +458,15 @@ static int smtp_open (CONNECTION* conn)
 
 #ifdef USE_SSL
   if (conn->ssf)
-    rc = M_NO;
+    rc = MUTT_NO;
   else if (option (OPTSSLFORCETLS))
-    rc = M_YES;
+    rc = MUTT_YES;
   else if (mutt_bit_isset (Capabilities, STARTTLS) &&
            (rc = query_quadoption (OPT_SSLSTARTTLS,
                                    _("Secure connection with TLS?"))) == -1)
     return rc;
 
-  if (rc == M_YES)
+  if (rc == MUTT_YES)
   {
     if (mutt_socket_write (conn, "STARTTLS\r\n") < 0)
       return smtp_err_write;
@@ -486,7 +486,7 @@ static int smtp_open (CONNECTION* conn)
   }
 #endif
 
-  if (conn->account.flags & M_ACCT_USER)
+  if (conn->account.flags & MUTT_ACCT_USER)
   {
     if (!mutt_bit_isset (Capabilities, AUTH))
     {
diff --git a/sort.c b/sort.c
index f3967f9..9b1db9f 100644
--- a/sort.c
+++ b/sort.c
@@ -157,7 +157,7 @@ static int compare_order (const void *a, const void *b)
   HEADER **hb = (HEADER **) b;
 
 #ifdef USE_NNTP
-  if (Context && Context->magic == M_NNTP)
+  if (Context && Context->magic == MUTT_NNTP)
   {
     anum_t na = NHDR (*ha)->article_num;
     anum_t nb = NHDR (*hb)->article_num;
diff --git a/status.c b/status.c
index c3d6591..deee02a 100644
--- a/status.c
+++ b/status.c
@@ -72,7 +72,7 @@ status_format_str (char *buf, size_t buflen, size_t col, int cols, char op, cons
 		   unsigned long data, format_flag flags)
 {
   char fmt[SHORT_STRING], tmp[SHORT_STRING], *cp;
-  int count, optional = (flags & M_FORMAT_OPTIONAL);
+  int count, optional = (flags & MUTT_FORMAT_OPTIONAL);
   MUTTMENU *menu = (MUTTMENU *) data;
 
   *buf = 0;
@@ -102,7 +102,7 @@ status_format_str (char *buf, size_t buflen, size_t col, int cols, char op, cons
     {
 #ifdef USE_NOTMUCH
       char *p;
-      if (Context && Context->magic == M_NOTMUCH &&
+      if (Context && Context->magic == MUTT_NOTMUCH &&
                    (p = nm_get_description(Context)))
 	  strfcpy(tmp, p, sizeof (tmp));
       else
@@ -237,7 +237,7 @@ status_format_str (char *buf, size_t buflen, size_t col, int cols, char op, cons
 	i = option(OPTATTACHMSG) ? 3 : ((Context->readonly ||
           Context->dontwrite) ? 2 : (Context->changed ||
           /* deleted doesn't necessarily mean changed in IMAP */
-          (Context->magic != M_IMAP &&
+          (Context->magic != MUTT_IMAP &&
            Context->deleted)) ? 1 : 0);
       }
       
@@ -310,7 +310,7 @@ status_format_str (char *buf, size_t buflen, size_t col, int cols, char op, cons
 
   if (optional)
     _menu_status_line (buf, buflen, col, cols, menu, ifstring);
-  else if (flags & M_FORMAT_OPTIONAL)
+  else if (flags & MUTT_FORMAT_OPTIONAL)
     _menu_status_line (buf, buflen, col, cols, menu, elsestring);
 
   return (src);
diff --git a/sys_socket.h b/sys_socket.h
index 68ffe25..eb56c14 100644
--- a/sys_socket.h
+++ b/sys_socket.h
@@ -19,33 +19,33 @@
 /* Solaris, OpenIndiana, and probably other derivatives
  * are including sys/stream.h inside their sys/socket.h.
  *
- * This include file is defining macros M_CMD and M_READ which
+ * This include file is defining macros MUTT_CMD and MUTT_READ which
  * are conflicting with the same macros Mutt defines in mutt.h
  *
  * To minimize breakage with out-of-tree patches, this is a workaround.
  */
 
-#ifdef M_CMD
-# define MUTT_ORIG_CMD M_CMD
-# undef M_CMD
+#ifdef MUTT_CMD
+# define MUTT_ORIG_CMD MUTT_CMD
+# undef MUTT_CMD
 #endif
 
-#ifdef M_READ
-# define MUTT_ORIG_READ M_READ
-# undef M_READ
+#ifdef MUTT_READ
+# define MUTT_ORIG_READ MUTT_READ
+# undef MUTT_READ
 #endif
 
 #include <sys/socket.h>
 
-#undef M_CMD
-#undef M_READ
+#undef MUTT_CMD
+#undef MUTT_READ
 
 #ifdef MUTT_ORIG_CMD
-# define M_CMD MUTT_ORIG_CMD
+# define MUTT_CMD MUTT_ORIG_CMD
 # undef MUTT_ORIG_CMD
 #endif
 
 #ifdef MUTT_ORIG_READ
-# define M_READ MUTT_ORIG_READ
+# define MUTT_READ MUTT_ORIG_READ
 # undef MUTT_ORIG_READ
 #endif
diff --git a/system.c b/system.c
index f7e44f8..36b80fb 100644
--- a/system.c
+++ b/system.c
@@ -49,7 +49,7 @@ int _mutt_system (const char *cmd, int flags)
   mutt_block_signals_system ();
 
   /* also don't want to be stopped right now */
-  if (flags & M_DETACH_PROCESS)
+  if (flags & MUTT_DETACH_PROCESS)
   {
     sigemptyset (&set);
     sigaddset (&set, SIGTSTP);
@@ -71,7 +71,7 @@ int _mutt_system (const char *cmd, int flags)
   {
     act.sa_flags = 0;
 
-    if (flags & M_DETACH_PROCESS)
+    if (flags & MUTT_DETACH_PROCESS)
     {
       int fd;
 
@@ -132,7 +132,7 @@ int _mutt_system (const char *cmd, int flags)
 
   /* reset SIGINT, SIGQUIT and SIGCHLD */
   mutt_unblock_signals_system (1);
-  if (flags & M_DETACH_PROCESS)
+  if (flags & MUTT_DETACH_PROCESS)
     sigprocmask (SIG_UNBLOCK, &set, NULL);
 
   rc = (thepid != -1) ? (WIFEXITED (rc) ? WEXITSTATUS (rc) : -1) : -1;
diff --git a/thread.c b/thread.c
index de1d16b..cf77bdb 100644
--- a/thread.c
+++ b/thread.c
@@ -225,7 +225,7 @@ static void calculate_visibility (CONTEXT *ctx, int *max_depth)
 
 /* Since the graphics characters have a value >255, I have to resort to
  * using escape sequences to pass the information to print_enriched_string().
- * These are the macros M_TREE_* defined in mutt.h.
+ * These are the macros MUTT_TREE_* defined in mutt.h.
  *
  * ncurses should automatically use the default ASCII characters instead of
  * graphics chars on terminals which don't support them (see the man page
@@ -234,8 +234,8 @@ static void calculate_visibility (CONTEXT *ctx, int *max_depth)
 void mutt_draw_tree (CONTEXT *ctx)
 {
   char *pfx = NULL, *mypfx = NULL, *arrow = NULL, *myarrow = NULL, *new_tree;
-  char corner = (Sort & SORT_REVERSE) ? M_TREE_ULCORNER : M_TREE_LLCORNER;
-  char vtee = (Sort & SORT_REVERSE) ? M_TREE_BTEE : M_TREE_TTEE;
+  char corner = (Sort & SORT_REVERSE) ? MUTT_TREE_ULCORNER : MUTT_TREE_LLCORNER;
+  char vtee = (Sort & SORT_REVERSE) ? MUTT_TREE_BTEE : MUTT_TREE_TTEE;
   int depth = 0, start_depth = 0, max_depth = 0, width = option (OPTNARROWTREE) ? 1 : 2;
   THREAD *nextdisp = NULL, *pseudo = NULL, *parent = NULL, *tree = ctx->tree;
 
@@ -251,19 +251,19 @@ void mutt_draw_tree (CONTEXT *ctx)
     {
       myarrow = arrow + (depth - start_depth - (start_depth ? 0 : 1)) * width;
       if (depth && start_depth == depth)
-	myarrow[0] = nextdisp ? M_TREE_LTEE : corner;
+	myarrow[0] = nextdisp ? MUTT_TREE_LTEE : corner;
       else if (parent->message && !option (OPTHIDELIMITED))
-	myarrow[0] = M_TREE_HIDDEN;
+	myarrow[0] = MUTT_TREE_HIDDEN;
       else if (!parent->message && !option (OPTHIDEMISSING))
-	myarrow[0] = M_TREE_MISSING;
+	myarrow[0] = MUTT_TREE_MISSING;
       else
 	myarrow[0] = vtee;
       if (width == 2)
-	myarrow[1] = pseudo ?  M_TREE_STAR
-	                     : (tree->duplicate_thread ? M_TREE_EQUALS : M_TREE_HLINE);
+	myarrow[1] = pseudo ?  MUTT_TREE_STAR
+	                     : (tree->duplicate_thread ? MUTT_TREE_EQUALS : MUTT_TREE_HLINE);
       if (tree->visible)
       {
-	myarrow[width] = M_TREE_RARROW;
+	myarrow[width] = MUTT_TREE_RARROW;
 	myarrow[width + 1] = 0;
 	new_tree = safe_malloc ((2 + depth * width));
 	if (start_depth > 1)
@@ -280,9 +280,9 @@ void mutt_draw_tree (CONTEXT *ctx)
     if (tree->child && depth)
     {
       mypfx = pfx + (depth - 1) * width;
-      mypfx[0] = nextdisp ? M_TREE_VLINE : M_TREE_SPACE;
+      mypfx[0] = nextdisp ? MUTT_TREE_VLINE : MUTT_TREE_SPACE;
       if (width == 2)
-	mypfx[1] = M_TREE_SPACE;
+	mypfx[1] = MUTT_TREE_SPACE;
     }
     parent = tree;
     nextdisp = NULL;
@@ -1133,7 +1133,7 @@ int _mutt_traverse_thread (CONTEXT *ctx, HEADER *cur, int flag)
   int min_unread_msgno = INT_MAX, min_unread = cur->virtual;
 #define CHECK_LIMIT (!ctx->pattern || cur->limited)
 
-  if ((Sort & SORT_MASK) != SORT_THREADS && !(flag & M_THREAD_GET_HIDDEN))
+  if ((Sort & SORT_MASK) != SORT_THREADS && !(flag & MUTT_THREAD_GET_HIDDEN))
   {
     mutt_error (_("Threading is not enabled."));
     return (cur->virtual);
@@ -1165,14 +1165,14 @@ int _mutt_traverse_thread (CONTEXT *ctx, HEADER *cur, int flag)
   if (cur->virtual == -1 && CHECK_LIMIT)
     num_hidden++;
 
-  if (flag & (M_THREAD_COLLAPSE | M_THREAD_UNCOLLAPSE))
+  if (flag & (MUTT_THREAD_COLLAPSE | MUTT_THREAD_UNCOLLAPSE))
   {
     cur->pair = 0; /* force index entry's color to be re-evaluated */
-    cur->collapsed = flag & M_THREAD_COLLAPSE;
+    cur->collapsed = flag & MUTT_THREAD_COLLAPSE;
     if (cur->virtual != -1)
     {
       roothdr = cur;
-      if (flag & M_THREAD_COLLAPSE)
+      if (flag & MUTT_THREAD_COLLAPSE)
 	final = roothdr->virtual;
     }
   }
@@ -1180,13 +1180,13 @@ int _mutt_traverse_thread (CONTEXT *ctx, HEADER *cur, int flag)
   if (thread == top && (thread = thread->child) == NULL)
   {
     /* return value depends on action requested */
-    if (flag & (M_THREAD_COLLAPSE | M_THREAD_UNCOLLAPSE))
+    if (flag & (MUTT_THREAD_COLLAPSE | MUTT_THREAD_UNCOLLAPSE))
       return (final);
-    else if (flag & M_THREAD_UNREAD)
+    else if (flag & MUTT_THREAD_UNREAD)
       return ((old && new) ? new : (old ? old : new));
-    else if (flag & M_THREAD_GET_HIDDEN)
+    else if (flag & MUTT_THREAD_GET_HIDDEN)
       return (num_hidden);
-    else if (flag & M_THREAD_NEXT_UNREAD)
+    else if (flag & MUTT_THREAD_NEXT_UNREAD)
       return (min_unread);
   }
   
@@ -1196,24 +1196,24 @@ int _mutt_traverse_thread (CONTEXT *ctx, HEADER *cur, int flag)
 
     if (cur)
     {
-      if (flag & (M_THREAD_COLLAPSE | M_THREAD_UNCOLLAPSE))
+      if (flag & (MUTT_THREAD_COLLAPSE | MUTT_THREAD_UNCOLLAPSE))
       {
 	cur->pair = 0; /* force index entry's color to be re-evaluated */
-	cur->collapsed = flag & M_THREAD_COLLAPSE;
+	cur->collapsed = flag & MUTT_THREAD_COLLAPSE;
 	if (!roothdr && CHECK_LIMIT)
 	{
 	  roothdr = cur;
-	  if (flag & M_THREAD_COLLAPSE)
+	  if (flag & MUTT_THREAD_COLLAPSE)
 	    final = roothdr->virtual;
 	}
 
-	if (reverse && (flag & M_THREAD_COLLAPSE) && (cur->msgno < minmsgno) && CHECK_LIMIT)
+	if (reverse && (flag & MUTT_THREAD_COLLAPSE) && (cur->msgno < minmsgno) && CHECK_LIMIT)
 	{
 	  minmsgno = cur->msgno;
 	  final = cur->virtual;
 	}
 
-	if (flag & M_THREAD_COLLAPSE)
+	if (flag & MUTT_THREAD_COLLAPSE)
 	{
 	  if (cur != roothdr)
 	    cur->virtual = -1;
@@ -1266,13 +1266,13 @@ int _mutt_traverse_thread (CONTEXT *ctx, HEADER *cur, int flag)
   }
 
   /* return value depends on action requested */
-  if (flag & (M_THREAD_COLLAPSE | M_THREAD_UNCOLLAPSE))
+  if (flag & (MUTT_THREAD_COLLAPSE | MUTT_THREAD_UNCOLLAPSE))
     return (final);
-  else if (flag & M_THREAD_UNREAD)
+  else if (flag & MUTT_THREAD_UNREAD)
     return ((old && new) ? new : (old ? old : new));
-  else if (flag & M_THREAD_GET_HIDDEN)
+  else if (flag & MUTT_THREAD_GET_HIDDEN)
     return (num_hidden+1);
-  else if (flag & M_THREAD_NEXT_UNREAD)
+  else if (flag & MUTT_THREAD_NEXT_UNREAD)
     return (min_unread);
 
   return (0);
@@ -1407,7 +1407,7 @@ static int link_threads (HEADER *parent, HEADER *child, CONTEXT *ctx)
   child->env->in_reply_to = mutt_new_list ();
   child->env->in_reply_to->data = safe_strdup (parent->env->message_id);
   
-  mutt_set_flag (ctx, child, M_TAG, 0);
+  mutt_set_flag (ctx, child, MUTT_TAG, 0);
   
   child->env->irt_changed = child->changed = 1;
   return 1;
-- 
2.8.2

