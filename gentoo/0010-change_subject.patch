From 349dd4f9eb2ed19e948eae4759487f65b580bc6e Mon Sep 17 00:00:00 2001
From: Richard Russon <rich@flatcap.org>
Date: Mon, 30 May 2016 03:55:55 +0100
Subject: [PATCH 10/13] change_subject

---
 PATCHES             |   1 +
 doc/manual.xml.head |  52 ++++++++++++++++++
 globals.h           |   3 +-
 hcache.c            |   2 +-
 hdrline.c           | 116 ++++++++++++++++++++++++++++++++++-----
 init.c              | 155 ++++++++++++++++++++++++++++++++++++++++++----------
 init.h              |   6 ++
 mutt.h              |  11 ++--
 muttlib.c           |   9 ++-
 protos.h            |   2 +-
 10 files changed, 303 insertions(+), 54 deletions(-)

diff --git a/PATCHES b/PATCHES
index 2d95814..fedec29 100644
--- a/PATCHES
+++ b/PATCHES
@@ -1,3 +1,4 @@
+dgc.subjrx
 fg.change_folder_next
 vvv.quote
 patch-1.5.4.lpr.collapse_flagged Lukas P. Ruf <lukas.ruf@lpr.ch>
diff --git a/doc/manual.xml.head b/doc/manual.xml.head
index a2b5ef8..4888499 100644
--- a/doc/manual.xml.head
+++ b/doc/manual.xml.head
@@ -4664,6 +4664,58 @@ <example id="ex-spam">
 
 </sect1>
 
+<sect1 id="subjrepl">
+<title>Altering the Display Subject</title>
+
+<para>
+In today's world of e-mail automation, Subject: headers often turn up
+with redundant, machine-generated text that provides no information
+useful to you as a reader, but consumes screen space.  To reduce
+the effect of this trend, you can use the <literal>subjectrx</literal>
+and <literal>unsubjectrx</literal> commands to apply regular expression
+transformations to your Subject: headers.
+</para>
+
+<para>
+<literallayout>
+Usage: <literal>subjectrx</literal> <emphasis>regex</emphasis> <emphasis>replace</emphasis>
+Usage: <literal>unsubjectrx</literal> <emphasis>regex</emphasis>
+</literallayout>
+</para>
+
+<para>
+<literal>subjectrx</literal> creates a new subject transformation.  Wherever
+the <emphasis>regex</emphasis> appears in a Subject: header, it will
+be replaced with <emphasis>replace</emphasis> for the index view only. 
+The actual subject of the message is not changed, as you'll see when
+you view, edit, or reply to the message.  The <emphasis>replace</emphasis>
+string can contain certain substitution tokens: &percnt;L for the part of
+the subject to the left of the regex, &percnt;R for the part to the right,
+and &percnt;1, &percnt;2, etc. for successive subexpressions.  The
+<emphasis>replace</emphasis> text replaces the <emphasis>entire</emphasis>
+subject, not just the matching part.
+</para>
+
+<para>
+<literal>unsubjectrx</literal> removes a <emphasis>regex</emphasis> from
+the list of transformations in use.
+</para>
+
+
+<para>
+Example: At my office we use the RT ticketing system for handling 
+customer and internal projects.  RT inserts a prefix on each Subject:
+header which it uses to associate e-mail to a ticket.  It's critical
+that this be present in the mail, but it's wasteful on my index screen.
+This <literal>subjectrx</literal> command hides it from view:
+<screen>
+subjectrx "\\[rt #[0-9]+\\] *" "%L%R"
+</screen>
+</para>
+
+</sect1>
+
+
 <sect1 id="set">
 <title>Setting and Querying Variables</title>
 
diff --git a/globals.h b/globals.h
index b44a08a..32311bd 100644
--- a/globals.h
+++ b/globals.h
@@ -199,8 +199,9 @@ WHERE RX_LIST *MailLists INITVAL(0);
 WHERE RX_LIST *UnMailLists INITVAL(0);
 WHERE RX_LIST *SubscribedLists INITVAL(0);
 WHERE RX_LIST *UnSubscribedLists INITVAL(0);
-WHERE SPAM_LIST *SpamList INITVAL(0);
+WHERE REPLACE_LIST *SpamList INITVAL(0);
 WHERE RX_LIST *NoSpamList INITVAL(0);
+WHERE REPLACE_LIST *SubjectRxList INITVAL(0);
 
 
 /* bit vector for boolean variables */
diff --git a/hcache.c b/hcache.c
index 912b80a..81b3487 100644
--- a/hcache.c
+++ b/hcache.c
@@ -1172,7 +1172,7 @@ mutt_hcache_open(const char *path, const char *folder, hcache_namer_t namer)
       unsigned int intval;
     } digest;
     struct md5_ctx ctx;
-    SPAM_LIST *spam;
+    REPLACE_LIST *spam;
     RX_LIST *nospam;
 
     hcachever = HCACHEVER;
diff --git a/hdrline.c b/hdrline.c
index d2c1253..5a2016a 100644
--- a/hdrline.c
+++ b/hdrline.c
@@ -235,6 +235,91 @@ int mutt_user_is_recipient (HEADER *h)
   return h->recipient;
 }
 
+static char *apply_subject_mods (ENVELOPE *env)
+{
+  REPLACE_LIST *l;
+  static regmatch_t *pmatch = NULL;
+  static int nmatch = 0;
+  static char twinbuf[2][LONG_STRING];
+  int switcher = 0;
+  char *p;
+  int i, n;
+  int tlen = 0;
+  char *src, *dst;
+
+  if (env == NULL)
+    return NULL;
+
+  if (SubjectRxList == NULL || env->subject == NULL)
+    return env->subject;
+
+  src = twinbuf[switcher];
+  dst = src;
+
+  strncpy(src, env->subject, LONG_STRING-1);
+  src[LONG_STRING-1] = '\0';
+
+  for (l = SubjectRxList; l; l = l->next)
+  {
+    /* If this pattern needs more matches, expand pmatch. */
+    if (l->nmatch > nmatch)
+    {
+      safe_realloc (&pmatch, l->nmatch * sizeof(regmatch_t));
+      nmatch = l->nmatch;
+    }
+
+    if (regexec (l->rx->rx, src, l->nmatch, pmatch, 0) == 0)
+    {
+      tlen = 0;
+      switcher ^= 1;
+      dst = twinbuf[switcher];
+
+      dprint (5, (debugfile, "apply_subject_mods: %s matches %s\n", src, l->rx->pattern));
+
+      /* Copy into other twinbuf with substitutions */
+      if (l->template)
+      {
+        for (p = l->template; *p; )
+        {
+	  if (*p == '%')
+	  {
+	    p++;
+	    if (*p == 'L')
+	    {
+	      p++;
+	      strncpy(&dst[tlen], src, pmatch[0].rm_so);
+	      tlen += pmatch[0].rm_so;
+	    }
+	    else if (*p == 'R')
+	    {
+	      p++;
+	      strncpy(&dst[tlen], &src[pmatch[0].rm_eo], LONG_STRING-tlen-1);
+	      tlen += strlen(src) - pmatch[0].rm_eo;
+	    }
+	    else
+	    {
+	      n = atoi(++p);                        /* get subst number */
+	      while (isdigit((unsigned char)*p))    /* skip subst token */
+                ++p;
+	      for (i = pmatch[n].rm_so; (i < pmatch[n].rm_eo) && (tlen < LONG_STRING-1); i++)
+	        dst[tlen++] = src[i];
+	    }
+	  }
+	  else
+	    dst[tlen++] = *p++;
+        }
+      }
+      dst[tlen] = '\0';
+      dprint (5, (debugfile, "apply_subject_mods: subst %s\n", dst));
+    }
+    src = dst;
+  }
+
+  env->disp_subj = safe_strdup(dst);
+  return env->disp_subj;
+}
+
+
 /* %a = address of author
  * %A = reply-to address (if present; otherwise: address of author
  * %b = filename of the originating folder
@@ -768,24 +853,27 @@ hdr_format_str (char *dest,
       break;
 
     case 's':
-      
-      if (flags & MUTT_FORMAT_TREE && !hdr->collapsed)
       {
-	if (flags & MUTT_FORMAT_FORCESUBJ)
+	char *subj;
+        if (hdr->env->disp_subj)
+	  subj = hdr->env->disp_subj;
+	else if (SubjectRxList)
+	  subj = apply_subject_mods(hdr->env);
+	else
+	  subj = hdr->env->subject;
+	if (flags & MUTT_FORMAT_TREE && !hdr->collapsed)
 	{
-	  colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_SUBJECT);
-	  mutt_format_s (dest + colorlen, destlen - colorlen, "", NONULL (hdr->env->subject));
-	  add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
-	  snprintf (buf2, sizeof (buf2), "%s%s", hdr->tree, dest);
-	  mutt_format_s_tree (dest, destlen, prefix, buf2);
+	  if (flags & MUTT_FORMAT_FORCESUBJ)
+	  {
+	    mutt_format_s (dest, destlen, "", NONULL (subj));
+	    snprintf (buf2, sizeof (buf2), "%s%s", hdr->tree, dest);
+	    mutt_format_s_tree (dest, destlen, prefix, buf2);
+	  }
+	  else
+	    mutt_format_s_tree (dest, destlen, prefix, hdr->tree);
 	}
 	else
-	  mutt_format_s_tree (dest, destlen, prefix, hdr->tree);
-      }
-      else {
-	colorlen = add_index_color (dest, destlen, flags, MT_COLOR_INDEX_SUBJECT);
-	mutt_format_s (dest + colorlen, destlen - colorlen, prefix, NONULL (hdr->env->subject));
-	add_index_color (dest + colorlen, destlen - colorlen, flags, MT_COLOR_INDEX);
+	  mutt_format_s (dest, destlen, prefix, NONULL (subj));
       }
       break;
 
diff --git a/init.c b/init.c
index 7ed4f7b..5a68b6a 100644
--- a/init.c
+++ b/init.c
@@ -460,11 +460,11 @@ int mutt_add_to_rx_list (RX_LIST **list, const char *s, int flags, BUFFER *err)
   return 0;
 }
 
-static int remove_from_spam_list (SPAM_LIST **list, const char *pat);
+static int remove_from_replace_list (REPLACE_LIST **list, const char *pat);
 
-static int add_to_spam_list (SPAM_LIST **list, const char *pat, const char *templ, BUFFER *err)
+static int add_to_replace_list (REPLACE_LIST **list, const char *pat, const char *templ, BUFFER *err)
 {
-  SPAM_LIST *t = NULL, *last = NULL;
+  REPLACE_LIST *t = NULL, *last = NULL;
   REGEXP *rx;
   int n;
   const char *p;
@@ -497,12 +497,12 @@ static int add_to_spam_list (SPAM_LIST **list, const char *pat, const char *temp
       break;
   }
 
-  /* If t is set, it's pointing into an extant SPAM_LIST* that we want to
+  /* If t is set, it's pointing into an extant REPLACE_LIST* that we want to
    * update. Otherwise we want to make a new one to link at the list's end.
    */
   if (!t)
   {
-    t = mutt_new_spam_list();
+    t = mutt_new_replace_list();
     t->rx = rx;
     if (last)
       last->next = t;
@@ -510,7 +510,7 @@ static int add_to_spam_list (SPAM_LIST **list, const char *pat, const char *temp
       *list = t;
   }
 
-  /* Now t is the SPAM_LIST* that we want to modify. It is prepared. */
+  /* Now t is the REPLACE_LIST* that we want to modify. It is prepared. */
   t->template = safe_strdup(templ);
 
   /* Find highest match number in template string */
@@ -531,9 +531,9 @@ static int add_to_spam_list (SPAM_LIST **list, const char *pat, const char *temp
 
   if (t->nmatch > t->rx->rx->re_nsub)
   {
-    snprintf (err->data, err->dsize, _("Not enough subexpressions for spam "
+    snprintf (err->data, err->dsize, _("Not enough subexpressions for "
                                        "template"));
-    remove_from_spam_list(list, pat);
+    remove_from_replace_list(list, pat);
     return -1;
   }
 
@@ -542,38 +542,38 @@ static int add_to_spam_list (SPAM_LIST **list, const char *pat, const char *temp
   return 0;
 }
 
-static int remove_from_spam_list (SPAM_LIST **list, const char *pat)
+static int remove_from_replace_list (REPLACE_LIST **list, const char *pat)
 {
-  SPAM_LIST *spam, *prev;
+  REPLACE_LIST *cur, *prev;
   int nremoved = 0;
 
   /* Being first is a special case. */
-  spam = *list;
-  if (!spam)
+  cur = *list;
+  if (!cur)
     return 0;
-  if (spam->rx && !mutt_strcmp(spam->rx->pattern, pat))
+  if (cur->rx && !mutt_strcmp(cur->rx->pattern, pat))
   {
-    *list = spam->next;
-    mutt_free_regexp(&spam->rx);
-    FREE(&spam->template);
-    FREE(&spam);
+    *list = cur->next;
+    mutt_free_regexp(&cur->rx);
+    FREE(&cur->template);
+    FREE(&cur);
     return 1;
   }
 
-  prev = spam;
-  for (spam = prev->next; spam;)
+  prev = cur;
+  for (cur = prev->next; cur;)
   {
-    if (!mutt_strcmp(spam->rx->pattern, pat))
+    if (!mutt_strcmp(cur->rx->pattern, pat))
     {
-      prev->next = spam->next;
-      mutt_free_regexp(&spam->rx);
-      FREE(&spam->template);
-      FREE(&spam);
-      spam = prev->next;
+      prev->next = cur->next;
+      mutt_free_regexp(&cur->rx);
+      FREE(&cur->template);
+      FREE(&cur);
+      cur = prev->next;
       ++nremoved;
     }
     else
-      spam = spam->next;
+      cur = cur->next;
   }
 
   return nremoved;
@@ -818,6 +818,103 @@ static int parse_unalternates (BUFFER *buf, BUFFER *s, unsigned long data, BUFFE
   return 0;
 }
 
+static int parse_replace_list (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  REPLACE_LIST **list = (REPLACE_LIST **)data;
+  BUFFER templ;
+
+  memset(&templ, 0, sizeof(templ));
+
+  /* First token is a regexp. */
+  if (!MoreArgs(s))
+  {
+    strfcpy(err->data, _("not enough arguments"), err->dsize);
+    return -1;
+  }
+  mutt_extract_token(buf, s, 0);
+
+  /* Second token is a replacement template */
+  if (!MoreArgs(s))
+  {
+    strfcpy(err->data, _("not enough arguments"), err->dsize);
+    return -1;
+  }
+  mutt_extract_token(&templ, s, 0);
+
+  if (add_to_replace_list(list, buf->data, templ.data, err) != 0) {
+    FREE(&templ.data);
+    return -1;
+  }
+  FREE(&templ.data);
+
+  return 0;
+}
+
+static int parse_unreplace_list (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  REPLACE_LIST **list = (REPLACE_LIST **)data;
+
+  /* First token is a regexp. */
+  if (!MoreArgs(s))
+  {
+    strfcpy(err->data, _("not enough arguments"), err->dsize);
+    return -1;
+  }
+
+  mutt_extract_token(buf, s, 0);
+  if (mutt_strcmp ("*", buf->data) == 0)
+  {
+    REPLACE_LIST *cur = *list;
+    while (cur != NULL)
+    {
+      *list = cur->next;
+      if (cur->rx)
+      {
+	mutt_free_regexp(&cur->rx);
+	FREE(&cur->template);
+	FREE(&cur);
+      }
+      cur = *list;
+    }
+  } else
+    remove_from_replace_list(list, buf->data);
+  return 0;
+}
+
+
+static void clear_subject_mods (void)
+{
+  int i;
+  if (Context && Context->msgcount) 
+  {
+    for (i = 0; i < Context->msgcount; i++)
+      FREE(&Context->hdrs[i]->env->disp_subj);
+  }
+}
+
+
+static int parse_subjectrx_list (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  int rc;
+
+  rc = parse_replace_list(buf, s, data, err);
+  if (rc == 0)
+    clear_subject_mods();
+  return rc;
+}
+
+
+static int parse_unsubjectrx_list (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  int rc;
+
+  rc = parse_unreplace_list(buf, s, data, err);
+  if (rc == 0)
+    clear_subject_mods();
+  return rc;
+}
+
+
 static int parse_spam_list (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
 {
   BUFFER templ;
@@ -846,7 +943,7 @@ static int parse_spam_list (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *
       mutt_extract_token (&templ, s, 0);
 
       /* Add to the spam list. */
-      if (add_to_spam_list (&SpamList, buf->data, templ.data, err) != 0) {
+      if (add_to_replace_list (&SpamList, buf->data, templ.data, err) != 0) {
 	  FREE(&templ.data);
           return -1;
       }
@@ -870,13 +967,13 @@ static int parse_spam_list (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *
     /* "*" is a special case. */
     if (!mutt_strcmp(buf->data, "*"))
     {
-      mutt_free_spam_list (&SpamList);
+      mutt_free_replace_list (&SpamList);
       mutt_free_rx_list (&NoSpamList);
       return 0;
     }
 
     /* If it's on the spam list, just remove it. */
-    if (remove_from_spam_list(&SpamList, buf->data) != 0)
+    if (remove_from_replace_list(&SpamList, buf->data) != 0)
       return 0;
 
     /* Otherwise, add it to the nospam list. */
diff --git a/init.h b/init.h
index 9a6320c..e292e6d 100644
--- a/init.h
+++ b/init.h
@@ -4225,6 +4225,10 @@ static int parse_subscribe (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unsubscribe (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_attachments (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unattachments (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_replace_list (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_unreplace_list (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_subjectrx_list (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_unsubjectrx_list (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 
 static int parse_alternates (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unalternates (BUFFER *, BUFFER *, unsigned long, BUFFER *);
@@ -4314,6 +4318,8 @@ const struct command_t Commands[] = {
   { "spam",		parse_spam_list,	MUTT_SPAM },
   { "nospam",		parse_spam_list,	MUTT_NOSPAM },
   { "subscribe",	parse_subscribe,	0 },
+  { "subjectrx",    parse_subjectrx_list, UL &SubjectRxList },
+  { "unsubjectrx",  parse_unsubjectrx_list, UL &SubjectRxList },
   { "toggle",		parse_set,		MUTT_SET_INV },
   { "unalias",		parse_unalias,		0 },
   { "unalternative_order",parse_unlist,		UL &AlternativeOrderList },
diff --git a/mutt.h b/mutt.h
index c4d851e..4dc9d85 100644
--- a/mutt.h
+++ b/mutt.h
@@ -634,20 +634,20 @@ typedef struct rx_list_t
   struct rx_list_t *next;
 } RX_LIST;
 
-typedef struct spam_list_t
+typedef struct replace_list_t
 {
   REGEXP *rx;
   int     nmatch;
   char   *template;
-  struct spam_list_t *next;
-} SPAM_LIST;
+  struct replace_list_t *next;
+} REPLACE_LIST;
 
 #define mutt_new_list() safe_calloc (1, sizeof (LIST))
 #define mutt_new_rx_list() safe_calloc (1, sizeof (RX_LIST))
-#define mutt_new_spam_list() safe_calloc (1, sizeof (SPAM_LIST))
+#define mutt_new_replace_list() safe_calloc (1, sizeof (REPLACE_LIST))
 void mutt_free_list (LIST **);
 void mutt_free_rx_list (RX_LIST **);
-void mutt_free_spam_list (SPAM_LIST **);
+void mutt_free_replace_list (REPLACE_LIST **);
 LIST *mutt_copy_list (LIST *);
 int mutt_matches_ignore (const char *, LIST *);
 
@@ -683,6 +683,7 @@ typedef struct envelope
   char *list_post;		/* this stores a mailto URL, or nothing */
   char *subject;
   char *real_subj;		/* offset of the real subject */
+  char *disp_subj;		/* display subject (modified copy of subject) */
   char *message_id;
   char *supersedes;
   char *date;
diff --git a/muttlib.c b/muttlib.c
index a972df4..78db80a 100644
--- a/muttlib.c
+++ b/muttlib.c
@@ -724,6 +724,7 @@ void mutt_free_envelope (ENVELOPE **p)
   FREE (&(*p)->list_post);
   FREE (&(*p)->subject);
   /* real_subj is just an offset to subject and shouldn't be freed */
+  FREE (&(*p)->disp_subj);
   FREE (&(*p)->message_id);
   FREE (&(*p)->supersedes);
   FREE (&(*p)->date);
@@ -780,8 +781,10 @@ void mutt_merge_envelopes(ENVELOPE* base, ENVELOPE** extra)
   {
     base->subject = (*extra)->subject;
     base->real_subj = (*extra)->real_subj;
+    base->disp_subj = (*extra)->disp_subj;
     (*extra)->subject = NULL;
     (*extra)->real_subj = NULL;
+    (*extra)->disp_subj = NULL;
   }
   /* spam and user headers should never be hashed, and the new envelope may
     * have better values. Use new versions regardless. */
@@ -2019,9 +2022,9 @@ void mutt_free_rx_list (RX_LIST **list)
   }
 }
 
-void mutt_free_spam_list (SPAM_LIST **list)
+void mutt_free_replace_list (REPLACE_LIST **list)
 {
-  SPAM_LIST *p;
+  REPLACE_LIST *p;
   
   if (!list) return;
   while (*list)
@@ -2057,7 +2060,7 @@ int mutt_match_rx_list (const char *s, RX_LIST *l)
  *
  * Returns 1 if the argument `s` matches a pattern in the spam list, otherwise
  * 0. */
-int mutt_match_spam_list (const char *s, SPAM_LIST *l, char *text, int textsize)
+int mutt_match_spam_list (const char *s, REPLACE_LIST *l, char *text, int textsize)
 {
   static regmatch_t *pmatch = NULL;
   static int nmatch = 0;
diff --git a/protos.h b/protos.h
index 16219f0..4157c8e 100644
--- a/protos.h
+++ b/protos.h
@@ -341,7 +341,7 @@ int mutt_is_valid_mailbox (const char *);
 int mutt_link_threads (HEADER *, HEADER *, CONTEXT *);
 int mutt_lookup_mime_type (BODY *, const char *);
 int mutt_match_rx_list (const char *, RX_LIST *);
-int mutt_match_spam_list (const char *, SPAM_LIST *, char *, int);
+int mutt_match_spam_list (const char *, REPLACE_LIST *, char *, int);
 int mutt_messages_in_thread (CONTEXT *, HEADER *, int);
 int mutt_multi_choice (char *prompt, char *letters);
 int mutt_needs_mailcap (BODY *);
-- 
2.8.2

