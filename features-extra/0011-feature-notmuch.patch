From d3bb07b47077e506d6fd71b70b75fa1170078c22 Mon Sep 17 00:00:00 2001
From: Karel Zak <kzak@redhat.com>
Date: Wed, 14 Dec 2011 11:58:47 +0100
Subject: [PATCH 11/16] feature: notmuch

Signed-off-by: Karel Zak <kzak@redhat.com>
---
 Makefile.am             |   14 +-
 OPS.NOTMUCH             |    5 +
 OPS.SIDEBAR             |    1 +
 README.notmuch          |  115 +++
 UPDATING                |    4 +
 UPDATING.kz             |   68 ++
 browser.c               |  102 ++-
 buffy.c                 |  223 ++++--
 buffy.h                 |    6 +
 color.c                 |   28 +-
 commands.c              |   38 +-
 compose.c               |    5 +-
 configure.ac            |   27 +-
 copy.c                  |   25 +-
 copy.h                  |    3 +-
 curs_lib.c              |   18 +-
 curs_main.c             |  324 ++++++--
 doc/manual.xml.head     |  422 +++++++++-
 doc/muttrc.notmuch      |  114 +++
 doc/muttrc.status-color |    2 +-
 doc/vimrc.notmuch       |   28 +
 enter.c                 |   21 +
 functions.h             |   17 +
 globals.h               |   15 +
 hdrline.c               |   60 ++
 init.c                  |  261 ++++++-
 init.h                  |  108 ++-
 mailbox.h               |    1 +
 menu.c                  |   11 +
 mh.c                    |  225 +++---
 mutt.h                  |   15 +-
 mutt_curses.h           |    9 +
 mutt_notmuch.c          | 1984 +++++++++++++++++++++++++++++++++++++++++++++++
 mutt_notmuch.h          |   39 +
 muttlib.c               |   21 +-
 mx.c                    |   87 ++-
 mx.h                    |   20 +-
 pattern.c               |   14 +
 protos.h                |   15 +-
 send.c                  |   21 +-
 sendlib.c               |    5 +-
 sidebar.c               |   92 ++-
 sidebar.h               |    1 +
 sort.h                  |    3 +-
 status.c                |   17 +-
 url.c                   |    5 +-
 url.h                   |    4 +
 version.c               |    5 +
 48 files changed, 4357 insertions(+), 291 deletions(-)
 create mode 100644 OPS.NOTMUCH
 create mode 100644 README.notmuch
 create mode 100644 UPDATING.kz
 create mode 100644 doc/muttrc.notmuch
 create mode 100644 doc/vimrc.notmuch
 create mode 100644 mutt_notmuch.c
 create mode 100644 mutt_notmuch.h

diff --git a/Makefile.am b/Makefile.am
index 1d7c4ad..cfdb258 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -79,6 +79,16 @@ EXTRA_DIST = COPYRIGHT GPL OPS OPS.PGP OPS.CRYPT OPS.SMIME TODO UPDATING \
 
 EXTRA_SCRIPTS = smime_keys
 
+if BUILD_NOTMUCH
+mutt_SOURCES += mutt_notmuch.c mutt_notmuch.h
+mutt_LDADD += $(NOTMUCH_LIBS)
+endif
+
+# kz
+EXTRA_DIST += UPDATING.kz README.notmuch OPS.NOTMUCH
+
+
+
 mutt_dotlock_SOURCES = mutt_dotlock.c
 mutt_dotlock_LDADD = $(LIBOBJS)
 mutt_dotlock_DEPENDENCIES = $(LIBOBJS)
@@ -131,9 +141,9 @@ smime_keys: $(srcdir)/smime_keys.pl
 keymap_defs.h: $(OPS) $(srcdir)/gen_defs
 	$(srcdir)/gen_defs $(OPS) > keymap_defs.h
 
-keymap_alldefs.h: $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.PGP $(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME $(srcdir)/gen_defs
+keymap_alldefs.h: $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.NOTMUCH $(srcdir)/OPS.PGP $(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME $(srcdir)/gen_defs
 	rm -f $@
-	$(srcdir)/gen_defs $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.PGP \
+	$(srcdir)/gen_defs $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.NOTMUCH $(srcdir)/OPS.PGP \
 		$(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME \
 			> keymap_alldefs.h
 
diff --git a/OPS.NOTMUCH b/OPS.NOTMUCH
new file mode 100644
index 0000000..4508e4e
--- /dev/null
+++ b/OPS.NOTMUCH
@@ -0,0 +1,5 @@
+OP_MAIN_CHANGE_VFOLDER "open a different virtual folder"
+OP_MAIN_VFOLDER_FROM_QUERY "generate virtual folder from query"
+OP_MAIN_MODIFY_LABELS "modify (notmuch) tags"
+OP_MAIN_MODIFY_LABELS_THEN_HIDE "modify labels and then hide message"
+OP_MAIN_ENTIRE_THREAD "read entire thread of the current message"
diff --git a/OPS.SIDEBAR b/OPS.SIDEBAR
index 7e5b504..e39f80c 100644
--- a/OPS.SIDEBAR
+++ b/OPS.SIDEBAR
@@ -5,4 +5,5 @@ OP_SIDEBAR_PAGE_DOWN "scroll the sidebar down 1 page"
 OP_SIDEBAR_PAGE_UP "scroll the sidebar up 1 page"
 OP_SIDEBAR_PREV "move the highlight to previous mailbox"
 OP_SIDEBAR_PREV_NEW "move the highlight to previous mailbox with new mail"
+OP_SIDEBAR_TOGGLE_VIRTUAL "toggle between mailboxes and virtual mailboxes"
 OP_SIDEBAR_TOGGLE_VISIBLE "make the sidebar (in)visible"
diff --git a/README.notmuch b/README.notmuch
new file mode 100644
index 0000000..e7ec564
--- /dev/null
+++ b/README.notmuch
@@ -0,0 +1,115 @@
+Notmuch Patch
+=============
+
+    Email search engine
+
+Patch
+-----
+
+    To check if Mutt supports "Notmuch", look for "+USE_NOTMUCH" in the mutt
+    version.
+
+    Dependencies
+    * mutt-1.6.2
+    * sidebar patch
+    * quasi-delete patch
+    * index-color patch
+    * Notmuch libraries
+
+Introduction
+------------
+
+Variables
+---------
+
+    Notmuch Variables
+
+    | Name                | Type    | Default                                                           |
+    |---------------------|---------|-------------------------------------------------------------------|
+    | 'nm_db_limit'       | number  | '0'                                                               |
+    | 'nm_default_uri'    | string  | (empty)                                                           |
+    | 'nm_exclude_tags'   | string  | (empty)                                                           |
+    | 'nm_hidden_tags'    | string  | 'unread,draft,flagged,passed,replied,attachment,signed,encrypted' |
+    | 'nm_open_timeout'   | number  | '5'                                                               |
+    | 'nm_query_type'     | string  | 'messages'                                                        |
+    | 'nm_record'         | boolean | 'no'                                                              |
+    | 'nm_record_tags'    | string  | (empty)                                                           |
+    | 'nm_unread_tag'     | string  | 'unread'                                                          |
+    | 'vfolder_format'    | string  | '%6n(%6N) %f'                                                     |
+    | 'virtual_spoolfile' | boolean | 'no'                                                              |
+
+Functions
+---------
+
+    Notmuch Functions
+
+    | Menus       | Default Key | Function                    | Description                                    |
+    |-------------|-------------|-----------------------------|------------------------------------------------|
+    | index,pager | X           | '<change-vfolder>'          | open a different virtual folder                |
+    | index,pager | +           | '<entire-thread>'           | read entire thread of the current message      |
+    | index,pager | `           | '<modify-labels>'           | modify (notmuch) tags                          |
+    | index,pager | (none)      | '<modify-labels-then-hide>' | modify labels and then hide message            |
+    | index,pager | (none)      | '<sidebar-toggle-virtual>'  | toggle between mailboxes and virtual mailboxes |
+    | index,pager | Alt-X       | '<vfolder-from-query>'      | generate virtual folder from query             |
+
+Commands
+--------
+
+    Notmuch Commands
+
+        virtual-mailboxes description notmuch-URI { description notmuch-URI ...}
+        tag-transforms tag transformed-string { tag transformed-string ...}
+        tag-formats tag format-string { tag format-string ...}
+
+Colors
+------
+
+    Adds these to index-color patch:
+
+    Index Colors
+
+    | Object       | Pattern | Highlights                                   |
+    |--------------|---------|----------------------------------------------|
+    | 'index_tag'  | yes     | an individual message tag, %G, uses tag name |
+    | 'index_tags' | no      | the transformed message tags, %g             |
+
+
+See Also
+--------
+
+    * NeoMutt project
+    * Compile-Time Features
+
+Known Bugs
+----------
+
+    None
+
+Credits
+-------
+
+    * Karel Zak <kzak@redhat.com>
+    * Chris Mason <clm@fb.com>
+    * Christoph Rissner <cri@visotech.at>
+    * David Riebenbauer <davrieb@liegesta.at>
+    * David Sterba <dsterba@suse.cz>
+    * David Wilson <dw@botanicus.net>
+    * Don Zickus <dzickus@redhat.com>
+    * Eric Davis <edavis@insanum.com>
+    * Jan Synacek <jsynacek@redhat.com>
+    * Jeremiah C. Foster <jeremiah@jeremiahfoster.com>
+    * Josh Poimboeuf <jpoimboe@redhat.com>
+    * Kirill A. Shutemov <kirill@shutemov.name>
+    * Luke Macken <lmacken@redhat.com>
+    * Mantas Mikulėnas <grawity@gmail.com>
+    * Patrick Brisbin <pbrisbin@gmail.com>
+    * Philippe Le Brouster <plb@nebkha.net>
+    * Raghavendra D Prabhu <rprabhu@wnohang.net>
+    * Sami Farin <hvtaifwkbgefbaei@gmail.com>
+    * Stefan Assmann <sassmann@kpanic.de>
+    * Stefan Kuhn <p_regius@gmx.ch>
+    * Tim Stoakes <tim@stoakes.net>
+    * Vladimir Marek <Vladimir.Marek@oracle.com>
+    * Víctor Manuel Jáquez Leal <vjaquez@igalia.com>
+    * Richard Russon <rich@flatcap.org>
+
diff --git a/UPDATING b/UPDATING
index db5cd6f..ded9ea4 100644
--- a/UPDATING
+++ b/UPDATING
@@ -12,6 +12,10 @@ The keys used are:
 
   ! Bug fix release.  No features were modified or added.
 
+1.6.1 (2016-05-01):
+
+  ! Bug fix release.  No features were modified or added.
+
 1.6.0 (2016-04-04):
 
   + Enabled utf-8 mailbox support for IMAP.
diff --git a/UPDATING.kz b/UPDATING.kz
new file mode 100644
index 0000000..1df36c0
--- /dev/null
+++ b/UPDATING.kz
@@ -0,0 +1,68 @@
+1.6.0.1:
+
++ rebase to mutt upstream 1.6.0
++ update to the new sidebar implementation. Note that all .muttrc options 
+  are prefixed by "sidebar_" now.
+
++ rebase is based on neomutt project (see https://github.com/neomutt) where are
+  maintained all non-upstream mutt changes, so it's easy to merge another
+  features like "trash", "ifdef", ... to mutt-kz.
+
++ the stable mutt-kz releases and tags are maintained in stable/v<version> branches, 
+  the master branch is going to be *rebased*. This development model help us to be 
+  up to date with mutt upstream.
+
+
+1.5.23.1:
+
++ integrated color status patch (original from Thomas Glanzmann)
+  https://thomas.glanzmann.de//mutt/#cstatus
++ integrated TLS Server Name Indication support patch (original from Phil Pennock)
++ improved sidebar functionality to optinaly show only folders with new emails
+  (sidebar-new, sitebar-next, ...)
+
++ fix notmuch DB usage
++ use unlocked libc IO in improve performance
++ security bug fix from original mutt
+
++ sync with the original mutt upstream
++ add sidebar_whitelist option
++ oppenc & pgp upstream sync and improvements
+
+
+1.5.22.1:
+
++ use git and github rather than hg to maintain source code
+
++ virtual folders based on notmuch queries
++ merge sidebar patch
++ merge index-color patch
+
++ <change-vfolder> command
++ <vfolder-from-query> command
++ <modify-labels> command to set/unset notmuch tags
++ <modify-labels-then-hide> command to set/unset notmuch tags and hide email
+  from the current view
++ <quasi-delete> command to delete message from mutt, but don't touch message
+  on the disk
++ <entire-thread> command to add to the current list of the messages all
+  messages that belongs to the same thread as the current message
++ ~Y EXPR  pattern modifier for notmuch labels for limit, tag-pattern,
+  delete-pattern, color etc.
++ virtual-mailboxes <desc> <uri> [...]  to specify list of the virtual mailboxes
++ virtual_spoolfile = <boolean> to use the first virtual mailbox as a spoolfile
++ tag-transforms <tag> <transform> to transform tag name to another name
++ tag-formats <tag> <format sequence> [ ...] to define tag specific formatting
+  sequence for $index_format
++ nm_record = <boolean> to add sent emails (mutt record) to notmuch DB
++ nm_record_tags = <comma delimited list> to specify tags for nm_record
++ nm_open_timeout = <seconds> to specify timeout for notmuch database
++ nm_default_uri = <uri>  the default URI to connect notmuch
++ nm_hidden_tags = <comma delimited list> to make some tags invisible for mutt user
++ nm_exclude_tags = <comma delimited list> - messages tagged with these tags
+  are excluded and not loaded from notmuch DB to mutt unless specified explicitly
++ nm_unread_tag = <name> to specify unread messages
++ nm_db_limit = <num> to specify notmuch query limit
++ nm_query_type = <threads|messages> to specify what to load from DB
++ vfolder_format = <string> to specify vfolders browser entry format
++ %g and %Gx index_format and pager_format formatting sequences
diff --git a/browser.c b/browser.c
index 5712f63..90765f0 100644
--- a/browser.c
+++ b/browser.c
@@ -29,9 +29,13 @@
 #include "sort.h"
 #include "mailbox.h"
 #include "browser.h"
+#include "mx.h"
 #ifdef USE_IMAP
 #include "imap.h"
 #endif
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
 #ifdef USE_NNTP
 #include "nntp.h"
 #endif
@@ -216,6 +220,12 @@ folder_format_str (char *dest, size_t destlen, size_t col, int cols, char op, co
     case 'f':
     {
       char *s;
+
+#ifdef USE_NOTMUCH
+      if (mx_is_notmuch(folder->ff->name))
+        s = NONULL (folder->ff->desc);
+      else
+#endif
 #ifdef USE_IMAP
       if (folder->ff->imap)
 	s = NONULL (folder->ff->desc);
@@ -299,6 +309,18 @@ folder_format_str (char *dest, size_t destlen, size_t col, int cols, char op, co
 	break;
       }
 #endif
+#ifdef USE_NOTMUCH
+      if (mx_is_notmuch (folder->ff->name))
+      {
+	if (!optional)
+	{
+	  snprintf (tmp, sizeof (tmp), "%%%sd", fmt);
+	  snprintf (dest, destlen, tmp, folder->ff->new);
+	} else if (!folder->ff->new)
+	  optional = 0;
+	break;
+      }
+#endif
       snprintf (tmp, sizeof (tmp), "%%%sc", fmt);
       snprintf (dest, destlen, tmp, folder->ff->new ? 'N' : ' ');
       break;
@@ -599,6 +621,32 @@ static int examine_directory (MUTTMENU *menu, struct browser_state *state,
   return 0;
 }
 
+#ifdef USE_NOTMUCH
+static int examine_vfolders (MUTTMENU *menu, struct browser_state *state)
+{
+  BUFFY *tmp = VirtIncoming;
+
+  if (!VirtIncoming)
+    return (-1);
+  mutt_buffy_check (0);
+
+  init_state (state, menu);
+
+  do
+  {
+    if (mx_is_notmuch (tmp->path))
+    {
+      nm_nonctx_get_count(tmp->path, &tmp->msg_count, &tmp->msg_unread);
+      add_folder (menu, state, tmp->path, NULL, NULL, tmp->msg_unread);
+      continue;
+    }
+  }
+  while ((tmp = tmp->next));
+  browser_sort (state);
+  return 0;
+}
+#endif
+
 /* get list of mailboxes/subscribed newsgroups */
 static int examine_mailboxes (MUTTMENU *menu, struct browser_state *state)
 {
@@ -703,6 +751,13 @@ static int select_file_search (MUTTMENU *menu, regex_t *re, int n)
   return (regexec (re, ((struct folder_file *) menu->data)[n].name, 0, NULL, 0));
 }
 
+#ifdef USE_NOTMUCH
+static int select_vfolder_search (MUTTMENU *menu, regex_t *re, int n)
+{
+  return (regexec (re, ((struct folder_file *) menu->data)[n].desc, 0, NULL, 0));
+}
+#endif
+
 static void folder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
 {
   FOLDER folder;
@@ -720,6 +775,19 @@ static void folder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
       (unsigned long) &folder, M_FORMAT_ARROWCURSOR);
 }
 
+#ifdef USE_NOTMUCH
+static void vfolder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
+{
+  FOLDER folder;
+
+  folder.ff = &((struct folder_file *) menu->data)[num];
+  folder.num = num;
+
+  mutt_FormatString (s, slen, 0, COLS - SidebarWidth, NONULL(VirtFolderFormat), folder_format_str,
+      (unsigned long) &folder, M_FORMAT_ARROWCURSOR);
+}
+#endif
+
 static void init_menu (struct browser_state *state, MUTTMENU *menu, char *title,
 		       size_t titlelen, int buffy)
 {
@@ -796,7 +864,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
   int buffy    = (flags & M_SEL_BUFFY)  ? 1 : 0;
 
   buffy = buffy && folder;
-  
+
   memset (&state, 0, sizeof (struct browser_state));
 
   if (!folder)
@@ -874,13 +942,17 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
     }
 #endif
   }
-  else 
+#ifdef USE_NOTMUCH
+  else if (!(flags & M_SEL_VFOLDER))
+#else
+  else
+#endif
   {
     if (!folder)
       getcwd (LastDir, sizeof (LastDir));
     else if (!LastDir[0])
       strfcpy (LastDir, NONULL(Maildir), sizeof (LastDir));
-    
+
 #ifdef USE_IMAP
     if (!buffy && mx_is_imap (LastDir))
     {
@@ -902,6 +974,12 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 
   *f = 0;
 
+#ifdef USE_NOTMUCH
+  if (flags & M_SEL_VFOLDER) {
+    if (examine_vfolders (NULL, &state) == -1)
+      goto bail;
+  } else
+#endif
   if (buffy)
   {
     if (examine_mailboxes (NULL, &state) == -1)
@@ -911,17 +989,25 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 #ifdef USE_IMAP
   if (!state.imap_browse)
 #endif
+  {
   if (examine_directory (NULL, &state, LastDir, prefix) == -1)
     goto bail;
-
+  }
   menu = mutt_new_menu (MENU_FOLDER);
-  menu->make_entry = folder_entry;
   menu->search = select_file_search;
   menu->title = title;
   menu->data = state.entry;
   if (multiple)
     menu->tag = file_tag;
 
+#ifdef USE_NOTMUCH
+  if (flags & M_SEL_VFOLDER) {
+    menu->make_entry = vfolder_entry;
+    menu->search = select_vfolder_search;
+  } else
+#endif
+    menu->make_entry = folder_entry;
+
   menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_FOLDER,
 #ifdef USE_NNTP
     option (OPTNEWS) ? FolderNewsHelp :
@@ -1077,6 +1163,10 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
 	else if (state.imap_browse)
           strfcpy (f, state.entry[menu->current].name, flen);
 #endif
+#ifdef USE_NOTMUCH
+	else if (mx_is_notmuch(state.entry[menu->current].name))
+	  strfcpy (f, state.entry[menu->current].name, flen);
+#endif
 	else
 	  mutt_concat_path (f, LastDir, state.entry[menu->current].name, flen);
 
@@ -1223,7 +1313,7 @@ void _mutt_select_file (char *f, size_t flen, int flags, char ***files, int *num
         }
         break;
 #endif
-      
+
       case OP_CHANGE_DIRECTORY:
 
 #ifdef USE_NNTP
diff --git a/buffy.c b/buffy.c
index f1e5d5a..7d90ca4 100644
--- a/buffy.c
+++ b/buffy.c
@@ -35,6 +35,10 @@
 #include "imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include <string.h>
 #include <sys/stat.h>
 #include <dirent.h>
@@ -216,6 +220,8 @@ static BUFFY *buffy_new (const char *path)
 
 static void buffy_free (BUFFY **mailbox)
 {
+  if (mailbox && *mailbox)
+    FREE (&(*mailbox)->desc);
   FREE (mailbox); /* __FREE_CHECKED__ */
 }
 
@@ -461,66 +467,67 @@ static int buffy_mbox_check (BUFFY* mailbox, struct stat *sb, int check_stats)
   return rc;
 }
 
-/* Check all Incoming for new mail and total/new/flagged messages
- * force: if true, ignore BuffyTimeout and check for new mail anyway
- */
-int mutt_buffy_check (int force)
+#ifdef USE_NOTMUCH
+int mutt_parse_virtual_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *err)
 {
-  BUFFY *tmp;
-  struct stat sb;
-  struct stat contex_sb;
-  time_t t;
-  int check_stats = 0;
-#ifdef USE_SIDEBAR
-  short orig_new;
-  int orig_count, orig_unread, orig_flagged;
-#endif
+  BUFFY **tmp;
+  char buf[_POSIX_PATH_MAX + LONG_STRING + 32];   /* path to DB + query + URI "decoration" */
 
-  sb.st_size=0;
-  contex_sb.st_dev=0;
-  contex_sb.st_ino=0;
+  while (MoreArgs (s))
+  {
+    char *desc;
 
-#ifdef USE_IMAP
-  /* update postponed count as well, on force */
-  if (force)
-    mutt_update_num_postponed ();
-#endif
+    mutt_extract_token (path, s, 0);
+    if (path->data && *path->data)
+      desc = safe_strdup( path->data);
+    else
+      continue;
 
-  /* fastest return if there are no mailboxes */
-  if (!Incoming)
-    return 0;
-  t = time (NULL);
-  if (!force && (t - BuffyTime < BuffyTimeout))
-    return BuffyCount;
+    mutt_extract_token (path, s, 0);
+    strfcpy (buf, path->data, sizeof (buf));
 
-  if (option (OPTMAILCHECKSTATS) &&
-      (t - BuffyStatsTime >= BuffyCheckStatsInterval))
-  {
-    check_stats = 1;
-    BuffyStatsTime = t;
-  }
+    /* Skip empty tokens. */
+    if(!*buf) {
+	    FREE(&desc);
+	    continue;
+    }
 
-  BuffyTime = t;
-  BuffyCount = 0;
-  BuffyNotify = 0;
+    /* avoid duplicates */
+    for (tmp = &VirtIncoming; *tmp; tmp = &((*tmp)->next))
+    {
+      if (mutt_strcmp (buf, (*tmp)->path) == 0)
+      {
+	dprint(3,(debugfile,"virtual mailbox '%s' already registered as '%s'\n", buf, (*tmp)->path));
+	break;
+      }
+    }
 
-#ifdef USE_IMAP
-  BuffyCount += imap_buffy_check (force, check_stats);
-#endif
+    if (!*tmp)
+      *tmp = buffy_new (buf);
 
-  /* check device ID and serial number instead of comparing paths */
-  if (!Context || Context->magic == M_IMAP || Context->magic == M_POP
-#ifdef USE_NNTP
-      || Context->magic == M_NNTP
+    (*tmp)->new = 0;
+    (*tmp)->notified = 1;
+    (*tmp)->newly_created = 0;
+    (*tmp)->size = 0;
+    (*tmp)->desc = desc;
+#ifdef USE_SIDEBAR
+    mutt_sb_notify_mailbox (*tmp, 1);
 #endif
-      || stat (Context->path, &contex_sb) != 0)
-  {
-    contex_sb.st_dev=0;
-    contex_sb.st_ino=0;
   }
-  
-  for (tmp = Incoming; tmp; tmp = tmp->next)
-  {
+  return 0;
+}
+#endif
+
+static void buffy_check (BUFFY *tmp, struct stat *contex_sb, int check_stats)
+{
+    struct stat sb;
+#ifdef USE_SIDEBAR
+    short orig_new;
+    int orig_count, orig_unread, orig_flagged;
+#endif
+
+    sb.st_size=0;
+
 #ifdef USE_SIDEBAR
     orig_new = tmp->new;
     orig_count = tmp->msg_count;
@@ -536,6 +543,11 @@ int mutt_buffy_check (int force)
 	tmp->magic = M_POP;
       else
 #endif
+#ifdef USE_NOTMUCH
+      if (mx_is_notmuch (tmp->path))
+	tmp->magic = M_NOTMUCH;
+      else
+#endif
 #ifdef USE_NNTP
       if ((tmp->magic == M_NNTP) || mx_is_nntp (tmp->path))
 	tmp->magic = M_NNTP;
@@ -549,7 +561,7 @@ int mutt_buffy_check (int force)
 	tmp->newly_created = 1;
 	tmp->magic = 0;
 	tmp->size = 0;
-	continue;
+	return;
       }
     }
 
@@ -559,10 +571,10 @@ int mutt_buffy_check (int force)
 #ifdef USE_NNTP
 	(( tmp->magic == M_IMAP || tmp->magic == M_POP || tmp->magic == M_NNTP )
 #else
-	(( tmp->magic == M_IMAP || tmp->magic == M_POP )
+	(( tmp->magic == M_IMAP || tmp->magic == M_POP || tmp->magic == M_NOTMUCH)
 #endif
 	    ? mutt_strcmp (tmp->path, Context->path) :
-	      (sb.st_dev != contex_sb.st_dev || sb.st_ino != contex_sb.st_ino)))
+	      (sb.st_dev != contex_sb->st_dev || sb.st_ino != contex_sb->st_ino)))
     {
       switch (tmp->magic)
       {
@@ -581,6 +593,18 @@ int mutt_buffy_check (int force)
           if (mh_buffy (tmp, check_stats) > 0)
             BuffyCount++;
           break;
+#ifdef USE_NOTMUCH
+        case M_NOTMUCH:
+          tmp->msg_count = 0;
+          tmp->msg_unread = 0;
+          tmp->msg_flagged = 0;
+          nm_nonctx_get_count(tmp->path, &tmp->msg_count, &tmp->msg_unread);
+          if (tmp->msg_unread > 0) {
+            BuffyCount++;
+            tmp->new = 1;
+          }
+          break;
+#endif
       }
     }
     else if (option(OPTCHECKMBOXSIZE) && Context && Context->path)
@@ -598,8 +622,72 @@ int mutt_buffy_check (int force)
       tmp->notified = 0;
     else if (!tmp->notified)
       BuffyNotify++;
+}
+
+/* Check all Incoming for new mail and total/new/flagged messages
+ * force: if true, ignore BuffyTimeout and check for new mail anyway
+ */
+int mutt_buffy_check (int force)
+{
+  BUFFY *tmp;
+  struct stat contex_sb;
+  time_t t;
+  int check_stats = 0;
+  contex_sb.st_dev=0;
+  contex_sb.st_ino=0;
+
+#ifdef USE_IMAP
+  /* update postponed count as well, on force */
+  if (force)
+    mutt_update_num_postponed ();
+#endif
+
+  /* fastest return if there are no mailboxes */
+#ifdef USE_NOTMUCH
+  if (!Incoming && !VirtIncoming)
+    return 0;
+#else
+  if (!Incoming)
+    return 0;
+#endif
+  t = time (NULL);
+  if (!force && (t - BuffyTime < BuffyTimeout))
+    return BuffyCount;
+
+  if (option (OPTMAILCHECKSTATS) &&
+      (t - BuffyStatsTime >= BuffyCheckStatsInterval))
+  {
+    check_stats = 1;
+    BuffyStatsTime = t;
   }
 
+  BuffyTime = t;
+  BuffyCount = 0;
+  BuffyNotify = 0;
+
+#ifdef USE_IMAP
+  BuffyCount += imap_buffy_check (force, check_stats);
+#endif
+
+  /* check device ID and serial number instead of comparing paths */
+  if (!Context || Context->magic == M_IMAP || Context->magic == M_POP
+#ifdef USE_NNTP
+      || Context->magic == M_NNTP
+#endif
+      || stat (Context->path, &contex_sb) != 0)
+  {
+    contex_sb.st_dev=0;
+    contex_sb.st_ino=0;
+  }
+
+  for (tmp = Incoming; tmp; tmp = tmp->next)
+    buffy_check(tmp, &contex_sb, check_stats);
+
+#ifdef USE_NOTMUCH
+  for (tmp = VirtIncoming; tmp; tmp = tmp->next)
+    buffy_check(tmp, &contex_sb, check_stats);
+#endif
+
   BuffyDoneTime = BuffyTime;
   return (BuffyCount);
 }
@@ -714,6 +802,35 @@ void mutt_buffy (char *s, size_t slen)
   *s = '\0';
 }
 
+#ifdef USE_NOTMUCH
+void mutt_buffy_vfolder (char *s, size_t slen)
+{
+  BUFFY *tmp;
+  int pass, found = 0;
+
+  if (mutt_buffy_check (0))
+  {
+    for (pass = 0; pass < 2; pass++) {
+      for (tmp = VirtIncoming; tmp; tmp = tmp->next)
+      {
+	if ((found || pass) && tmp->new)
+	{
+	  strfcpy (s, tmp->desc, slen);
+	  return;
+	}
+	if (mutt_strcmp (s, tmp->path) == 0)
+	  found = 1;
+      }
+    }
+
+    mutt_buffy_check (1); /* buffy was wrong - resync things */
+  }
+
+  /* no folders with new mail */
+  *s = '\0';
+}
+#endif
+
 /* fetch buffy object for given path, if present */
 static BUFFY* buffy_get (const char *path)
 {
diff --git a/buffy.h b/buffy.h
index 16191f8..f77bda2 100644
--- a/buffy.h
+++ b/buffy.h
@@ -28,6 +28,7 @@ typedef struct buffy_t
   char path[_POSIX_PATH_MAX];
   char realpath[_POSIX_PATH_MAX]; /* used for duplicate detection, context comparison,
                                      and the sidebar */
+  char *desc;
   off_t size;
   struct buffy_t *next;
   short new;			/* mailbox has new mail */
@@ -49,6 +50,11 @@ WHERE BUFFY *Incoming INITVAL (0);
 WHERE short BuffyTimeout INITVAL (3);
 WHERE short BuffyCheckStatsInterval INITVAL (60);
 
+#ifdef USE_NOTMUCH
+WHERE BUFFY *VirtIncoming INITVAL (0);
+void mutt_buffy_vfolder (char *s, size_t slen);
+#endif
+
 extern time_t BuffyDoneTime;	/* last time we knew for sure how much mail there was */
 
 BUFFY *mutt_find_mailbox (const char *path);
diff --git a/color.c b/color.c
index ff69f41..172bc59 100644
--- a/color.c
+++ b/color.c
@@ -39,6 +39,9 @@ COLOR_LINE *ColorIndexList = NULL;
 COLOR_LINE *ColorIndexAuthorList = NULL;
 COLOR_LINE *ColorIndexFlagsList = NULL;
 COLOR_LINE *ColorIndexSubjectList = NULL;
+#ifdef USE_NOTMUCH
+COLOR_LINE *ColorIndexTagList = NULL;
+#endif
 
 /* local to this file */
 static int ColorQuoteSize;
@@ -106,6 +109,10 @@ static const struct mapping_t Fields[] =
   { "index_number",	MT_COLOR_INDEX_NUMBER },
   { "index_size",	MT_COLOR_INDEX_SIZE },
   { "index_subject",	MT_COLOR_INDEX_SUBJECT },
+#ifdef USE_NOTMUCH
+  { "index_tag",	MT_COLOR_INDEX_TAG },
+  { "index_tags",	MT_COLOR_INDEX_TAGS },
+#endif
   { "prompt",		MT_COLOR_PROMPT },
 #ifdef USE_SIDEBAR
   { "sidebar_divider",	MT_COLOR_DIVIDER },
@@ -520,6 +527,10 @@ static int _mutt_parse_uncolor (BUFFER *buf, BUFFER *s, unsigned long data,
     mutt_do_uncolor (buf, s, &ColorIndexFlagsList, &do_cache, parse_uncolor);
   else if (object == MT_COLOR_INDEX_SUBJECT)
     mutt_do_uncolor (buf, s, &ColorIndexSubjectList, &do_cache, parse_uncolor);
+#ifdef USE_NOTMUCH
+  else if (object == MT_COLOR_INDEX_TAG)
+    mutt_do_uncolor(buf, s, &ColorIndexTagList, &do_cache, parse_uncolor);
+#endif
 
   if (do_cache && !option (OPTNOCURSES))
   {
@@ -765,8 +776,11 @@ _mutt_parse_color (BUFFER *buf, BUFFER *s, BUFFER *err,
       (object == MT_COLOR_INDEX) ||
       (object == MT_COLOR_INDEX_AUTHOR) ||
       (object == MT_COLOR_INDEX_FLAGS) ||
-      (object == MT_COLOR_INDEX_SUBJECT))
-  {
+      (object == MT_COLOR_INDEX_SUBJECT)
+#ifdef USE_NOTMUCH
+      || (object == MT_COLOR_INDEX_TAG)
+#endif
+      ) {
     if (!MoreArgs (s)) {
       strfcpy (err->data, _("too few arguments"), err->dsize);
       return -1;
@@ -804,7 +818,7 @@ _mutt_parse_color (BUFFER *buf, BUFFER *s, BUFFER *err,
   else if (object == MT_COLOR_BODY)
     r = add_pattern (&ColorBodyList, buf->data, 1, fg, bg, attr, err, 0, match);
   else if ((object == MT_COLOR_STATUS) && MoreArgs (s)) {
-    /* 'color status fg bg' can have upto 2 arguments:
+    /* 'color status fg bg' can have up to 2 arguments:
      * 0 arguments: sets the default status color (handled below by else part)
      * 1 argument : colorize pattern on match
      * 2 arguments: colorize nth submatch of pattern
@@ -845,6 +859,14 @@ _mutt_parse_color (BUFFER *buf, BUFFER *s, BUFFER *err,
 		    fg, bg, attr, err, 1, match);
     set_option (OPTFORCEREDRAWINDEX);
   }
+#ifdef USE_NOTMUCH
+  else if (object == MT_COLOR_INDEX_TAG)
+  {
+    r = add_pattern (&ColorIndexTagList, buf->data, 1,
+		    fg, bg, attr, err, 1, match);
+    set_option (OPTFORCEREDRAWINDEX);
+  }
+#endif
   else if (object == MT_COLOR_QUOTED)
   {
     if (q_level >= ColorQuoteSize)
diff --git a/commands.c b/commands.c
index 4970c3a..1af59f4 100644
--- a/commands.c
+++ b/commands.c
@@ -40,6 +40,10 @@
 #include "imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "buffy.h"
 
 #include <errno.h>
@@ -61,6 +65,7 @@ int mutt_display_message (HEADER *cur)
   char tempfile[_POSIX_PATH_MAX], buf[LONG_STRING];
   int rc = 0, builtin = 0;
   int cmflags = M_CM_DECODE | M_CM_DISPLAY | M_CM_CHARCONV;
+  int chflags;
   FILE *fpout = NULL;
   FILE *fpfilterout = NULL;
   pid_t filterpid = -1;
@@ -145,8 +150,14 @@ int mutt_display_message (HEADER *cur)
     fputs ("\n\n", fpout);
   }
 
-  res = mutt_copy_message (fpout, Context, cur, cmflags,
-       	(option (OPTWEED) ? (CH_WEED | CH_REORDER) : 0) | CH_DECODE | CH_FROM | CH_DISPLAY);
+  chflags = (option (OPTWEED) ? (CH_WEED | CH_REORDER) : 0)
+           | CH_DECODE | CH_FROM | CH_DISPLAY;
+#ifdef USE_NOTMUCH
+  if (Context->magic == M_NOTMUCH)
+    chflags |= CH_VIRTUAL;
+#endif
+  res = mutt_copy_message (fpout, Context, cur, cmflags, chflags);
+
   if ((safe_fclose (&fpout) != 0 && errno != EPIPE) || res < 0)
   {
     mutt_error (_("Could not copy message"));
@@ -851,19 +862,30 @@ int mutt_save_message (HEADER *h, int delete,
     }
     else
     {
+      int rc = 0;
+
+#ifdef USE_NOTMUCH
+      if (Context->magic == M_NOTMUCH)
+        nm_longrun_init(Context, TRUE);
+#endif
       for (i = 0; i < Context->vcount; i++)
       {
 	if (Context->hdrs[Context->v2r[i]]->tagged)
 	{
 	  mutt_message_hook (Context, Context->hdrs[Context->v2r[i]], M_MESSAGEHOOK);
-	  if (_mutt_save_message(Context->hdrs[Context->v2r[i]],
-			     &ctx, delete, decode, decrypt) != 0)
-          {
-            mx_close_mailbox (&ctx, NULL);
-            return -1;
-          }
+	  if ((rc = _mutt_save_message(Context->hdrs[Context->v2r[i]],
+			     &ctx, delete, decode, decrypt) != 0))
+	    break;
 	}
       }
+#ifdef USE_NOTMUCH
+      if (Context->magic == M_NOTMUCH)
+        nm_longrun_done(Context);
+#endif
+      if (rc != 0) {
+	mx_close_mailbox (&ctx, NULL);
+	return -1;
+      }
     }
 
     need_buffy_cleanup = (ctx.magic == M_MBOX || ctx.magic == M_MMDF);
diff --git a/compose.c b/compose.c
index e528e0c..d555d92 100644
--- a/compose.c
+++ b/compose.c
@@ -836,7 +836,8 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	  numfiles = 0;
 	  files = NULL;
 
-	  if (_mutt_enter_fname (prompt, fname, sizeof (fname), &menu->redraw, 0, 1, &files, &numfiles) == -1 ||
+	  if (_mutt_enter_fname (prompt, fname, sizeof (fname),
+			&menu->redraw, 0, 1, &files, &numfiles, 0) == -1 ||
 	      *fname == '\0')
 	    break;
 
@@ -1407,7 +1408,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
          if (msg->content->next)
            msg->content = mutt_make_multipart (msg->content);
 
-         if (mutt_write_fcc (fname, msg, NULL, 0, NULL) < 0)
+         if (mutt_write_fcc (fname, msg, NULL, 0, NULL, NULL) < 0)
            msg->content = mutt_remove_multipart (msg->content);
          else
            mutt_message _("Message written.");
diff --git a/configure.ac b/configure.ac
index 19a9012..7ee23b2 100644
--- a/configure.ac
+++ b/configure.ac
@@ -191,6 +191,30 @@ AS_IF([test x$enable_sidebar = "xyes"], [
 	   MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS sidebar.o"
 ])
 
+AC_ARG_ENABLE(notmuch, AC_HELP_STRING([--enable-notmuch], [Enable NOTMUCH support]), enable_notmuch=$enableval, enable_notmuch=no)
+AS_IF([test x$enable_notmuch = "xyes"], [
+		AC_CHECK_LIB(notmuch, notmuch_database_open,,
+			AC_MSG_ERROR([Unable to find Notmuch library]))
+		AC_DEFINE(USE_NOTMUCH,1,[ Define if you want support for the notmuch. ])
+		NOTMUCH_LIBS="-lnotmuch"
+		OPS="$OPS \$(srcdir)/OPS.NOTMUCH"
+		need_notmuch="yes"
+
+		AC_MSG_CHECKING([for notmuch api version 3])
+		AC_COMPILE_IFELSE( [AC_LANG_PROGRAM(
+					[[#include <notmuch.h>]],
+					[[notmuch_database_open("/path", NOTMUCH_DATABASE_MODE_READ_ONLY, (notmuch_database_t**)NULL);]]
+					)],
+		[notmuch_api_3=yes
+			AC_DEFINE([NOTMUCH_API_3], 1, [Define to 1 if you have the notmuch api version 3.])
+			],
+		[notmuch_api_3=no]
+		)
+		AC_MSG_RESULT([$notmuch_api_3])
+])
+AM_CONDITIONAL(BUILD_NOTMUCH, test x$need_notmuch = xyes)
+
+
 AC_ARG_WITH(mixmaster, AS_HELP_STRING([--with-mixmaster@<:@=PATH@:>@],[Include Mixmaster support]),
   [if test "$withval" != no
    then
@@ -327,7 +351,7 @@ main ()
 AC_HEADER_STDC
 
 AC_CHECK_HEADERS(stdarg.h sys/ioctl.h ioctl.h sysexits.h)
-AC_CHECK_HEADERS(sys/time.h sys/resource.h)
+AC_CHECK_HEADERS(sys/time.h sys/resource.h sys/syscall.h)
 AC_CHECK_HEADERS(unix.h)
 
 AC_CHECK_FUNCS(setrlimit getsid)
@@ -1092,6 +1116,7 @@ AC_SUBST(MUTTLIBS)
 AC_SUBST(MUTT_LIB_OBJECTS)
 AC_SUBST(LIBIMAP)
 AC_SUBST(LIBIMAPDEPS)
+AC_SUBST(NOTMUCH_LIBS)
 
 dnl -- iconv/gettext --
 
diff --git a/copy.c b/copy.c
index a09ba57..4167411 100644
--- a/copy.c
+++ b/copy.c
@@ -30,6 +30,10 @@
 #include "mutt_idna.h"
 #include "mutt_curses.h"
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include <string.h>
 #include <stdlib.h>
 #include <ctype.h>
@@ -344,6 +348,7 @@ mutt_copy_hdr (FILE *in, FILE *out, LOFF_T off_start, LOFF_T off_end, int flags,
 	CH_NOQFROM      ignore ">From " line
 	CH_UPDATE_IRT	update the In-Reply-To: header
 	CH_UPDATE_REFS	update the References: header
+	CH_VIRTUAL      write virtual header lines too
 
    prefix
    	string to use if CH_PREFIX is set
@@ -357,7 +362,7 @@ mutt_copy_header (FILE *in, HEADER *h, FILE *out, int flags, const char *prefix)
   if (h->env)
     flags |= (h->env->irt_changed ? CH_UPDATE_IRT : 0)
       | (h->env->refs_changed ? CH_UPDATE_REFS : 0);
-  
+
   if (mutt_copy_hdr (in, out, h->offset, h->content->offset, flags, prefix) == -1)
     return -1;
 
@@ -423,6 +428,15 @@ mutt_copy_header (FILE *in, HEADER *h, FILE *out, int flags, const char *prefix)
       fprintf (out, "Lines: %d\n", h->lines);
   }
 
+#ifdef USE_NOTMUCH
+  if ((flags & CH_VIRTUAL) && nm_header_get_tags(h))
+  {
+    fputs ("Tags: ", out);
+    fputs (nm_header_get_tags(h), out);
+    fputc ('\n', out);
+  }
+#endif
+
   if (flags & CH_UPDATE_LABEL && h->label_changed)
   {
     h->label_changed = 0;
@@ -750,7 +764,7 @@ mutt_copy_message (FILE *fpout, CONTEXT *src, HEADER *hdr, int flags,
 {
   MESSAGE *msg;
   int r;
-  
+
   if ((msg = mx_open_message (src, hdr->msgno)) == NULL)
     return -1;
   if ((r = _mutt_copy_message (fpout, msg->fp, hdr, hdr->content, flags, chflags)) == 0 
@@ -785,7 +799,7 @@ _mutt_append_message (CONTEXT *dest, FILE *fpin, CONTEXT *src, HEADER *hdr,
   fseeko (fpin, hdr->offset, 0);
   if (fgets (buf, sizeof (buf), fpin) == NULL)
     return -1;
-  
+
   if ((msg = mx_open_new_message (dest, hdr, is_from (buf, NULL, 0, NULL) ? 0 : M_ADD_FROM)) == NULL)
     return -1;
   if (dest->magic == M_MBOX || dest->magic == M_MMDF)
@@ -795,6 +809,11 @@ _mutt_append_message (CONTEXT *dest, FILE *fpin, CONTEXT *src, HEADER *hdr,
   if (mx_commit_message (msg, dest) != 0)
     r = -1;
 
+#ifdef USE_NOTMUCH
+  if (hdr && msg->commited_path && dest->magic == M_MAILDIR && src->magic == M_NOTMUCH)
+	  nm_update_filename(src, NULL, msg->commited_path, hdr);
+#endif
+
   mx_close_message (&msg);
   return r;
 }
diff --git a/copy.h b/copy.h
index 9a98d21..4dcec52 100644
--- a/copy.h
+++ b/copy.h
@@ -53,7 +53,8 @@
 #define CH_UPDATE_IRT     (1<<16) /* update In-Reply-To: */
 #define CH_UPDATE_REFS    (1<<17) /* update References: */
 #define CH_DISPLAY        (1<<18) /* display result to user */
-#define CH_UPDATE_LABEL   (1<<19) /* update X-Label: from hdr->env->x_label? */
+#define CH_VIRTUAL	  (1<<19) /* write virtual header lines too */
+#define CH_UPDATE_LABEL   (1<<20) /* update X-Label: from hdr->env->x_label? */
 
 
 int mutt_copy_hdr (FILE *, FILE *, LOFF_T, LOFF_T, int, const char *);
diff --git a/curs_lib.c b/curs_lib.c
index 3086ad7..2145946 100644
--- a/curs_lib.c
+++ b/curs_lib.c
@@ -44,6 +44,10 @@
 #include <langinfo.h>
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 /* not possible to unget more than one char under some curses libs, and it
  * is impossible to unget function keys in SLang, so roll our own input
  * buffering routines.
@@ -624,7 +628,9 @@ int mutt_do_pager (const char *banner,
   return rc;
 }
 
-int _mutt_enter_fname (const char *prompt, char *buf, size_t blen, int *redraw, int buffy, int multiple, char ***files, int *numfiles)
+int _mutt_enter_fname (const char *prompt, char *buf, size_t blen,
+		int *redraw, int buffy, int multiple,
+		char ***files, int *numfiles, int flags)
 {
   event_t ch;
 
@@ -647,8 +653,10 @@ int _mutt_enter_fname (const char *prompt, char *buf, size_t blen, int *redraw,
   {
     mutt_refresh ();
     buf[0] = 0;
-    _mutt_select_file (buf, blen, M_SEL_FOLDER | (multiple ? M_SEL_MULTI : 0), 
-		       files, numfiles);
+    if (!flags)
+      flags = M_SEL_FOLDER | (multiple ? M_SEL_MULTI : 0);
+
+    _mutt_select_file (buf, blen, flags, files, numfiles);
     *redraw = REDRAW_FULL;
   }
   else
@@ -662,6 +670,10 @@ int _mutt_enter_fname (const char *prompt, char *buf, size_t blen, int *redraw,
       buf[0] = 0;
     MAYBE_REDRAW (*redraw);
     FREE (&pc);
+#ifdef USE_NOTMUCH
+    if ((flags & M_SEL_VFOLDER) && buf[0] && strncmp(buf, "notmuch://", 10) != 0)
+      nm_description_to_path(buf, buf, blen);
+#endif
   }
 
   return 0;
diff --git a/curs_main.c b/curs_main.c
index e123c1e..5631e8a 100644
--- a/curs_main.c
+++ b/curs_main.c
@@ -42,6 +42,10 @@
 #include "imap_private.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "mutt_crypt.h"
 
 #ifdef USE_NNTP
@@ -592,6 +596,87 @@ mutt_draw_statusline (int cols, const char *buf)
 	safe_free (&syntax);
 }
 
+static int main_change_folder(MUTTMENU *menu, int op, char *buf, size_t bufsz,
+			  int *oldcount, int *index_hint, int flags)
+{
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    unset_option (OPTNEWS);
+    nntp_expand_path (buf, bufsz, &CurrentNewsSrv->conn->account);
+  }
+  else
+#endif
+  mutt_expand_path (buf, bufsz);
+  if (mx_get_magic (buf) <= 0)
+  {
+    mutt_error (_("%s is not a mailbox."), buf);
+    return -1;
+  }
+  mutt_str_replace (&CurrentFolder, buf);
+
+  /* keepalive failure in mutt_enter_fname may kill connection. #3028 */
+  if (Context && !Context->path)
+    FREE (&Context);
+
+  if (Context)
+  {
+    int check;
+
+#ifdef USE_COMPRESSED
+	  if (Context->compress_info && Context->realpath)
+	    mutt_str_replace (&LastFolder, Context->realpath);
+	  else
+#endif
+    mutt_str_replace (&LastFolder, Context->path);
+    *oldcount = Context ? Context->msgcount : 0;
+
+    if ((check = mx_close_mailbox (Context, index_hint)) != 0)
+    {
+      if (check == M_NEW_MAIL || check == M_REOPENED)
+        update_index (menu, Context, check, *oldcount, *index_hint);
+
+      set_option (OPTSEARCHINVALID);
+      menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
+      return 0;
+    }
+    FREE (&Context);
+  }
+
+  if (Labels)
+    hash_destroy(&Labels, NULL);
+
+  mutt_sleep (0);
+
+  /* Set CurrentMenu to MENU_MAIN before executing any folder
+   * hooks so that all the index menu functions are available to
+   * the exec command.
+   */
+
+  CurrentMenu = MENU_MAIN;
+  mutt_folder_hook (buf);
+
+  if ((Context = mx_open_mailbox (buf, flags, NULL)) != NULL)
+  {
+    Labels = hash_create(131, 0);
+    mutt_scan_labels(Context);
+    menu->current = ci_first_message ();
+  }
+  else
+    menu->current = 0;
+
+#ifdef USE_SIDEBAR
+        mutt_sb_set_open_buffy ();
+#endif
+
+  mutt_clear_error ();
+  mutt_buffy_check(1); /* force the buffy check after we have changed the folder */
+  menu->redraw = REDRAW_FULL;
+  set_option (OPTSEARCHINVALID);
+
+  return 0;
+}
+
 static const struct mapping_t IndexHelp[] = {
   { N_("Quit"),  OP_QUIT },
   { N_("Del"),   OP_DELETE },
@@ -911,6 +996,11 @@ int mutt_index_menu (void)
       mutt_curs_set (1);	/* fallback from the pager */
     }
 
+#ifdef USE_NOTMUCH
+    if (Context)
+      nm_debug_check(Context);
+#endif
+
 #ifdef USE_NNTP
     unset_option (OPTNEWS);	/* for any case */
 #endif
@@ -1498,6 +1588,131 @@ int mutt_index_menu (void)
 	}
 	break;
 
+#ifdef USE_NOTMUCH
+      case OP_MAIN_ENTIRE_THREAD:
+      {
+	int oldcount  = Context->msgcount;
+	if (Context->magic != M_NOTMUCH) {
+	  mutt_message _("No virtual folder, aborting.");
+	  break;
+	}
+	CHECK_MSGCOUNT;
+        CHECK_VISIBLE;
+	if (nm_read_entire_thread(Context, CURHDR) < 0) {
+	   mutt_message _("Failed to read thread, aborting.");
+	   break;
+	}
+	if (oldcount < Context->msgcount) {
+		HEADER *oldcur = CURHDR;
+
+		if ((Sort & SORT_MASK) == SORT_THREADS)
+			mutt_sort_headers (Context, 0);
+		menu->current = oldcur->virtual;
+		menu->redraw = REDRAW_STATUS | REDRAW_INDEX;
+
+		if (oldcur->collapsed || Context->collapsed) {
+			menu->current = mutt_uncollapse_thread(Context, CURHDR);
+			mutt_set_virtual(Context);
+		}
+	}
+	if (menu->menu == MENU_PAGER)
+	{
+	  op = OP_DISPLAY_MESSAGE;
+	  continue;
+	}
+	break;
+      }
+
+      case OP_MAIN_MODIFY_LABELS:
+      case OP_MAIN_MODIFY_LABELS_THEN_HIDE:
+      {
+	if (Context->magic != M_NOTMUCH) {
+	  mutt_message _("No virtual folder, aborting.");
+	  break;
+	}
+	CHECK_MSGCOUNT;
+        CHECK_VISIBLE;
+	*buf = '\0';
+	if (mutt_get_field ("Add/remove labels: ", buf, sizeof (buf), M_NM_TAG) || !*buf)
+	{
+          mutt_message _("No label specified, aborting.");
+          break;
+        }
+	if (tag)
+	{
+	  char msgbuf[STRING];
+	  progress_t progress;
+	  int px;
+
+	  if (!Context->quiet) {
+	    snprintf(msgbuf, sizeof (msgbuf), _("Update labels..."));
+	    mutt_progress_init(&progress, msgbuf, M_PROGRESS_MSG,
+				   1, Context->tagged);
+	  }
+	  nm_longrun_init(Context, TRUE);
+	  for (px = 0, j = 0; j < Context->vcount; j++) {
+	    if (Context->hdrs[Context->v2r[j]]->tagged) {
+	      if (!Context->quiet)
+		mutt_progress_update(&progress, ++px, -1);
+	      nm_modify_message_tags(Context, Context->hdrs[Context->v2r[j]], buf);
+	      if (op == OP_MAIN_MODIFY_LABELS_THEN_HIDE)
+	      {
+		Context->hdrs[Context->v2r[j]]->quasi_deleted = TRUE;
+	        Context->changed = TRUE;
+	      }
+	    }
+	  }
+	  nm_longrun_done(Context);
+	  menu->redraw = REDRAW_STATUS | REDRAW_INDEX;
+	}
+	else
+	{
+	  if (nm_modify_message_tags(Context, CURHDR, buf)) {
+	    mutt_message _("Failed to modify labels, aborting.");
+	    break;
+	  }
+	  if (op == OP_MAIN_MODIFY_LABELS_THEN_HIDE)
+	  {
+	    CURHDR->quasi_deleted = TRUE;
+	    Context->changed = TRUE;
+	  }
+	  if (menu->menu == MENU_PAGER)
+	  {
+	    op = OP_DISPLAY_MESSAGE;
+	    continue;
+	  }
+	  if (option (OPTRESOLVE))
+	  {
+	    if ((menu->current = ci_next_undeleted (menu->current)) == -1)
+	    {
+	      menu->current = menu->oldcurrent;
+	      menu->redraw = REDRAW_CURRENT;
+	    }
+	    else
+	      menu->redraw = REDRAW_MOTION_RESYNCH;
+	  }
+	  else
+	    menu->redraw = REDRAW_CURRENT;
+	}
+	menu->redraw |= REDRAW_STATUS;
+	break;
+      }
+
+      case OP_MAIN_VFOLDER_FROM_QUERY:
+	buf[0] = '\0';
+        if (mutt_get_field ("Query: ", buf, sizeof (buf), M_NM_QUERY) != 0 || !buf[0])
+        {
+          mutt_message _("No query, aborting.");
+          break;
+        }
+	if (!nm_uri_from_query(Context, buf, sizeof (buf)))
+	  mutt_message _("Failed to create query, aborting.");
+	else
+	  main_change_folder(menu, op, buf, sizeof (buf), &oldcount, &index_hint, 0);
+	break;
+
+      case OP_MAIN_CHANGE_VFOLDER:
+#endif
 #ifdef USE_SIDEBAR
       case OP_SIDEBAR_OPEN:
 #endif
@@ -1520,7 +1735,11 @@ int mutt_index_menu (void)
 
 	if (flags)
           cp = _("Open mailbox in read-only mode");
-        else
+#ifdef USE_NOTMUCH
+        else if (op == OP_MAIN_CHANGE_VFOLDER)
+	  cp = _("Open virtual folder");
+#endif
+	else
           cp = _("Open mailbox");
 
 	buf[0] = '\0';
@@ -1544,6 +1763,20 @@ int mutt_index_menu (void)
           strncpy (buf, path, sizeof (buf));
         }
 #endif
+#ifdef USE_NOTMUCH
+	else if (op == OP_MAIN_CHANGE_VFOLDER) {
+	  if (Context->magic == M_NOTMUCH) {
+		  strfcpy(buf, Context->path, sizeof (buf));
+		  mutt_buffy_vfolder (buf, sizeof (buf));
+	  }
+	  mutt_enter_vfolder (cp, buf, sizeof (buf), &menu->redraw, 1);
+	  if (!buf[0])
+	  {
+	    CLEARLINE (LINES-1);
+	    break;
+	  }
+	}
+#endif
 	else
 	{
 #ifdef USE_NNTP
@@ -1581,86 +1814,16 @@ int mutt_index_menu (void)
 	  }
 	}
 
-#ifdef USE_NNTP
-	if (option (OPTNEWS))
-	{
-	  unset_option (OPTNEWS);
-	  nntp_expand_path (buf, sizeof (buf), &CurrentNewsSrv->conn->account);
-	}
-	else
-#endif
-	mutt_expand_path (buf, sizeof (buf));
-	if (mx_get_magic (buf) <= 0)
-	{
-	  mutt_error (_("%s is not a mailbox."), buf);
-	  break;
-	}
-	mutt_str_replace (&CurrentFolder, buf);
-
-	/* keepalive failure in mutt_enter_fname may kill connection. #3028 */
-	if (Context && !Context->path)
-	  FREE (&Context);
-
-        if (Context)
-        {
-	  int check;
-
-#ifdef USE_COMPRESSED
-	  if (Context->compress_info && Context->realpath)
-	    mutt_str_replace (&LastFolder, Context->realpath);
-	  else
-#endif
-	  mutt_str_replace (&LastFolder, Context->path);
-	  oldcount = Context ? Context->msgcount : 0;
-
-	  if ((check = mx_close_mailbox (Context, &index_hint)) != 0)
-	  {
-	    if (check == M_NEW_MAIL || check == M_REOPENED)
-	      update_index (menu, Context, check, oldcount, index_hint);
-
-	    set_option (OPTSEARCHINVALID);
-	    menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
-	    break;
-	  }
-	  FREE (&Context);
-	}
-
-        if (Labels)
-          hash_destroy(&Labels, NULL);
-
-        mutt_sleep (0);
-
-	/* Set CurrentMenu to MENU_MAIN before executing any folder
-	 * hooks so that all the index menu functions are available to
-	 * the exec command.
-	 */
-
-	CurrentMenu = MENU_MAIN;
-	mutt_folder_hook (buf);
-
-	if ((Context = mx_open_mailbox (buf, flags, NULL)) != NULL)
-	{
-	  Labels = hash_create(131, 0);
-	  mutt_scan_labels(Context);
-	  menu->current = ci_first_message ();
-	}
-	else
-	  menu->current = 0;
-
-#ifdef USE_SIDEBAR
-        mutt_sb_set_open_buffy ();
-#endif
-
+	main_change_folder(menu, op, buf, sizeof (buf), &oldcount, &index_hint, flags);
 #ifdef USE_NNTP
 	/* mutt_buffy_check() must be done with mail-reader mode! */
 	menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_MAIN,
 	  (Context && (Context->magic == M_NNTP)) ? IndexNewsHelp : IndexHelp);
 #endif
-	mutt_clear_error ();
-	mutt_buffy_check(1); /* force the buffy check after we have changed
-			      the folder */
-	menu->redraw = REDRAW_FULL;
-	set_option (OPTSEARCHINVALID);
+	mutt_expand_path (buf, sizeof (buf));
+#ifdef USE_SIDEBAR
+	mutt_sb_set_open_buffy();
+#endif
 	break;
 
       case OP_DISPLAY_MESSAGE:
@@ -2803,12 +2966,21 @@ int mutt_index_menu (void)
 	toggle_option (OPTSIDEBAR);
 	menu->redraw = REDRAW_FULL;
 	break;
+
+      case OP_SIDEBAR_TOGGLE_VIRTUAL:
+	mutt_sb_toggle_virtual();
+	break;
 #endif
       default:
 	if (menu->menu == MENU_MAIN)
 	  km_error_key (MENU_MAIN);
     }
 
+#ifdef USE_NOTMUCH
+    if (Context)
+      nm_debug_check(Context);
+#endif
+
     if (menu->menu == MENU_PAGER)
     {
       menu->menu = MENU_MAIN;
diff --git a/doc/manual.xml.head b/doc/manual.xml.head
index bb72e2f..e8ee958 100644
--- a/doc/manual.xml.head
+++ b/doc/manual.xml.head
@@ -10525,7 +10525,6 @@ <sect1 id="keywords">
 
   <sect2 id="keywords-see-also">
     <title>See Also</title>
-
     <itemizedlist>
       <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
       <listitem><para><link linkend="index-format">$index_format</link></para></listitem>
@@ -11402,6 +11401,425 @@ <sect1 id="nntp">
   </sect2>
 </sect1>
 
+<sect1 id="notmuch">
+  <title>Notmuch Patch</title>
+  <subtitle>Email search engine</subtitle>
+
+  <sect2 id="notmuch-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>Notmuch</quote>, look for
+      <quote>+USE_NOTMUCH</quote> in the mutt version.
+      See: <xref linkend="compile-time-features"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.6.2</para></listitem>
+      <listitem><para><link linkend="sidebar">sidebar patch</link></para></listitem>
+      <listitem><para><link linkend="quasi-delete">quasi-delete patch</link></para></listitem>
+      <listitem><para><link linkend="index-color">index-color patch</link></para></listitem>
+      <listitem><para>Notmuch libraries</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+<!--
+  <sect2 id="notmuch-intro">
+    <title>Introduction</title>
+  </sect2>
+-->
+
+  <sect2 id="notmuch-variables">
+    <title>Variables</title>
+
+    <table id="table-notmuch-variables">
+      <title>Notmuch Variables</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Type</entry>
+            <entry>Default</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>nm_db_limit</literal></entry>
+            <entry>number</entry>
+            <entry><literal>0</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_default_uri</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nm_exclude_tags</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nm_hidden_tags</literal></entry>
+            <entry>string</entry>
+            <entry><literal>unread,draft,flagged,passed,replied,attachment,signed,encrypted</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_open_timeout</literal></entry>
+            <entry>number</entry>
+            <entry><literal>5</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_query_type</literal></entry>
+            <entry>string</entry>
+            <entry><literal>messages</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_record</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+          <row>
+            <entry><literal>nm_record_tags</literal></entry>
+            <entry>string</entry>
+            <entry>(empty)</entry>
+          </row>
+          <row>
+            <entry><literal>nm_unread_tag</literal></entry>
+            <entry>string</entry>
+            <entry><literal>unread</literal></entry>
+          </row>
+          <row>
+            <entry><literal>vfolder_format</literal></entry>
+            <entry>string</entry>
+            <entry><literal>%6n(%6N) %f</literal></entry>
+          </row>
+          <row>
+            <entry><literal>virtual_spoolfile</literal></entry>
+            <entry>boolean</entry>
+            <entry><literal>no</literal></entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="notmuch-functions">
+    <title>Functions</title>
+
+    <table id="table-notmuch-functions">
+      <title>Notmuch Functions</title>
+      <tgroup cols="4">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Default Key</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>index,pager</entry>
+            <entry>X</entry>
+            <entry><literal>&lt;change-vfolder&gt;</literal></entry>
+            <entry>open a different virtual folder</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry>+</entry>
+            <entry><literal>&lt;entire-thread&gt;</literal></entry>
+            <entry>read entire thread of the current message</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry>`</entry>
+            <entry><literal>&lt;modify-labels&gt;</literal></entry>
+            <entry>modify (notmuch) tags</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry>(none)</entry>
+            <entry><literal>&lt;modify-labels-then-hide&gt;</literal></entry>
+            <entry>modify labels and then hide message</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry>(none)</entry>
+            <entry><literal>&lt;sidebar-toggle-virtual&gt;</literal></entry>
+            <entry>toggle between mailboxes and virtual mailboxes</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry>Alt-X</entry>
+            <entry><literal>&lt;vfolder-from-query&gt;</literal></entry>
+            <entry>generate virtual folder from query</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="notmuch-commands">
+    <title>Commands</title>
+    <cmdsynopsis>
+
+      <command>virtual-mailboxes</command>
+      <arg choice="plain">
+        <replaceable class="parameter">description</replaceable>
+        <arg choice="plain">
+          <replaceable class="parameter">notmuch-URI</replaceable>
+        </arg>
+      </arg>
+      <group choice="req" rep="repeat">
+        <arg choice="plain">
+          <replaceable class="parameter">description</replaceable>
+          <arg choice="plain">
+            <replaceable class="parameter">notmuch-URI</replaceable>
+          </arg>
+        </arg>
+      </group>
+
+      <command>tag-transforms</command>
+      <arg choice="plain">
+        <replaceable class="parameter">tag</replaceable>
+        <arg choice="plain">
+          <replaceable class="parameter">transformed-string</replaceable>
+        </arg>
+      </arg>
+      <group choice="req" rep="repeat">
+        <arg choice="plain">
+          <replaceable class="parameter">tag</replaceable>
+          <arg choice="plain">
+            <replaceable class="parameter">transformed-string</replaceable>
+          </arg>
+        </arg>
+      </group>
+
+      <command>tag-formats</command>
+      <arg choice="plain">
+        <replaceable class="parameter">tag</replaceable>
+        <arg choice="plain">
+          <replaceable class="parameter">format-string</replaceable>
+        </arg>
+      </arg>
+      <group choice="req" rep="repeat">
+        <arg choice="plain">
+          <replaceable class="parameter">tag</replaceable>
+          <arg choice="plain">
+            <replaceable class="parameter">format-string</replaceable>
+          </arg>
+        </arg>
+      </group>
+
+    </cmdsynopsis>
+  </sect2>
+
+  <sect2 id="notmuch-colors">
+    <title>Colors</title>
+
+    <para>Adds these to index-color patch:</para>
+
+    <table id="table-notmuch-colors">
+      <title>Index Colors</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Object</entry>
+            <entry>Pattern</entry>
+            <entry>Highlights</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>index_tag</literal></entry>
+            <entry>yes</entry>
+            <entry>an individual message tag, %G, uses tag name</entry>
+          </row>
+          <row>
+            <entry><literal>index_tags</literal></entry>
+            <entry>no</entry>
+            <entry>the transformed message tags, %g</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+<!--
+  <sect2 id="notmuch-sort">
+    <title>Sort</title>
+  </sect2>
+-->
+
+  <sect2 id="notmuch-muttrc">
+    <title>Muttrc</title>
+
+<screen>
+<emphasis role="comment"># This is a complete list of notmuch-related configuration.
+ 
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+ 
+# This variable specifies notmuch query limit.</emphasis>
+set nm_db_limit = 0
+ 
+<emphasis role="comment"># This variable specifies the default Notmuch database in format:
+# notmuch://&lt;absolute path&gt;</emphasis>
+set nm_default_uri = ""
+ 
+<emphasis role="comment"># The messages tagged with these tags are excluded and not loaded
+# from notmuch DB to mutt unless specified explicitly.</emphasis>
+set nm_exclude_tags = ""
+ 
+<emphasis role="comment"># This variable specifies private notmuch tags which should not be printed
+# on screen (index, pager).</emphasis>
+set nm_hidden_tags = "unread,draft,flagged,passed,replied,attachment,signed,encrypted"
+ 
+<emphasis role="comment"># This option specifies timeout for Notmuch database. Default is 5 seconds.</emphasis>
+set nm_open_timeout = 5
+ 
+<emphasis role="comment"># This variable specifies notmuch query type, supported types: 'threads' and</emphasis>
+# 'messages'.
+set nm_query_type = messages
+ 
+<emphasis role="comment"># Add messages stored to the mutt record (see $record in the mutt docs)
+# also to notmuch DB.</emphasis>
+set nm_record = no
+ 
+<emphasis role="comment"># Tags that should be removed or added to the to the messages stored in the mutt record.</emphasis>
+set nm_record_tags = ""
+ 
+<emphasis role="comment"># This variable specifies notmuch tag which is used for unread messages.</emphasis>
+set nm_unread_tag = unread
+ 
+<emphasis role="comment"># This variable allows you to customize the file browser display for virtual
+# folders to your personal taste.</emphasis>
+set vfolder_format = "%6n(%6N) %f"
+ 
+<emphasis role="comment"># When set, mutt will use the first virtual mailbox (see virtual-mailboxes)
+# as a spoolfile.</emphasis>
+set virtual_spoolfile = no
+ 
+<emphasis role="comment"># --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+ 
+# open a different virtual folder</emphasis>
+bind index,pager X change-vfolder 
+ 
+<emphasis role="comment"># read entire thread of the current message</emphasis>
+bind index,pager + entire-thread 
+ 
+<emphasis role="comment"># modify (notmuch) tags</emphasis>
+bind index,pager ` modify-labels 
+ 
+<emphasis role="comment"># generate virtual folder from query</emphasis>
+bind index,pager \eX vfolder-from-query 
+ 
+<emphasis role="comment"># modify labels and then hide message
+# bind index,pager ??? modify-labels-then-hide 
+ 
+# toggle between mailboxes and virtual mailboxes
+# bind index,pager ??? sidebar-toggle-virtual 
+ 
+# --------------------------------------------------------------------------
+# COMMANDS - shown with an example
+# --------------------------------------------------------------------------
+ 
+# virtual-mailboxes description notmuch-URI { description notmuch-URI ...}
+# virtual-mailboxes "Climbing" "notmuch://?query=climbing"
+ 
+# Replace some tags with icons
+# tag-transforms tag transformed-string { tag transformed-string ...}
+# tag-transforms "inbox"   "i"   \
+#                "unread"  "u"   \
+#                "replied" "↻ "  \
+#                "sent"    "➥ "  \
+#                "todo"    "T"   \
+#                "deleted" "DEL" \
+#                "invites" "CAL"
+ 
+# See README.notmuch for an explanation
+# tag-formats tag format-string { tag format-string ...}
+# tag-formats "inbox"   "GI" \
+#              "unread"  "GU" \
+#              "replied" "GR" \
+#              "sent"    "GS" \
+#              "todo"    "Gt" \
+#              "deleted" "GD" \
+#              "invites" "Gi"
+ 
+# set index_format='4C %S %[%y.%m.%d] %-18.18n %?GU?%GU&amp; ? %?GR?%GR&amp; ? %?GI?%GI&amp; ? %s'
+ 
+# --------------------------------------------------------------------------
+# COLORS - some unpleasant examples are given
+# --------------------------------------------------------------------------
+ 
+# These symbols are added to the index-color patch:
+ 
+# an individual message tag, %G, uses tag name
+# this symbol uses a pattern</emphasis>
+color index_tag red white "inbox"
+ 
+<emphasis role="comment"># the transformed message tags, %g
+# this symbol does not use a pattern</emphasis>
+color index_tags green default
+ 
+<emphasis role="comment"># --------------------------------------------------------------------------
+ 
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="notmuch-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><ulink url="http://www.neomutt.org/">NeoMutt Project</ulink></para></listitem>
+      <listitem><para><link linkend="compile-time-features">Compile-Time Features</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="notmuch-known-bugs">
+    <title>Known Bugs</title>
+    <para>None</para>
+  </sect2>
+
+  <sect2 id="notmuch-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Karel Zak <email>kzak@redhat.com</email></para></listitem>
+    <listitem><para>Chris Mason <email>clm@fb.com</email></para></listitem>
+    <listitem><para>Christoph Rissner <email>cri@visotech.at</email></para></listitem>
+    <listitem><para>David Riebenbauer <email>davrieb@liegesta.at</email></para></listitem>
+    <listitem><para>David Sterba <email>dsterba@suse.cz</email></para></listitem>
+    <listitem><para>David Wilson <email>dw@botanicus.net</email></para></listitem>
+    <listitem><para>Don Zickus <email>dzickus@redhat.com</email></para></listitem>
+    <listitem><para>Eric Davis <email>edavis@insanum.com</email></para></listitem>
+    <listitem><para>Jan Synacek <email>jsynacek@redhat.com</email></para></listitem>
+    <listitem><para>Jeremiah C. Foster <email>jeremiah@jeremiahfoster.com</email></para></listitem>
+    <listitem><para>Josh Poimboeuf <email>jpoimboe@redhat.com</email></para></listitem>
+    <listitem><para>Kirill A. Shutemov <email>kirill@shutemov.name</email></para></listitem>
+    <listitem><para>Luke Macken <email>lmacken@redhat.com</email></para></listitem>
+    <listitem><para>Mantas Mikulėnas <email>grawity@gmail.com</email></para></listitem>
+    <listitem><para>Patrick Brisbin <email>pbrisbin@gmail.com</email></para></listitem>
+    <listitem><para>Philippe Le Brouster <email>plb@nebkha.net</email></para></listitem>
+    <listitem><para>Raghavendra D Prabhu <email>rprabhu@wnohang.net</email></para></listitem>
+    <listitem><para>Sami Farin <email>hvtaifwkbgefbaei@gmail.com</email></para></listitem>
+    <listitem><para>Stefan Assmann <email>sassmann@kpanic.de</email></para></listitem>
+    <listitem><para>Stefan Kuhn <email>p_regius@gmx.ch</email></para></listitem>
+    <listitem><para>Tim Stoakes <email>tim@stoakes.net</email></para></listitem>
+    <listitem><para>Vladimir Marek <email>Vladimir.Marek@oracle.com</email></para></listitem>
+    <listitem><para>Víctor Manuel Jáquez Leal <email>vjaquez@igalia.com</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
 <sect1 id="progress">
   <title>Progress Bar Patch</title>
   <subtitle>Show a visual progress bar on slow operations</subtitle>
@@ -12372,7 +12790,7 @@ <sect1 id="status-color">
 # First, highlight anything (*/*)</emphasis>
 color status brightred default '\([^)]+/[^)]+\)'
  
-<emphasis role="comment"># Then override the color for one specfic case</emphasis>
+<emphasis role="comment"># Then override the color for one specific case</emphasis>
 color status default   default '\(threads/last-date-received\)'
  
 <emphasis role="comment"># 2 extra parameters
diff --git a/doc/muttrc.notmuch b/doc/muttrc.notmuch
new file mode 100644
index 0000000..c752395
--- /dev/null
+++ b/doc/muttrc.notmuch
@@ -0,0 +1,114 @@
+# This is a complete list of notmuch-related configuration.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# This variable specifies notmuch query limit.
+set nm_db_limit = 0
+
+# This variable specifies the default Notmuch database in format:
+# notmuch://<absolute path>
+set nm_default_uri = ""
+
+# The messages tagged with these tags are excluded and not loaded
+# from notmuch DB to mutt unless specified explicitly.
+set nm_exclude_tags = ""
+
+# This variable specifies private notmuch tags which should not be printed
+# on screen (index, pager).
+set nm_hidden_tags = "unread,draft,flagged,passed,replied,attachment,signed,encrypted"
+
+# This option specifies timeout for Notmuch database. Default is 5 seconds.
+set nm_open_timeout = 5
+
+# This variable specifies notmuch query type, supported types: 'threads' and
+# 'messages'.
+set nm_query_type = messages
+
+# Add messages stored to the mutt record (see $record in the mutt docs)
+# also to notmuch DB.
+set nm_record = no
+
+# Tags that should be removed or added to the to the messages stored in the mutt record.
+set nm_record_tags = ""
+
+# This variable specifies notmuch tag which is used for unread messages.
+set nm_unread_tag = unread
+
+# This variable allows you to customize the file browser display for virtual
+# folders to your personal taste.
+set vfolder_format = "%6n(%6N) %f"
+
+# When set, mutt will use the first virtual mailbox (see virtual-mailboxes)
+# as a spoolfile.
+set virtual_spoolfile = no
+
+# --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# open a different virtual folder
+bind index,pager X change-vfolder
+
+# read entire thread of the current message
+bind index,pager + entire-thread
+
+# modify (notmuch) tags
+bind index,pager ` modify-labels
+
+# generate virtual folder from query
+bind index,pager \eX vfolder-from-query
+
+# modify labels and then hide message
+# bind index,pager ??? modify-labels-then-hide
+
+# toggle between mailboxes and virtual mailboxes
+# bind index,pager ??? sidebar-toggle-virtual
+
+# --------------------------------------------------------------------------
+# COMMANDS - shown with an example
+# --------------------------------------------------------------------------
+
+# virtual-mailboxes description notmuch-URI { description notmuch-URI ...}
+# virtual-mailboxes "Climbing" "notmuch://?query=climbing"
+
+# Replace some tags with icons
+# tag-transforms tag transformed-string { tag transformed-string ...}
+# tag-transforms "inbox"   "i"   \
+#                "unread"  "u"   \
+#                "replied" "↻ "  \
+#                "sent"    "➥ "  \
+#                "todo"    "T"   \
+#                "deleted" "DEL" \
+#                "invites" "CAL"
+
+# See README.notmuch for an explanation
+# tag-formats tag format-string { tag format-string ...}
+# tag-formats "inbox"   "GI" \
+#              "unread"  "GU" \
+#              "replied" "GR" \
+#              "sent"    "GS" \
+#              "todo"    "Gt" \
+#              "deleted" "GD" \
+#              "invites" "Gi"
+
+# set index_format='4C %S %[%y.%m.%d] %-18.18n %?GU?%GU& ? %?GR?%GR& ? %?GI?%GI& ? %s'
+
+# --------------------------------------------------------------------------
+# COLORS - some unpleasant examples are given
+# --------------------------------------------------------------------------
+
+# These symbols are added to the index-color patch:
+
+# an individual message tag, %G, uses tag name
+# this symbol uses a pattern
+color index_tag red white "inbox"
+
+# the transformed message tags, %g
+# this symbol does not use a pattern
+color index_tags green default
+
+# --------------------------------------------------------------------------
+
+# vim: syntax=muttrc
diff --git a/doc/muttrc.status-color b/doc/muttrc.status-color
index 385396f..9a1350c 100644
--- a/doc/muttrc.status-color
+++ b/doc/muttrc.status-color
@@ -28,7 +28,7 @@ color status brightred white '(New|Del|Flag):[0-9]+'
 # First, highlight anything (*/*)
 color status brightred default '\([^)]+/[^)]+\)'
 
-# Then override the color for one specfic case
+# Then override the color for one specific case
 color status default   default '\(threads/last-date-received\)'
 
 # 2 extra parameters
diff --git a/doc/vimrc.notmuch b/doc/vimrc.notmuch
new file mode 100644
index 0000000..918d23d
--- /dev/null
+++ b/doc/vimrc.notmuch
@@ -0,0 +1,28 @@
+" Vim syntax file for the mutt notmuch patch
+
+syntax keyword muttrcVarBool    contained skipwhite nm_record             nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    contained skipwhite virtual_spoolfile     nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarNum     contained skipwhite nm_db_limit           nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarNum     contained skipwhite nm_open_timeout       nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarStr     contained skipwhite nm_default_uri        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_exclude_tags       nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_hidden_tags        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_query_type         nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_record_tags        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite nm_unread_tag         nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite vfolder_format        nextgroup=muttrcVarEqualsIdxFmt
+
+syntax keyword muttrcCommand    virtual-mailboxes
+syntax keyword muttrcCommand    tag-transforms
+syntax keyword muttrcCommand    tag-formats
+
+syntax match muttrcFunction     contained "<change-vfolder>"
+syntax match muttrcFunction     contained "<entire-thread>"
+syntax match muttrcFunction     contained "<modify-labels-then-hide>"
+syntax match muttrcFunction     contained "<modify-labels>"
+syntax match muttrcFunction     contained "<sidebar-toggle>"
+syntax match muttrcFunction     contained "<vfolder-from-query>"
+
+" vim: syntax=vim
diff --git a/enter.c b/enter.c
index d1373ea..467bccf 100644
--- a/enter.c
+++ b/enter.c
@@ -673,6 +673,27 @@ int _mutt_enter_string (char *buf, size_t buflen, int y, int x,
 	      BEEP (); /* let the user know that nothing matched */
 	    replace_part (state, 0, buf);
 	  }
+#if USE_NOTMUCH
+	  else if (flags & M_NM_QUERY)
+	  {
+	    my_wcstombs (buf, buflen, state->wbuf, state->curpos);
+	    i = strlen (buf);
+	    if (!mutt_nm_query_complete(buf, buflen, i, state->tabs))
+	      BEEP ();
+
+	    replace_part (state, 0, buf);
+	  }
+	  else if (flags & M_NM_TAG)
+	  {
+	    my_wcstombs (buf, buflen, state->wbuf, state->curpos);
+	    i = strlen (buf);
+	    if (!mutt_nm_tag_complete(buf, buflen, i, state->tabs))
+	      BEEP ();
+
+	    replace_part (state, 0, buf);
+	  }
+
+#endif
 	  else
 	    goto self_insert;
 	  break;
diff --git a/functions.h b/functions.h
index dd1ac3e..5747425 100644
--- a/functions.h
+++ b/functions.h
@@ -199,9 +199,17 @@ const struct binding_t OpMain[] = { /* map: index */
   { "sidebar-page-up",		OP_SIDEBAR_PAGE_UP,		NULL },
   { "sidebar-prev",		OP_SIDEBAR_PREV,		NULL },
   { "sidebar-prev-new",		OP_SIDEBAR_PREV_NEW,		NULL },
+  { "sidebar-toggle-virtual",	OP_SIDEBAR_TOGGLE_VIRTUAL,	NULL },
   { "sidebar-toggle-visible",	OP_SIDEBAR_TOGGLE_VISIBLE,	NULL },
 #endif
 
+#ifdef USE_NOTMUCH
+  { "change-vfolder",		OP_MAIN_CHANGE_VFOLDER,         "X" },
+  { "vfolder-from-query",	OP_MAIN_VFOLDER_FROM_QUERY,     "\033X" },
+  { "modify-labels",		OP_MAIN_MODIFY_LABELS,		"`" },
+  { "modify-labels-then-hide",	OP_MAIN_MODIFY_LABELS_THEN_HIDE, NULL },
+  { "entire-thread",		OP_MAIN_ENTIRE_THREAD,          "+" },
+#endif
   { NULL,			0,				NULL }
 };
 
@@ -327,9 +335,18 @@ const struct binding_t OpPager[] = { /* map: pager */
   { "sidebar-page-up",		OP_SIDEBAR_PAGE_UP,		NULL },
   { "sidebar-prev",		OP_SIDEBAR_PREV,		NULL },
   { "sidebar-prev-new",		OP_SIDEBAR_PREV_NEW,		NULL },
+  { "sidebar-toggle-virtual",	OP_SIDEBAR_TOGGLE_VIRTUAL,	NULL },
   { "sidebar-toggle-visible",	OP_SIDEBAR_TOGGLE_VISIBLE,	NULL },
 #endif
 
+#ifdef USE_NOTMUCH
+  { "change-vfolder",		OP_MAIN_CHANGE_VFOLDER,		"X" },
+  { "vfolder-from-query",	OP_MAIN_VFOLDER_FROM_QUERY,	"\033X" },
+  { "modify-labels",		OP_MAIN_MODIFY_LABELS,		"`" },
+  { "modify-labels-then-hide",	OP_MAIN_MODIFY_LABELS_THEN_HIDE, NULL },
+  { "entire-thread",		OP_MAIN_ENTIRE_THREAD,          "+" },
+#endif
+
   { NULL,		0,				NULL }
 };
 
diff --git a/globals.h b/globals.h
index f04e9c0..07e77ed 100644
--- a/globals.h
+++ b/globals.h
@@ -176,6 +176,10 @@ WHERE const char *ReleaseDate;
 WHERE HASH *Groups;
 WHERE HASH *Labels;
 WHERE HASH *ReverseAlias;
+#ifdef USE_NOTMUCH
+WHERE HASH *TagTransforms;
+WHERE HASH *TagFormats;
+#endif
 
 WHERE LIST *AutoViewList INITVAL(0);
 WHERE LIST *AlternativeOrderList INITVAL(0);
@@ -302,6 +306,17 @@ WHERE char *SmimeGetCertCommand;
 WHERE char *SmimeImportCertCommand;
 WHERE char *SmimeGetCertEmailCommand;
 
+#ifdef USE_NOTMUCH
+WHERE int NotmuchOpenTimeout;
+WHERE char *NotmuchDefaultUri;
+WHERE char *NotmuchExcludeTags;
+WHERE char *NotmuchUnreadTag;
+WHERE char *NotmuchHiddenTags;
+WHERE char *VirtFolderFormat;
+WHERE int NotmuchDBLimit;
+WHERE char *NotmuchQueryType;
+WHERE char *NotmuchRecordTags;
+#endif
 
 
 
diff --git a/hdrline.c b/hdrline.c
index c29107b..ccddd05 100644
--- a/hdrline.c
+++ b/hdrline.c
@@ -36,6 +36,10 @@
 #include <alloca.h>
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 int mutt_is_mail_list (ADDRESS *addr)
 {
   if (!mutt_match_rx_list (addr->mailbox, UnMailLists))
@@ -243,6 +247,7 @@ int mutt_user_is_recipient (HEADER *h)
  * %E = number of messages in current thread
  * %f = entire from line
  * %F = like %n, unless from self
+ * %g = message labels (e.g. notmuch tags)
  * %g = newsgroup name (if compiled with NNTP support)
  * %i = message-id
  * %I = initials of author
@@ -590,6 +595,19 @@ hdr_format_str (char *dest,
         optional = 0;
       break;
 
+#ifdef USE_NOTMUCH
+    case 'g':
+      if (!optional)
+      {
+        colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_TAGS);
+        mutt_format_s (dest+colorlen, destlen-colorlen, prefix, nm_header_get_tags_transformed(hdr));
+        add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
+      }
+      else if (!nm_header_get_tags_transformed(hdr))
+        optional = 0;
+      break;
+#endif
+
     case 'H':
       /* (Hormel) spam score */
       if (optional)
@@ -955,6 +973,48 @@ hdr_format_str (char *dest,
       }
       break;
 
+#ifdef USE_NOTMUCH
+    case 'G':
+    {
+      char *tag_transformed;
+      char format[3];
+      char *tag;
+
+      if (!optional)
+      {
+        format[0] = op;
+        format[1] = *src;
+        format[2] = 0;
+
+        tag = hash_find(TagFormats, format);
+        if (tag != NULL)
+        {
+            tag_transformed = nm_header_get_tag_transformed(tag, hdr);
+
+            colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_TAG);
+            mutt_format_s (dest+colorlen, destlen-colorlen, prefix,
+                           (tag_transformed) ? tag_transformed : "");
+            add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
+        }
+
+        src++;
+      }
+      else
+      {
+        format[0] = op;
+        format[1] = *prefix;
+        format[2] = 0;
+
+        tag = hash_find(TagFormats, format);
+        if (tag != NULL)
+          if (nm_header_get_tag_transformed(tag, hdr) == NULL)
+            optional = 0;
+      }
+
+      break;
+    }
+#endif
+
     default:
       snprintf (dest, destlen, "%%%s%c", prefix, op);
       break;
diff --git a/init.c b/init.c
index 663b914..7b7c4c5 100644
--- a/init.c
+++ b/init.c
@@ -38,7 +38,9 @@
 #include "mutt_ssl.h"
 #endif
 
-
+#if USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
 
 #include "mx.h"
 #include "init.h"
@@ -77,6 +79,12 @@ static void myvar_set (const char* var, const char* val);
 static const char* myvar_get (const char* var);
 static void myvar_del (const char* var);
 
+#if USE_NOTMUCH
+/* List of tags found in last call to mutt_nm_query_complete(). */
+static char **nm_tags;
+#endif
+
+
 static void toggle_quadoption (int opt)
 {
   int n = opt/4;
@@ -2754,6 +2762,182 @@ int mutt_var_value_complete (char *buffer, size_t len, int pos)
   return 0;
 }
 
+#if USE_NOTMUCH
+
+/* Fetch a list of all notmuch tags and insert them into the completion
+ * machinery.
+ */
+static int complete_all_nm_tags (const char *pt)
+{
+  int num;
+  int tag_count_1 = 0;
+  int tag_count_2 = 0;
+
+  Num_matched = 0;
+  strfcpy (User_typed, pt, sizeof (User_typed));
+  memset (Matches, 0, Matches_listsize);
+  memset (Completed, 0, sizeof (Completed));
+
+  nm_longrun_init(Context, FALSE);
+
+  /* Work out how many tags there are. */
+  if (nm_get_all_tags(Context, NULL, &tag_count_1) || tag_count_1 == 0)
+    goto done;
+
+  /* Free the old list, if any. */
+  if (nm_tags != NULL) {
+    int i;
+    for (i = 0; nm_tags[i] != NULL; i++)
+      FREE (&nm_tags[i]);
+    FREE (&nm_tags);
+  }
+  /* Allocate a new list, with sentinel. */
+  nm_tags = safe_malloc((tag_count_1 + 1) * sizeof (char *));
+  nm_tags[tag_count_1] = NULL;
+
+  /* Get all the tags. */
+  if (nm_get_all_tags(Context, nm_tags, &tag_count_2) ||
+      tag_count_1 != tag_count_2) {
+    FREE (&nm_tags);
+    nm_tags = NULL;
+    nm_longrun_done(Context);
+    return -1;
+  }
+
+  /* Put them into the completion machinery. */
+  for (num = 0; num < tag_count_1; num++) {
+    candidate (Completed, User_typed, nm_tags[num], sizeof (Completed));
+  }
+
+  matches_ensure_morespace (Num_matched);
+  Matches[Num_matched++] = User_typed;
+
+done:
+  nm_longrun_done(Context);
+  return 0;
+}
+
+/* Return the last instance of needle in the haystack, or NULL.
+ * Like strstr(), only backwards, and for a limited haystack length.
+ */
+static const char* rstrnstr(const char* haystack,
+                            size_t haystack_length,
+                            const char* needle)
+{
+  int needle_length = strlen(needle);
+  const char* haystack_end = haystack + haystack_length - needle_length;
+  const char* p;
+
+  for (p = haystack_end; p >= haystack; --p)
+  {
+    size_t i;
+    for (i = 0; i < needle_length; ++i) {
+      if (p[i] != needle[i])
+        goto next;
+    }
+    return p;
+
+    next:;
+  }
+  return NULL;
+}
+
+/* Complete the nearest "tag:"-prefixed string previous to pos. */
+int mutt_nm_query_complete (char *buffer, size_t len, int pos, int numtabs)
+{
+  char *pt = buffer;
+  int spaces;
+
+  SKIPWS (buffer);
+  spaces = buffer - pt;
+
+  pt = (char *)rstrnstr((char *)buffer, pos, "tag:");
+  if (pt != NULL) {
+    pt += 4;
+    if (numtabs == 1) {
+      /* First TAB. Collect all the matches */
+      complete_all_nm_tags(pt);
+
+      /* All matches are stored. Longest non-ambiguous string is ""
+       * i.e. don't change 'buffer'. Fake successful return this time.
+       */
+      if (User_typed[0] == 0)
+	return 1;
+    }
+
+    if (Completed[0] == 0 && User_typed[0])
+      return 0;
+
+    /* Num_matched will _always_ be atleast 1 since the initial
+     * user-typed string is always stored */
+    if (numtabs == 1 && Num_matched == 2)
+      snprintf(Completed, sizeof(Completed),"%s", Matches[0]);
+    else if (numtabs > 1 && Num_matched > 2)
+      /* cycle thru all the matches */
+      snprintf(Completed, sizeof(Completed), "%s",
+	       Matches[(numtabs - 2) % Num_matched]);
+
+    /* return the completed query */
+    strncpy (pt, Completed, buffer + len - pt - spaces);
+  }
+  else
+    return 0;
+
+  return 1;
+}
+
+/* Complete the nearest "+" or "-" -prefixed string previous to pos. */
+int mutt_nm_tag_complete (char *buffer, size_t len, int pos, int numtabs)
+{
+  char *pt = buffer;
+  int spaces;
+  const char *first_plus = NULL;
+  const char *first_minus = NULL;
+
+  SKIPWS (buffer);
+  spaces = buffer - pt;
+
+  first_plus = rstrnstr((char *)buffer, pos, "+");
+  first_minus = rstrnstr((char *)buffer, pos, "-");
+  pt = (char *)MAX(first_plus, first_minus);
+
+  if (pt != NULL) {
+    pt++;
+
+    if (numtabs == 1)
+    {
+      /* First TAB. Collect all the matches */
+      complete_all_nm_tags(pt);
+
+      /* All matches are stored. Longest non-ambiguous string is ""
+       * i.e. don't change 'buffer'. Fake successful return this time.
+       */
+      if (User_typed[0] == 0)
+	return 1;
+    }
+
+    if (Completed[0] == 0 && User_typed[0])
+      return 0;
+
+    /* Num_matched will _always_ be atleast 1 since the initial
+     * user-typed string is always stored */
+    if (numtabs == 1 && Num_matched == 2)
+      snprintf(Completed, sizeof(Completed),"%s", Matches[0]);
+    else if (numtabs > 1 && Num_matched > 2)
+      /* cycle thru all the matches */
+      snprintf(Completed, sizeof(Completed), "%s",
+	       Matches[(numtabs - 2) % Num_matched]);
+
+    /* return the completed query */
+    strncpy (pt, Completed, buffer + len - pt - spaces);
+  }
+  else
+    return 0;
+
+  return 1;
+}
+#endif
+
 static int var_to_string (int idx, char* val, size_t len)
 {
   char tmp[LONG_STRING];
@@ -3021,7 +3205,11 @@ void mutt_init (int skip_sys_rc, LIST *commands)
 
   Groups = hash_create (1031, 0);
   ReverseAlias = hash_create (1031, 1);
-  
+#ifdef USE_NOTMUCH
+  TagTransforms = hash_create (64, 1);
+  TagFormats = hash_create (64, 0);
+#endif
+
   mutt_menu_init ();
   mutt_srandom ();
 
@@ -3331,6 +3519,11 @@ void mutt_init (int skip_sys_rc, LIST *commands)
 
   mutt_read_histfile ();
 
+#ifdef USE_NOTMUCH
+  if (option (OPTVIRTSPOOLFILE) && VirtIncoming)
+    mutt_str_replace(&Spoolfile, VirtIncoming->path);
+#endif
+
 #if 0
   set_option (OPTWEED); /* turn weeding on by default */
 #endif
@@ -3378,6 +3571,70 @@ static int parse_group_context (group_context_t **ctx, BUFFER *buf, BUFFER *s, u
   return -1;
 }
 
+#ifdef USE_NOTMUCH
+int parse_tag_transforms (BUFFER *b, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  char *tmp;
+
+  while (MoreArgs (s))
+  {
+    char *tag, *transform;
+
+    mutt_extract_token (b, s, 0);
+    if (b->data && *b->data)
+      tag = safe_strdup (b->data);
+    else
+      continue;
+
+    mutt_extract_token (b, s, 0);
+    transform = safe_strdup (b->data);
+
+    /* avoid duplicates */
+    tmp = hash_find(TagTransforms, tag);
+    if (tmp) {
+      dprint(3,(debugfile,"tag transform '%s' already registered as '%s'\n", tag, tmp));
+      FREE(&tag);
+      FREE(&transform);
+      continue;
+    }
+
+    hash_insert(TagTransforms, tag, transform, 0);
+  }
+  return 0;
+}
+
+int parse_tag_formats (BUFFER *b, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  char *tmp;
+
+  while (MoreArgs (s))
+  {
+    char *tag, *format;
+
+    mutt_extract_token (b, s, 0);
+    if (b->data && *b->data)
+      tag = safe_strdup (b->data);
+    else
+      continue;
+
+    mutt_extract_token (b, s, 0);
+    format = safe_strdup (b->data);
+
+    /* avoid duplicates */
+    tmp = hash_find(TagFormats, format);
+    if (tmp) {
+      dprint(3,(debugfile,"tag format '%s' already registered as '%s'\n", format, tmp));
+      FREE(&tag);
+      FREE(&format);
+      continue;
+    }
+
+    hash_insert(TagFormats, format, tag, 0);
+  }
+  return 0;
+}
+#endif
+
 static void myvar_set (const char* var, const char* val)
 {
   myvar_t** cur;
diff --git a/init.h b/init.h
index 86a4cae..93a1fac 100644
--- a/init.h
+++ b/init.h
@@ -1370,6 +1370,7 @@ struct option_t MuttVars[] = {
   ** .dt %E .dd number of messages in current thread
   ** .dt %f .dd sender (address + real name), either From: or Return-Path:
   ** .dt %F .dd author name, or recipient name if the message is from you
+  ** .dt %g .dd message labels (e.g. notmuch tags)
   ** .dt %g .dd newsgroup name (if compiled with NNTP support)
   ** .dt %H .dd spam attribute(s) of this message
   ** .dt %i .dd message-id of the current message
@@ -1891,6 +1892,60 @@ struct option_t MuttVars[] = {
   ** etc.).
   */
 #endif
+#ifdef USE_NOTMUCH
+  { "nm_open_timeout", DT_NUM, R_NONE, UL &NotmuchOpenTimeout, 5 },
+  /*
+   ** .pp
+   ** This variable specifies the timeout for database open in seconds.
+   */
+
+  { "nm_default_uri", DT_STR, R_NONE, UL &NotmuchDefaultUri, 0 },
+  /*
+   ** .pp
+   ** This variable specifies the default Notmuch database in format
+   ** notmuch://<absolute path>.
+   */
+
+  { "nm_hidden_tags", DT_STR, R_NONE, UL &NotmuchHiddenTags, UL "unread,draft,flagged,passed,replied,attachment,signed,encrypted" },
+  /*
+   ** .pp
+   ** This variable specifies private notmuch tags which should not be printed
+   ** on screen.
+   */
+  { "nm_exclude_tags", DT_STR,  R_NONE, UL &NotmuchExcludeTags, 0 },
+  /*
+   ** .pp
+   ** The messages tagged with these tags are excluded and not loaded
+   ** from notmuch DB to mutt unless specified explicitly.
+   */
+  { "nm_unread_tag", DT_STR, R_NONE, UL &NotmuchUnreadTag, UL "unread" },
+  /*
+   ** .pp
+   ** This variable specifies notmuch tag which is used for unread messages. The
+   ** variable is used to count unread messages in DB only. All other mutt commands
+   ** use standard (e.g. maildir) flags.
+   */
+  { "nm_db_limit", DT_NUM, R_NONE, UL &NotmuchDBLimit, 0 },
+  /*
+   ** .pp
+   ** This variable specifies the default limit used in notmuch queries.
+   */
+  { "nm_query_type", DT_STR, R_NONE, UL &NotmuchQueryType, UL "messages" },
+  /*
+   ** .pp
+   ** This variable specifies the default query type (threads or messages) used in notmuch queries.
+   */
+  { "nm_record", DT_BOOL, R_NONE, OPTNOTMUCHRECORD, 0 },
+  /*
+   ** .pp
+   ** This variable specifies if the mutt record should indexed by notmuch.
+   */
+  { "nm_record_tags", DT_STR, R_NONE, UL &NotmuchRecordTags, 0 },
+  /*
+   ** .pp
+   ** This variable specifies the default tags applied to messages stored to the mutt record.
+   */
+#endif
   { "pager",		DT_PATH, R_NONE, UL &Pager, UL "builtin" },
   /*
   ** .pp
@@ -3459,14 +3514,15 @@ struct option_t MuttVars[] = {
   { "sort_re",		DT_BOOL, R_INDEX|R_RESORT|R_RESORT_INIT, OPTSORTRE, 1 },
   /*
   ** .pp
-  ** This variable is only useful when sorting by threads with
-  ** $$strict_threads \fIunset\fP.  In that case, it changes the heuristic
-  ** mutt uses to thread messages by subject.  With $$sort_re \fIset\fP, mutt will
-  ** only attach a message as the child of another message by subject if
-  ** the subject of the child message starts with a substring matching the
-  ** setting of $$reply_regexp.  With $$sort_re \fIunset\fP, mutt will attach
-  ** the message whether or not this is the case, as long as the
-  ** non-$$reply_regexp parts of both messages are identical.
+  ** This variable is only useful when sorting by mailboxes in sidebar. By default,
+  ** entries are unsorted.  Valid values:
+  ** .il
+  ** .dd count (all message count)
+  ** .dd desc  (virtual mailbox description)
+  ** .dd new (new message count)
+  ** .dd path
+  ** .dd unsorted
+  ** .ie
   */
   { "spam_separator",   DT_STR, R_NONE, UL &SpamSep, UL "," },
   /*
@@ -3919,6 +3975,31 @@ struct option_t MuttVars[] = {
   ** Specifies the visual editor to invoke when the ``\fC~v\fP'' command is
   ** given in the built-in editor.
   */
+#ifdef USE_NOTMUCH
+  { "vfolder_format",	DT_STR,	 R_INDEX, UL &VirtFolderFormat, UL " %6n(%6N) %f " },
+  /*
+  ** .pp
+  ** This variable allows you to customize the file browser display for virtual
+  ** folders to your ** personal taste.  This string is similar to $$index_format,
+  ** but has its own set of \fCprintf(3)\fP-like sequences:
+  ** .dl
+  ** .dt %f  .dd folder name (description)
+  ** .dt %n  .dd number of all messages
+  ** .dt %N  .dd number of new messages
+  ** .dt %>X .dd right justify the rest of the string and pad with character ``X''
+  ** .dt %|X .dd pad to the end of the line with character ``X''
+  ** .dt %*X .dd soft-fill with character ``X'' as pad
+  ** .de
+  ** .pp
+  ** For an explanation of ``soft-fill'', see the $$index_format documentation.
+  */
+  { "virtual_spoolfile", DT_BOOL, R_NONE, OPTVIRTSPOOLFILE, 0 },
+  /*
+  ** .pp
+  ** When \fset\fP, mutt will use the first defined virtual mailbox (see
+  ** virtual-mailboxes) as a spool file.
+  */
+#endif
   { "wait_key",		DT_BOOL, R_NONE, OPTWAITKEY, 1 },
   /*
   ** .pp
@@ -4091,6 +4172,7 @@ const struct mapping_t SortKeyMethods[] = {
 const struct mapping_t SortSidebarMethods[] = {
   { "alpha",		SORT_PATH },
   { "count",		SORT_COUNT },
+  { "desc",		SORT_DESC },
   { "flagged",		SORT_FLAGGED },
   { "mailbox-order",	SORT_ORDER },
   { "name",		SORT_PATH },
@@ -4126,13 +4208,16 @@ static int parse_unsubscribe (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_attachments (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unattachments (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 
-
 static int parse_alternates (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 static int parse_unalternates (BUFFER *, BUFFER *, unsigned long, BUFFER *);
 
 /* Parse -group arguments */
 static int parse_group_context (group_context_t **ctx, BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err);
 
+#ifdef USE_NOTMUCH
+static int parse_tag_transforms (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_tag_formats (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+#endif
 
 struct command_t
 {
@@ -4181,6 +4266,11 @@ const struct command_t Commands[] = {
   { "macro",		mutt_parse_macro,	0 },
   { "mailboxes",	mutt_parse_mailboxes,	M_MAILBOXES },
   { "unmailboxes",	mutt_parse_mailboxes,	M_UNMAILBOXES },
+#ifdef USE_NOTMUCH
+  { "virtual-mailboxes",mutt_parse_virtual_mailboxes, 0 },
+  { "tag-transforms",	parse_tag_transforms,	0 },
+  { "tag-formats",	parse_tag_formats,	0 },
+#endif
   { "mailto_allow",	parse_list,		UL &MailtoAllow },
   { "unmailto_allow",	parse_unlist,		UL &MailtoAllow },
   { "message-hook",	mutt_parse_hook,	M_MESSAGEHOOK },
diff --git a/mailbox.h b/mailbox.h
index 99ea706..1b1cad1 100644
--- a/mailbox.h
+++ b/mailbox.h
@@ -45,6 +45,7 @@ typedef struct
 {
   FILE *fp;	/* pointer to the message data */
   char *path;	/* path to temp file */
+  char *commited_path; /* the final path generated by mx_commit_message() */
   short magic;	/* type of mailbox this message belongs to */
   short write;	/* nonzero if message is open for writing */
   struct {
diff --git a/menu.c b/menu.c
index 9fd25fa..567b962 100644
--- a/menu.c
+++ b/menu.c
@@ -50,6 +50,17 @@ get_color (int index, unsigned char *s)
 		case MT_COLOR_INDEX_SUBJECT:
 			color = ColorIndexSubjectList;
 			break;
+#ifdef USE_NOTMUCH
+                case MT_COLOR_INDEX_TAG:
+                        for (color = ColorIndexTagList; color; color = color->next)
+                        {
+				const char * transform = hash_find(TagTransforms, color->pattern);
+				if (transform && (strncmp((const char *)(s+1),
+				    transform, strlen(transform)) == 0))
+					return color->pair;
+                        }
+                        return 0;
+#endif
 		default:
 			return ColorDefs[type];
 	}
diff --git a/mh.c b/mh.c
index b75de6d..cb6967e 100644
--- a/mh.c
+++ b/mh.c
@@ -56,6 +56,10 @@
 #include <sys/time.h>
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #define		INS_SORT_THRESHOLD		6
 
 struct maildir
@@ -658,7 +662,7 @@ static void maildir_free_maildir (struct maildir **md)
   }
 }
 
-static void maildir_parse_flags (HEADER * h, const char *path)
+void maildir_parse_flags (HEADER * h, const char *path)
 {
   char *p, *q = NULL;
 
@@ -741,40 +745,51 @@ static void maildir_update_mtime (CONTEXT * ctx)
  * Actually parse a maildir message.  This may also be used to fill
  * out a fake header structure generated by lazy maildir parsing.
  */
-static HEADER *maildir_parse_message (int magic, const char *fname,
+HEADER *maildir_parse_stream (int magic, FILE *f, const char *fname,
 				      int is_old, HEADER * _h)
 {
-  FILE *f;
   HEADER *h = _h;
   struct stat st;
 
-  if ((f = fopen (fname, "r")) != NULL)
-  {
-    if (!h)
-      h = mutt_new_header ();
-    h->env = mutt_read_rfc822_header (f, h, 0, 0);
+  if (!h)
+    h = mutt_new_header ();
+  h->env = mutt_read_rfc822_header (f, h, 0, 0);
 
-    fstat (fileno (f), &st);
-    safe_fclose (&f);
+  fstat (fileno (f), &st);
 
-    if (!h->received)
-      h->received = h->date_sent;
+  if (!h->received)
+    h->received = h->date_sent;
 
-    /* always update the length since we have fresh information available. */
-    h->content->length = st.st_size - h->content->offset;
+  /* always update the length since we have fresh information available. */
+  h->content->length = st.st_size - h->content->offset;
 
-    h->index = -1;
+  h->index = -1;
 
-    if (magic == M_MAILDIR)
-    {
-      /* 
-       * maildir stores its flags in the filename, so ignore the
-       * flags in the header of the message 
-       */
+  if (magic == M_MAILDIR)
+  {
+    /*
+     * maildir stores its flags in the filename, so ignore the
+     * flags in the header of the message
+     */
 
-      h->old = is_old;
-      maildir_parse_flags (h, fname);
-    }
+    h->old = is_old;
+    maildir_parse_flags (h, fname);
+  }
+  return h;
+}
+
+/*
+ * Actually parse a maildir message.  This may also be used to fill
+ * out a fake header structure generated by lazy maildir parsing.
+ */
+HEADER *maildir_parse_message (int magic, const char *fname,
+				      int is_old, HEADER * h)
+{
+  FILE *f;
+
+  if ((f = fopen (fname, "r")) != NULL) {
+    h = maildir_parse_stream (magic, f, fname, is_old, h);
+    safe_fclose (&f);
     return h;
   }
   return NULL;
@@ -1297,7 +1312,7 @@ static int ch_compar (const void *a, const void *b)
   return (int)( *((const char *) a) - *((const char *) b));
 }
 
-static void maildir_flags (char *dest, size_t destlen, HEADER * hdr)
+void maildir_flags (char *dest, size_t destlen, HEADER * hdr)
 {
   *dest = '\0';
 
@@ -1457,10 +1472,6 @@ int maildir_commit_message (CONTEXT * ctx, MESSAGE * msg, HEADER * hdr)
 
     if (safe_rename (msg->path, full) == 0)
     {
-      if (hdr)
-	mutt_str_replace (&hdr->path, path);
-      FREE (&msg->path);
-
       /*
        * Adjust the mtime on the file to match the time at which this
        * message was received.  Currently this is only set when copying
@@ -1476,11 +1487,23 @@ int maildir_commit_message (CONTEXT * ctx, MESSAGE * msg, HEADER * hdr)
 	if (utime (full, &ut))
 	{
 	  mutt_perror (_("maildir_commit_message(): unable to set time on file"));
-	  return -1;
+	  goto post_rename_err;
 	}
       }
 
+#ifdef USE_NOTMUCH
+      if (ctx->magic == M_NOTMUCH)
+	nm_update_filename(ctx, hdr->path, full, hdr);
+#endif
+      if (hdr)
+	mutt_str_replace (&hdr->path, path);
+      mutt_str_replace (&msg->commited_path, full);
+      FREE (&msg->path);
+
       return 0;
+
+post_rename_err:
+      return -1;
     }
     else if (errno != EEXIST)
     {
@@ -1556,6 +1579,7 @@ static int _mh_commit_message (CONTEXT * ctx, MESSAGE * msg, HEADER * hdr,
     {
       if (hdr)
 	mutt_str_replace (&hdr->path, tmp);
+      mutt_str_replace (&msg->commited_path, path);
       FREE (&msg->path);
       break;
     }
@@ -1731,97 +1755,114 @@ static int maildir_sync_message (CONTEXT * ctx, int msgno)
   return (0);
 }
 
-int mh_sync_mailbox (CONTEXT * ctx, int *index_hint)
-{
-  char path[_POSIX_PATH_MAX], tmp[_POSIX_PATH_MAX];
-  int i, j;
-#if USE_HCACHE
-  header_cache_t *hc = NULL;
-#endif /* USE_HCACHE */
-  char msgbuf[STRING];
-  progress_t progress;
-
-  if (ctx->magic == M_MH)
-    i = mh_check_mailbox (ctx, index_hint);
-  else 
-    i = maildir_check_mailbox (ctx, index_hint);
-      
-  if (i != 0)
-    return i;
-
 #if USE_HCACHE
-  if (ctx->magic == M_MAILDIR || ctx->magic == M_MH)
-    hc = mutt_hcache_open(HeaderCache, ctx->path, NULL);
-#endif /* USE_HCACHE */
-
-  if (!ctx->quiet)
-  {
-    snprintf (msgbuf, sizeof (msgbuf), _("Writing %s..."), ctx->path);
-    mutt_progress_init (&progress, msgbuf, M_PROGRESS_MSG, WriteInc, ctx->msgcount);
-  }
-
-  for (i = 0; i < ctx->msgcount; i++)
-  {
-    if (!ctx->quiet)
-      mutt_progress_update (&progress, i, -1);
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno, header_cache_t *hc)
+#else
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno)
+#endif
+{
+    char path[_POSIX_PATH_MAX], tmp[_POSIX_PATH_MAX];
+    HEADER *h = ctx->hdrs[msgno];
 
-    if (ctx->hdrs[i]->deleted
-	&& (ctx->magic != M_MAILDIR || !option (OPTMAILDIRTRASH)))
+    if (h->deleted && (ctx->magic != M_MAILDIR || !option (OPTMAILDIRTRASH)))
     {
-      snprintf (path, sizeof (path), "%s/%s", ctx->path, ctx->hdrs[i]->path);
+      snprintf (path, sizeof (path), "%s/%s", ctx->path, h->path);
       if (ctx->magic == M_MAILDIR
 	  || (option (OPTMHPURGE) && ctx->magic == M_MH))
       {
 #if USE_HCACHE
-        if (ctx->magic == M_MAILDIR)
-          mutt_hcache_delete (hc, ctx->hdrs[i]->path + 3, &maildir_hcache_keylen);
-	else if (ctx->magic == M_MH)
-	  mutt_hcache_delete (hc, ctx->hdrs[i]->path, strlen);
+	if (hc) {
+           if (ctx->magic == M_MAILDIR)
+              mutt_hcache_delete (hc, h->path + 3, &maildir_hcache_keylen);
+	   else if (ctx->magic == M_MH)
+	      mutt_hcache_delete (hc, h->path, strlen);
+	}
 #endif /* USE_HCACHE */
 	unlink (path);
       }
       else if (ctx->magic == M_MH)
       {
 	/* MH just moves files out of the way when you delete them */
-	if (*ctx->hdrs[i]->path != ',')
+	if (*h->path != ',')
 	{
-	  snprintf (tmp, sizeof (tmp), "%s/,%s", ctx->path,
-		    ctx->hdrs[i]->path);
+	  snprintf (tmp, sizeof (tmp), "%s/,%s", ctx->path, h->path);
 	  unlink (tmp);
 	  rename (path, tmp);
 	}
 
       }
     }
-    else if (ctx->hdrs[i]->changed || ctx->hdrs[i]->attach_del ||
-	     ctx->hdrs[i]->label_changed ||
+    else if (h->changed || h->attach_del ||
+	     h->label_changed ||
 	     (ctx->magic == M_MAILDIR
-	      && (option (OPTMAILDIRTRASH) || ctx->hdrs[i]->trash)
-	      && (ctx->hdrs[i]->deleted != ctx->hdrs[i]->trash)))
+	      && (option (OPTMAILDIRTRASH) || h->trash)
+	      && (h->deleted != h->trash)))
     {
       if (ctx->magic == M_MAILDIR)
       {
-	if (maildir_sync_message (ctx, i) == -1)
-	  goto err;
+	if (maildir_sync_message (ctx, msgno) == -1)
+	  return -1;
       }
       else
       {
-	if (mh_sync_message (ctx, i) == -1)
-	  goto err;
+	if (mh_sync_message (ctx, msgno) == -1)
+	  return -1;
       }
     }
 
 #if USE_HCACHE
-    if (ctx->hdrs[i]->changed)
+    if (hc && h->changed)
     {
       if (ctx->magic == M_MAILDIR)
-	mutt_hcache_store (hc, ctx->hdrs[i]->path + 3, ctx->hdrs[i],
-			   0, &maildir_hcache_keylen, M_GENERATE_UIDVALIDITY);
+	mutt_hcache_store (hc, h->path + 3, h, 0, &maildir_hcache_keylen, M_GENERATE_UIDVALIDITY);
       else if (ctx->magic == M_MH)
-	mutt_hcache_store (hc, ctx->hdrs[i]->path, ctx->hdrs[i], 0, strlen, M_GENERATE_UIDVALIDITY);
+	mutt_hcache_store (hc, h->path, h, 0, strlen, M_GENERATE_UIDVALIDITY);
     }
 #endif
 
+    return 0;
+}
+
+int mh_sync_mailbox (CONTEXT * ctx, int *index_hint)
+{
+  int i, j;
+#if USE_HCACHE
+  header_cache_t *hc = NULL;
+#endif /* USE_HCACHE */
+  char msgbuf[STRING];
+  progress_t progress;
+
+  if (ctx->magic == M_MH)
+    i = mh_check_mailbox (ctx, index_hint);
+  else
+    i = maildir_check_mailbox (ctx, index_hint);
+
+  if (i != 0)
+    return i;
+
+#if USE_HCACHE
+  if (ctx->magic == M_MAILDIR || ctx->magic == M_MH)
+    hc = mutt_hcache_open(HeaderCache, ctx->path, NULL);
+#endif /* USE_HCACHE */
+
+  if (!ctx->quiet)
+  {
+    snprintf (msgbuf, sizeof (msgbuf), _("Writing %s..."), ctx->path);
+    mutt_progress_init (&progress, msgbuf, M_PROGRESS_MSG, WriteInc, ctx->msgcount);
+  }
+
+  for (i = 0; i < ctx->msgcount; i++)
+  {
+    if (!ctx->quiet)
+      mutt_progress_update (&progress, i, -1);
+
+#if USE_HCACHE
+    if (mh_sync_mailbox_message (ctx, i, hc) == -1)
+      goto err;
+#else
+    if (mh_sync_mailbox_message (ctx, i) == -1)
+      goto err;
+#endif
   }
 
 #if USE_HCACHE
@@ -1900,7 +1941,7 @@ static void maildir_update_tables (CONTEXT *ctx, int *index_hint)
   mutt_clear_threads (ctx);
 }
 
-static void maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n)
+void maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n)
 {
   /* save the global state here so we can reset it at the
    * end of list block if required.
@@ -2203,7 +2244,7 @@ int mh_check_mailbox (CONTEXT * ctx, int *index_hint)
  */
 
 static FILE *_maildir_open_find_message (const char *folder, const char *unique,
-				  const char *subfolder)
+				  const char *subfolder, char **newname)
 {
   char dir[_POSIX_PATH_MAX];
   char tunique[_POSIX_PATH_MAX];
@@ -2239,11 +2280,15 @@ static FILE *_maildir_open_find_message (const char *folder, const char *unique,
 
   closedir (dp);
 
+  if (newname && fp)
+    *newname = safe_strdup(fname);
+
   errno = oe;
   return fp;
 }
 
-FILE *maildir_open_find_message (const char *folder, const char *msg)
+FILE *maildir_open_find_message (const char *folder, const char *msg,
+                                  char **newname)
 {
   char unique[_POSIX_PATH_MAX];
   FILE *fp;
@@ -2255,7 +2300,8 @@ FILE *maildir_open_find_message (const char *folder, const char *msg)
   if (
       (fp =
        _maildir_open_find_message (folder, unique,
-				   new_hits > cur_hits ? "new" : "cur"))
+				   new_hits > cur_hits ? "new" : "cur",
+				   newname))
       || errno != ENOENT)
   {
     if (new_hits < UINT_MAX && cur_hits < UINT_MAX)
@@ -2269,7 +2315,8 @@ FILE *maildir_open_find_message (const char *folder, const char *msg)
   if (
       (fp =
        _maildir_open_find_message (folder, unique,
-				   new_hits > cur_hits ? "cur" : "new"))
+				   new_hits > cur_hits ? "cur" : "new",
+				   newname))
       || errno != ENOENT)
   {
     if (new_hits < UINT_MAX && cur_hits < UINT_MAX)
diff --git a/mutt.h b/mutt.h
index 825cc41..754705e 100644
--- a/mutt.h
+++ b/mutt.h
@@ -89,6 +89,10 @@
 #define  M_COMMAND (1<<6) /* do command completion */
 #define  M_PATTERN (1<<7) /* pattern mode - only used for history classes */
 #define  M_LABEL   (1<<8) /* do label completion */
+#if USE_NOTMUCH
+#define  M_NM_QUERY (1<<9) /* Notmuch query mode. */
+#define  M_NM_TAG   (1<<10) /* Notmuch tag +/- mode. */
+#endif
 
 /* flags for mutt_get_token() */
 #define M_TOKEN_EQUAL		1	/* treat '=' as a special */
@@ -233,6 +237,9 @@ enum
   M_CRYPT_ENCRYPT,
   M_PGP_KEY,
   M_XLABEL,
+#ifdef USE_NOTMUCH
+  M_NOTMUCH_LABEL,
+#endif
   M_MIMEATTACH,
 #ifdef USE_NNTP
   M_NEWSGROUPS,
@@ -325,6 +332,7 @@ enum
 #define M_SEL_BUFFY	(1<<0)
 #define M_SEL_MULTI	(1<<1)
 #define M_SEL_FOLDER	(1<<2)
+#define M_SEL_VFOLDER	(1<<3)
 
 /* flags for parse_spam_list */
 #define M_SPAM          1
@@ -573,6 +581,10 @@ enum
   OPTDONTHANDLEPGPKEYS,	/* (pseudo) used to extract PGP keys */
   OPTIGNOREMACROEVENTS, /* (pseudo) don't process macro/push/exec events while set */
 
+#ifdef USE_NOTMUCH
+  OPTVIRTSPOOLFILE,
+  OPTNOTMUCHRECORD,
+#endif
 #ifdef USE_NNTP
   OPTNEWS,		/* (pseudo) used to change reader mode */
   OPTNEWSSEND,		/* (pseudo) used to change behavior when posting */
@@ -853,8 +865,9 @@ typedef struct header
   int refno;			/* message number on server */
 #endif
 
-#if defined USE_POP || defined USE_IMAP || defined USE_NNTP
+#if defined USE_POP || defined USE_IMAP || defined USE_NOTMUCH || defined USE_NNTP
   void *data;            	/* driver-specific data */
+  void (*free_cb)(struct header *); /* driver-specific data free function */
 #endif
   
   char *maildir_flags;		/* unknown maildir flags */
diff --git a/mutt_curses.h b/mutt_curses.h
index 8d3530b..bdeb6a6 100644
--- a/mutt_curses.h
+++ b/mutt_curses.h
@@ -136,6 +136,9 @@ enum
   MT_COLOR_SB_SPOOLFILE,
 #endif
   /* please no non-MT_COLOR_INDEX objects after this point */
+#ifdef USE_NOTMUCH
+  MT_COLOR_INDEX_TAG,
+#endif
   MT_COLOR_INDEX,
   MT_COLOR_INDEX_AUTHOR,
   MT_COLOR_INDEX_FLAGS,
@@ -146,6 +149,9 @@ enum
   MT_COLOR_INDEX_LABEL,
   MT_COLOR_INDEX_NUMBER,
   MT_COLOR_INDEX_SIZE,
+#ifdef USE_NOTMUCH
+  MT_COLOR_INDEX_TAGS,
+#endif
   MT_COLOR_MAX
 };
 
@@ -208,6 +214,9 @@ extern COLOR_LINE *ColorIndexList;
 extern COLOR_LINE *ColorIndexAuthorList;
 extern COLOR_LINE *ColorIndexFlagsList;
 extern COLOR_LINE *ColorIndexSubjectList;
+#ifdef USE_NOTMUCH
+extern COLOR_LINE *ColorIndexTagList;
+#endif
 
 void ci_init_color (void);
 void ci_start_color (void);
diff --git a/mutt_notmuch.c b/mutt_notmuch.c
new file mode 100644
index 0000000..e17d3df
--- /dev/null
+++ b/mutt_notmuch.c
@@ -0,0 +1,1984 @@
+/*
+ * Notmuch support for mutt
+ *
+ * Copyright (C) 2011, 2012 Karel Zak <kzak@redhat.com>
+ *
+ * Notes:
+ *
+ * - notmuch uses private CONTEXT->data and private HEADER->data
+ *
+ * - all exported functions are usable within notmuch context only
+ *
+ * - all functions have to be covered by "ctx->magic == M_NOTMUCH" check
+ *   (it's implemented in get_ctxdata() and init_context() functions).
+ *
+ * - exception are nm_nonctx_* functions -- these functions use nm_default_uri
+ *   (or parse URI from another resource)
+ */
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mx.h"
+#include "rfc2047.h"
+#include "sort.h"
+#include "mailbox.h"
+#include "copy.h"
+#include "keymap.h"
+#include "url.h"
+#include "buffy.h"
+
+#include <dirent.h>
+#include <fcntl.h>
+#include <sys/file.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <utime.h>
+
+#include <notmuch.h>
+
+#include "mutt_notmuch.h"
+#include "mutt_curses.h"
+
+#ifdef LIBNOTMUCH_CHECK_VERSION
+#undef LIBNOTMUCH_CHECK_VERSION
+#endif
+
+/* The definition in <notmuch.h> is broken */
+#define LIBNOTMUCH_CHECK_VERSION(major, minor, micro)                               \
+    (LIBNOTMUCH_MAJOR_VERSION > (major) ||                                          \
+     (LIBNOTMUCH_MAJOR_VERSION == (major) && LIBNOTMUCH_MINOR_VERSION > (minor)) || \
+     (LIBNOTMUCH_MAJOR_VERSION == (major) && LIBNOTMUCH_MINOR_VERSION == (minor) && \
+      LIBNOTMUCH_MICRO_VERSION >= (micro)))
+
+
+/* read whole-thread or matching messages only? */
+enum {
+	NM_QUERY_TYPE_MESGS = 1,	/* default */
+	NM_QUERY_TYPE_THREADS
+};
+
+/*
+ * Parsed URI arguments
+ */
+struct uri_tag {
+	char *name;
+	char *value;
+	struct uri_tag *next;
+};
+
+/*
+ * HEADER->(nm_hdrdata *)data->tag_list node
+ */
+struct nm_hdrtag
+{
+  char *tag;
+  char *transformed;
+  struct nm_hdrtag *next;
+};
+
+/*
+ * HEADER->data
+ */
+struct nm_hdrdata {
+	char *folder;
+	char *tags;
+	char *tags_transformed;
+	struct nm_hdrtag *tag_list;
+	char *oldpath;
+	char *virtual_id;
+	int magic;
+};
+
+/*
+ * CONTEXT->data
+ */
+struct nm_ctxdata {
+	notmuch_database_t *db;
+
+	char *db_filename;
+	char *db_query;
+	int db_limit;
+	int query_type;
+
+	struct uri_tag *query_items;
+
+	progress_t progress;
+	int oldmsgcount;
+	int ignmsgcount;	/* ingored messages */
+
+	unsigned int noprogress : 1,
+		     longrun : 1,
+		     trans : 1,
+		     progress_ready : 1;
+
+};
+
+static HEADER *get_mutt_header(CONTEXT *ctx, notmuch_message_t *msg);
+static notmuch_message_t *get_nm_message(notmuch_database_t *db, HEADER *hdr);
+
+static void url_free_tags(struct uri_tag *tags)
+{
+	while (tags) {
+		struct uri_tag *next = tags->next;
+		FREE(&tags->name);
+		FREE(&tags->value);
+		FREE(&tags);
+		tags = next;
+	}
+}
+
+static int url_parse_query(char *url, char **filename, struct uri_tag **tags)
+{
+	char *p = strstr(url, "://");	/* remote unsupported */
+	char *e;
+	struct uri_tag *tag, *last = NULL;
+
+	*filename = NULL;
+	*tags = NULL;
+
+	if (!p || !*(p + 3))
+		return -1;
+
+	p += 3;
+	*filename = p;
+
+	e = strchr(p, '?');
+
+	*filename = e ? e == p ? NULL : strndup(p, e - p) : safe_strdup(p);
+	if (!e)
+		return 0;
+
+	if (*filename && url_pct_decode(*filename) < 0)
+		goto err;
+	if (!e)
+		return 0;	/* only filename */
+
+	++e;	/* skip '?' */
+	p = e;
+
+	while (p && *p) {
+		tag = safe_calloc(1, sizeof(struct uri_tag));
+		if (!tag)
+			goto err;
+
+		if (!*tags)
+			last = *tags = tag;
+		else {
+			last->next = tag;
+			last = tag;
+		}
+
+		e = strchr(p, '=');
+		if (!e)
+			e = strchr(p, '&');
+		tag->name = e ? strndup(p, e - p) : safe_strdup(p);
+		if (!tag->name || url_pct_decode(tag->name) < 0)
+			goto err;
+		if (!e)
+			break;
+
+		p = e + 1;
+
+		if (*e == '&')
+			continue;
+
+		e = strchr(p, '&');
+		tag->value = e ? strndup(p, e - p) : safe_strdup(p);
+		if (!tag->value || url_pct_decode(tag->value) < 0)
+			goto err;
+		if (!e)
+			break;
+		p = e + 1;
+	}
+
+	return 0;
+err:
+	FREE(&(*filename));
+	url_free_tags(*tags);
+	return -1;
+}
+
+static void free_tag_list(struct nm_hdrtag **tag_list)
+{
+	struct nm_hdrtag *tmp;
+
+	while ((tmp = *tag_list) != NULL)
+	{
+		*tag_list = tmp->next;
+		FREE(&tmp->tag);
+		FREE(&tmp->transformed);
+		FREE(&tmp);
+	}
+
+	*tag_list = 0;
+}
+
+static void free_hdrdata(struct nm_hdrdata *data)
+{
+	if (!data)
+		return;
+
+	dprint(2, (debugfile, "nm: freeing header %p\n", data));
+	FREE(&data->folder);
+	FREE(&data->tags);
+	FREE(&data->tags_transformed);
+	free_tag_list(&data->tag_list);
+	FREE(&data->oldpath);
+	FREE(&data->virtual_id);
+	FREE(&data);
+}
+
+static void free_ctxdata(struct nm_ctxdata *data)
+{
+	if (!data)
+		return;
+
+	dprint(1, (debugfile, "nm: freeing context data %p\n", data));
+
+	if (data->db)
+#ifdef NOTMUCH_API_3
+	        notmuch_database_destroy(data->db);
+#else
+		notmuch_database_close(data->db);
+#endif
+	data->db = NULL;
+
+	FREE(&data->db_filename);
+	FREE(&data->db_query);
+	url_free_tags(data->query_items);
+	FREE(&data);
+}
+
+static struct nm_ctxdata *new_ctxdata(char *uri)
+{
+	struct nm_ctxdata *data;
+
+	if (!uri)
+		return NULL;
+
+	data = safe_calloc(1, sizeof(struct nm_ctxdata));
+	dprint(1, (debugfile, "nm: initialize context data %p\n", data));
+
+	data->db_limit = NotmuchDBLimit;
+
+	if (url_parse_query(uri, &data->db_filename, &data->query_items)) {
+		mutt_error(_("failed to parse notmuch uri: %s"), uri);
+		data->db_filename = NULL;
+		data->query_items = NULL;
+		data->query_type = 0;
+		return NULL;
+	}
+
+	return data;
+}
+
+static int deinit_context(CONTEXT *ctx)
+{
+	int i;
+
+	if (!ctx || ctx->magic != M_NOTMUCH)
+		return -1;
+
+	for (i = 0; i < ctx->msgcount; i++) {
+		HEADER *h = ctx->hdrs[i];
+
+		if (h) {
+			free_hdrdata(h->data);
+			h->data = NULL;
+		}
+	}
+
+	free_ctxdata(ctx->data);
+	ctx->data = NULL;
+	return 0;
+}
+
+static int init_context(CONTEXT *ctx)
+{
+	if (!ctx || ctx->magic != M_NOTMUCH)
+		return -1;
+
+	if (ctx->data)
+		return 0;
+
+	ctx->data = new_ctxdata(ctx->path);
+	if (!ctx->data)
+		return -1;
+
+	ctx->mx_close = deinit_context;
+	return 0;
+}
+
+char *nm_header_get_folder(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->folder : NULL;
+}
+
+/* returns all unhidden tags */
+char *nm_header_get_tags(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->tags : NULL;
+}
+
+char *nm_header_get_tags_transformed(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->tags_transformed : NULL;
+}
+
+char *nm_header_get_tag_transformed(char *tag, HEADER *h)
+{
+	struct nm_hdrtag *tmp;
+
+	if (!h || !h->data)
+		return NULL;
+
+	for (tmp = ((struct nm_hdrdata *) h->data)->tag_list;
+	     tmp != NULL;
+	     tmp = tmp->next)
+	{
+		if (strcmp(tag, tmp->tag) == 0)
+			return tmp->transformed;
+	}
+
+	return NULL;
+}
+
+int nm_header_get_magic(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->magic : 0;
+}
+
+/*
+ * Returns notmuch message Id.
+ */
+static char *nm_header_get_id(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->virtual_id : NULL;
+}
+
+
+char *nm_header_get_fullpath(HEADER *h, char *buf, size_t bufsz)
+{
+	snprintf(buf, bufsz, "%s/%s", nm_header_get_folder(h), h->path);
+	/*dprint(2, (debugfile, "nm: returns fullpath '%s'\n", buf));*/
+	return buf;
+}
+
+
+static struct nm_ctxdata *get_ctxdata(CONTEXT *ctx)
+{
+	if (ctx && ctx->magic == M_NOTMUCH)
+		return ctx->data;
+
+	return NULL;
+}
+
+static int string_to_guery_type(const char *str)
+{
+	if (!str)
+		str = NotmuchQueryType;		/* user's default */
+	if (!str)
+		return NM_QUERY_TYPE_MESGS;	/* hardcoded default */
+
+	if (strcmp(str, "threads") == 0)
+		return NM_QUERY_TYPE_THREADS;
+	else if (strcmp(str, "messages") == 0)
+		return NM_QUERY_TYPE_MESGS;
+
+	mutt_error (_("failed to parse notmuch query type: %s"), str);
+	return NM_QUERY_TYPE_MESGS;
+}
+
+static char *get_query_string(struct nm_ctxdata *data)
+{
+	struct uri_tag *item;
+
+	if (!data)
+		return NULL;
+	if (data->db_query)
+		return data->db_query;
+
+	for (item = data->query_items; item; item = item->next) {
+		if (!item->value || !item->name)
+			continue;
+
+		if (strcmp(item->name, "limit") == 0) {
+			if (mutt_atoi(item->value, &data->db_limit))
+				mutt_error (_("failed to parse notmuch limit: %s"), item->value);
+
+		} else if (strcmp(item->name, "type") == 0)
+			data->query_type = string_to_guery_type(item->value);
+
+		else if (strcmp(item->name, "query") == 0)
+			data->db_query = safe_strdup(item->value);
+	}
+
+	if (!data->query_type)
+		data->query_type = string_to_guery_type(NULL);
+
+	dprint(2, (debugfile, "nm: query '%s'\n", data->db_query));
+
+	return data->db_query;
+}
+
+static int get_limit(struct nm_ctxdata *data)
+{
+	return data ? data->db_limit : 0;
+}
+
+static int get_query_type(struct nm_ctxdata *data)
+{
+	return (data && data->query_type) ? data->query_type : string_to_guery_type(NULL);
+}
+
+static const char *get_db_filename(struct nm_ctxdata *data)
+{
+	char *db_filename;
+
+	if (!data)
+		return NULL;
+
+	db_filename = data->db_filename ? data->db_filename : NotmuchDefaultUri;
+	if (!db_filename)
+		db_filename = Maildir;
+	if (!db_filename)
+		return NULL;
+	if (strncmp(db_filename, "notmuch://", 10) == 0)
+		db_filename += 10;
+
+	dprint(2, (debugfile, "nm: db filename '%s'\n", db_filename));
+	return db_filename;
+}
+
+static notmuch_database_t *do_database_open(const char *filename,
+					    int writable, int verbose)
+{
+	notmuch_database_t *db = NULL;
+	unsigned int ct = 0;
+	notmuch_status_t st = NOTMUCH_STATUS_SUCCESS;
+
+	dprint(1, (debugfile, "nm: db open '%s' %s (timeout %d)\n", filename,
+			writable ? "[WRITE]" : "[READ]", NotmuchOpenTimeout));
+	do {
+#ifdef NOTMUCH_API_3
+		st = notmuch_database_open(filename,
+					writable ? NOTMUCH_DATABASE_MODE_READ_WRITE :
+					NOTMUCH_DATABASE_MODE_READ_ONLY, &db);
+#else
+		db = notmuch_database_open(filename,
+					writable ? NOTMUCH_DATABASE_MODE_READ_WRITE :
+					NOTMUCH_DATABASE_MODE_READ_ONLY);
+#endif
+		if (db || !NotmuchOpenTimeout || ct / 2 > NotmuchOpenTimeout)
+			break;
+
+		if (verbose && ct && ct % 2 == 0)
+			mutt_error(_("Waiting for notmuch DB... (%d sec)"), ct / 2);
+		usleep(500000);
+		ct++;
+	} while (1);
+
+	if (verbose) {
+		if (!db)
+			mutt_error (_("Cannot open notmuch database: %s: %s"),
+				    filename,
+				    st ? notmuch_status_to_string(st) :
+					 _("unknown reason"));
+		else if (ct > 1)
+			mutt_clear_error();
+	}
+	return db;
+}
+
+static notmuch_database_t *get_db(struct nm_ctxdata *data, int writable)
+{
+	if (!data)
+	       return NULL;
+	if (!data->db) {
+		const char *db_filename = get_db_filename(data);
+
+		if (db_filename)
+			data->db = do_database_open(db_filename, writable, TRUE);
+	}
+	return data->db;
+}
+
+static int release_db(struct nm_ctxdata *data)
+{
+	if (data && data->db) {
+		dprint(1, (debugfile, "nm: db close\n"));
+#ifdef NOTMUCH_API_3
+		notmuch_database_destroy(data->db);
+#else
+		notmuch_database_close(data->db);
+#endif
+		data->db = NULL;
+		data->longrun = 0;
+		return 0;
+	}
+
+	return -1;
+}
+
+/* returns:	< 0 = error
+ *		  1 = new transaction started
+ *		  0 = already within transaction
+ */
+static int db_trans_begin(struct nm_ctxdata *data)
+{
+	if (!data || !data->db)
+		return -1;
+
+	if (!data->trans) {
+		dprint(2, (debugfile, "nm: db trans start\n"));
+		if (notmuch_database_begin_atomic(data->db))
+			return -1;
+		data->trans = 1;
+		return 1;
+	}
+
+	return 0;
+}
+
+static int db_trans_end(struct nm_ctxdata *data)
+{
+	if (!data || !data->db)
+		return -1;
+
+	if (data->trans) {
+		dprint(2, (debugfile, "nm: db trans end\n"));
+		data->trans = 0;
+		if (notmuch_database_end_atomic(data->db))
+			return -1;
+	}
+
+	return 0;
+}
+
+void nm_longrun_init(CONTEXT *ctx, int writable)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (data && get_db(data, writable)) {
+		data->longrun = 1;
+		dprint(2, (debugfile, "nm: long run initialized\n"));
+	}
+}
+
+void nm_longrun_done(CONTEXT *ctx)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (data && release_db(data) == 0)
+		dprint(2, (debugfile, "nm: long run deinitialized\n"));
+}
+
+static int is_longrun(struct nm_ctxdata *data)
+{
+	return data && data->longrun;
+}
+
+void nm_debug_check(CONTEXT *ctx)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (!data)
+		return;
+
+	if (data->db) {
+		dprint(1, (debugfile, "nm: ERROR: db is open, closing\n"));
+		release_db(data);
+	}
+}
+
+static int get_database_mtime(struct nm_ctxdata *data, time_t *mtime)
+{
+	char path[_POSIX_PATH_MAX];
+	struct stat st;
+
+	if (!data)
+	       return -1;
+
+	snprintf(path, sizeof(path), "%s/.notmuch/xapian", get_db_filename(data));
+	dprint(2, (debugfile, "nm: checking '%s' mtime\n", path));
+
+	if (stat(path, &st))
+		return -1;
+
+	if (mtime)
+		*mtime = st.st_mtime;
+
+	return 0;
+}
+
+static void apply_exclude_tags(notmuch_query_t *query)
+{
+	char *buf, *p, *end = NULL, *tag = NULL;
+
+	if (!NotmuchExcludeTags || !*NotmuchExcludeTags)
+		return;
+	buf = safe_strdup(NotmuchExcludeTags);
+
+	for (p = buf; p && *p; p++) {
+		if (!tag && isspace(*p))
+			continue;
+		if (!tag)
+			tag = p;		/* begin of the tag */
+		if (*p == ',' || *p == ' ')
+			end = p;		/* terminate the tag */
+		else if (*(p + 1) == '\0')
+			end = p + 1;		/* end of optstr */
+		if (!tag || !end)
+			continue;
+		if (tag >= end)
+			break;
+		*end = '\0';
+
+		dprint(2, (debugfile, "nm: query exclude tag '%s'\n", tag));
+		notmuch_query_add_tag_exclude(query, tag);
+		end = tag = NULL;
+	}
+	notmuch_query_set_omit_excluded(query, 1);
+	FREE(&buf);
+}
+
+static notmuch_query_t *get_query(struct nm_ctxdata *data, int writable)
+{
+	notmuch_database_t *db = NULL;
+	notmuch_query_t *q = NULL;
+	const char *str;
+
+	if (!data)
+		return NULL;
+
+	db = get_db(data, writable);
+	str = get_query_string(data);
+
+	if (!db || !str)
+		goto err;
+
+	q = notmuch_query_create(db, str);
+	if (!q)
+		goto err;
+
+	apply_exclude_tags(q);
+	notmuch_query_set_sort(q, NOTMUCH_SORT_NEWEST_FIRST);
+	dprint(2, (debugfile, "nm: query successfully initialized\n"));
+	return q;
+err:
+	if (!is_longrun(data))
+		release_db(data);
+	return NULL;
+}
+
+static void append_str_item(char **str, const char *item, int sep)
+{
+	char *p;
+	size_t sz = strlen(item);
+	size_t ssz = *str ? strlen(*str) : 0;
+
+	safe_realloc(str, ssz + (ssz && sep ? 1 : 0) + sz + 1);
+	p = *str + ssz;
+	if (sep && ssz)
+	    *p++ = sep;
+	memcpy(p, item, sz + 1);
+}
+
+static int update_header_tags(HEADER *h, notmuch_message_t *msg)
+{
+	struct nm_hdrdata *data = h->data;
+	notmuch_tags_t *tags;
+	char *tstr = NULL, *ttstr = NULL;
+	struct nm_hdrtag *tag_list = NULL, *tmp;
+
+	dprint(2, (debugfile, "nm: tags update requested (%s)\n", data->virtual_id));
+
+	for (tags = notmuch_message_get_tags(msg);
+	     tags && notmuch_tags_valid(tags);
+	     notmuch_tags_move_to_next(tags)) {
+
+		const char *t = notmuch_tags_get(tags);
+		const char *tt = NULL;
+
+		if (!t || !*t)
+			continue;
+
+		tt = hash_find(TagTransforms, t);
+		if (!tt)
+			tt = t;
+
+		/* tags list contains all tags */
+		tmp = safe_calloc(1, sizeof(*tmp));
+		tmp->tag = safe_strdup(t);
+		tmp->transformed = safe_strdup(tt);
+		tmp->next = tag_list;
+		tag_list = tmp;
+
+		/* filter out hidden tags */
+		if (NotmuchHiddenTags) {
+			char *p = strstr(NotmuchHiddenTags, t);
+			size_t xsz = p ? strlen(t) : 0;
+
+			if (p && (p == NotmuchHiddenTags
+				  || *(p - 1) == ','
+				  || *(p - 1) == ' ')
+			    && (*(p + xsz) == '\0'
+				  || *(p + xsz) == ','
+				  || *(p + xsz) == ' '))
+				continue;
+		}
+
+		/* expand the transformed tag string */
+		append_str_item(&ttstr, tt, ' ');
+
+		/* expand the un-transformed tag string */
+		append_str_item(&tstr, t, ' ');
+	}
+
+	free_tag_list(&data->tag_list);
+	data->tag_list = tag_list;
+
+	if (data->tags && tstr && strcmp(data->tags, tstr) == 0) {
+		FREE(&tstr);
+		FREE(&ttstr);
+		dprint(2, (debugfile, "nm: tags unchanged\n"));
+		return 1;
+	}
+
+	/* free old version */
+	FREE(&data->tags);
+	FREE(&data->tags_transformed);
+
+	/* new version */
+	data->tags = tstr;
+	dprint(2, (debugfile, "nm: new tags: '%s'\n", tstr));
+
+	data->tags_transformed = ttstr;
+	dprint(2, (debugfile, "nm: new tag transforms: '%s'\n", ttstr));
+
+	return 0;
+}
+
+/*
+ * set/update HEADER->path and HEADER->data->path
+ */
+static int update_message_path(HEADER *h, const char *path)
+{
+	struct nm_hdrdata *data = h->data;
+	char *p;
+
+	dprint(2, (debugfile, "nm: path update requested path=%s, (%s)\n",
+				path, data->virtual_id));
+
+	p = strrchr(path, '/');
+	if (p && p - path > 3 &&
+	    (strncmp(p - 3, "cur", 3) == 0 ||
+	     strncmp(p - 3, "new", 3) == 0 ||
+	     strncmp(p - 3, "tmp", 3) == 0)) {
+
+		data->magic = M_MAILDIR;
+
+		FREE(&h->path);
+		FREE(&data->folder);
+
+		p -= 3;				/* skip subfolder (e.g. "new") */
+		h->path = safe_strdup(p);
+
+		for (; p > path && *(p - 1) == '/'; p--);
+
+		data->folder = strndup(path, p - path);
+
+		dprint(2, (debugfile, "nm: folder='%s', file='%s'\n", data->folder, h->path));
+		return 0;
+	}
+
+	return 1;
+}
+
+static char *get_folder_from_path(const char *path)
+{
+	char *p = strrchr(path, '/');
+
+	if (p && p - path > 3 &&
+	    (strncmp(p - 3, "cur", 3) == 0 ||
+	     strncmp(p - 3, "new", 3) == 0 ||
+	     strncmp(p - 3, "tmp", 3) == 0)) {
+
+		p -= 3;
+		for (; p > path && *(p - 1) == '/'; p--);
+
+		return strndup(path, p - path);
+	}
+
+	return NULL;
+}
+
+static void deinit_header(HEADER *h)
+{
+	if (h) {
+		free_hdrdata(h->data);
+		h->data = NULL;
+	}
+}
+
+/* converts notmuch message Id to mutt message <Id> */
+static char *nm2mutt_message_id(const char *id)
+{
+	size_t sz;
+	char *mid;
+
+	if (!id)
+		return NULL;
+	sz = strlen(id) + 3;
+	mid = safe_malloc(sz);
+
+	snprintf(mid, sz, "<%s>", id);
+	return mid;
+}
+
+static int init_header(HEADER *h, const char *path, notmuch_message_t *msg)
+{
+	const char *id;
+
+	if (h->data)
+		return 0;
+
+	id = notmuch_message_get_message_id(msg);
+
+	h->data = safe_calloc(1, sizeof(struct nm_hdrdata));
+	h->free_cb = deinit_header;
+
+	/*
+	 * Notmuch ensures that message Id exists (if not notmuch Notmuch will
+	 * generate an ID), so it's more safe than use mutt HEADER->env->id
+	 */
+	((struct nm_hdrdata *) h->data)->virtual_id = safe_strdup( id );
+
+	dprint(2, (debugfile, "nm: initialize header data: [hdr=%p, data=%p] (%s)\n",
+				h, h->data, id));
+
+	if (!h->env->message_id)
+		h->env->message_id = nm2mutt_message_id( id );
+
+	if (update_message_path(h, path))
+		return -1;
+
+	update_header_tags(h, msg);
+
+	return 0;
+}
+
+/**
+static void debug_print_filenames(notmuch_message_t *msg)
+{
+	notmuch_filenames_t *ls;
+	const char *id = notmuch_message_get_message_id(msg);
+
+	for (ls = notmuch_message_get_filenames(msg);
+	     ls && notmuch_filenames_valid(ls);
+	     notmuch_filenames_move_to_next(ls)) {
+
+		dprint(2, (debugfile, "nm: %s: %s\n", id, notmuch_filenames_get(ls)));
+	}
+}
+
+static void debug_print_tags(notmuch_message_t *msg)
+{
+	notmuch_tags_t *tags;
+	const char *id = notmuch_message_get_message_id(msg);
+
+	for (tags = notmuch_message_get_tags(msg);
+	     tags && notmuch_tags_valid(tags);
+	     notmuch_tags_move_to_next(tags)) {
+
+		dprint(2, (debugfile, "nm: %s: %s\n", id, notmuch_tags_get(tags)));
+	}
+}
+***/
+
+static const char *get_message_last_filename(notmuch_message_t *msg)
+{
+	notmuch_filenames_t *ls;
+	const char *name = NULL;
+
+	for (ls = notmuch_message_get_filenames(msg);
+	     ls && notmuch_filenames_valid(ls);
+	     notmuch_filenames_move_to_next(ls)) {
+
+		name = notmuch_filenames_get(ls);
+	}
+
+	return name;
+}
+
+static void nm_progress_reset(CONTEXT *ctx)
+{
+	struct nm_ctxdata *data;
+
+	if (ctx->quiet)
+		return;
+
+	data = get_ctxdata(ctx);
+
+	memset(&data->progress, 0, sizeof(data->progress));
+	data->oldmsgcount = ctx->msgcount;
+	data->ignmsgcount = 0;
+	data->noprogress = 0;
+	data->progress_ready = 0;
+}
+
+static void nm_progress_update(CONTEXT *ctx, notmuch_query_t *q)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (ctx->quiet || data->noprogress)
+		return;
+
+	if (!data->progress_ready && q) {
+		unsigned count;
+		static char msg[STRING];
+		snprintf(msg, sizeof(msg), _("Reading messages..."));
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+		if (notmuch_query_count_messages_st (q, &count) != NOTMUCH_STATUS_SUCCESS)
+			count = 0;	/* may not be defined on error */
+#else
+		count = notmuch_query_count_messages(q);
+#endif
+		mutt_progress_init(&data->progress, msg, M_PROGRESS_MSG,
+			ReadInc, count);
+		data->progress_ready = 1;
+	}
+
+	if (data->progress_ready)
+		mutt_progress_update(&data->progress,
+				ctx->msgcount + data->ignmsgcount
+					      - data->oldmsgcount, -1);
+}
+
+static void append_message(CONTEXT *ctx,
+			   notmuch_query_t *q,
+			   notmuch_message_t *msg,
+			   int dedup)
+{
+	char *newpath = NULL;
+	const char *path;
+	HEADER *h = NULL;
+
+	/* deduplicate */
+	if (dedup && get_mutt_header(ctx, msg)) {
+		get_ctxdata(ctx)->ignmsgcount++;
+		nm_progress_update(ctx, q);
+	        dprint(2, (debugfile, "nm: ignore id=%s, already in the context\n",
+					notmuch_message_get_message_id(msg)));
+		return;
+	}
+
+	path = get_message_last_filename(msg);
+	if (!path)
+		return;
+
+	dprint(2, (debugfile, "nm: appending message, i=%d, id=%s, path=%s\n",
+				ctx->msgcount,
+				notmuch_message_get_message_id(msg),
+				path));
+
+	if (ctx->msgcount >= ctx->hdrmax) {
+		dprint(2, (debugfile, "nm: allocate mx memory\n"));
+		mx_alloc_memory(ctx);
+	}
+	if (access(path, F_OK) == 0)
+		h = maildir_parse_message(M_MAILDIR, path, 0, NULL);
+	else {
+		/* maybe moved try find it... */
+		char *folder = get_folder_from_path(path);
+
+		if (folder) {
+			FILE *f = maildir_open_find_message(folder, path, &newpath);
+			if (f) {
+				h = maildir_parse_stream(M_MAILDIR, f, newpath, 0, NULL);
+				fclose(f);
+
+				dprint(1, (debugfile, "nm: not up-to-date: %s -> %s\n",
+							path, newpath));
+			}
+		}
+		FREE(&folder);
+	}
+
+	if (!h) {
+		dprint(1, (debugfile, "nm: failed to parse message: %s\n", path));
+		goto done;
+	}
+	if (init_header(h, newpath ? newpath : path, msg) != 0) {
+		mutt_free_header(&h);
+		dprint(1, (debugfile, "nm: failed to append header!\n"));
+		goto done;
+	}
+
+	h->active = 1;
+	h->index = ctx->msgcount;
+	ctx->size += h->content->length
+		   + h->content->offset
+		   - h->content->hdr_offset;
+	ctx->hdrs[ctx->msgcount] = h;
+	ctx->msgcount++;
+
+	if (newpath) {
+		/* remember that file has been moved -- nm_sync() will update the DB */
+		struct nm_hdrdata *hd = (struct nm_hdrdata *) h->data;
+
+		if (hd) {
+			dprint(1, (debugfile, "nm: remember obsolete path: %s\n", path));
+			hd->oldpath = safe_strdup(path);
+		}
+	}
+	nm_progress_update(ctx, q);
+done:
+	FREE(&newpath);
+}
+
+/*
+ * add all the replies to a given messages into the display.
+ * Careful, this calls itself recursively to make sure we get
+ * everything.
+ */
+static void append_replies(CONTEXT *ctx,
+			   notmuch_query_t *q,
+			   notmuch_message_t *top,
+			   int dedup)
+{
+	notmuch_messages_t *msgs;
+
+	for (msgs = notmuch_message_get_replies(top);
+	     notmuch_messages_valid(msgs);
+	     notmuch_messages_move_to_next(msgs)) {
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		append_message(ctx, q, m, dedup);
+		/* recurse through all the replies to this message too */
+		append_replies(ctx, q, m, dedup);
+		notmuch_message_destroy(m);
+	}
+}
+
+/*
+ * add each top level reply in the thread, and then add each
+ * reply to the top level replies
+ */
+static void append_thread(CONTEXT *ctx,
+			  notmuch_query_t *q,
+			  notmuch_thread_t *thread,
+			  int dedup)
+{
+	notmuch_messages_t *msgs;
+
+	for (msgs = notmuch_thread_get_toplevel_messages(thread);
+	     notmuch_messages_valid(msgs);
+	     notmuch_messages_move_to_next(msgs)) {
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		append_message(ctx, q, m, dedup);
+		append_replies(ctx, q, m, dedup);
+		notmuch_message_destroy(m);
+	}
+}
+
+static void read_mesgs_query(CONTEXT *ctx, notmuch_query_t *q, int dedup)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	int limit;
+	notmuch_messages_t *msgs;
+
+	if (!data)
+		return;
+
+	limit = get_limit(data);
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+	if (notmuch_query_search_messages_st (q, &msgs) != NOTMUCH_STATUS_SUCCESS)
+		return;
+#else
+	msgs = notmuch_query_search_messages(q);
+#endif
+
+	for (; notmuch_messages_valid(msgs) &&
+		(limit == 0 || ctx->msgcount < limit);
+	     notmuch_messages_move_to_next(msgs)) {
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		append_message(ctx, q, m, dedup);
+		notmuch_message_destroy(m);
+	}
+}
+
+static void read_threads_query(CONTEXT *ctx, notmuch_query_t *q, int dedup, int limit)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	notmuch_threads_t *threads;
+
+	if (!data)
+		return;
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+	if (notmuch_query_search_threads_st (q, &threads) != NOTMUCH_STATUS_SUCCESS)
+		return;
+#else
+	threads = notmuch_query_search_threads(q);
+#endif
+
+	for (; notmuch_threads_valid(threads) &&
+		(limit == 0 || ctx->msgcount < limit);
+	     notmuch_threads_move_to_next(threads)) {
+
+		notmuch_thread_t *thread = notmuch_threads_get(threads);
+		append_thread(ctx, q, thread, dedup);
+		notmuch_thread_destroy(thread);
+	}
+}
+
+int nm_read_query(CONTEXT *ctx)
+{
+	notmuch_query_t *q;
+	struct nm_ctxdata *data;
+	int rc = -1;
+
+	if (init_context(ctx) != 0)
+		return -1;
+
+	data = get_ctxdata(ctx);
+	if (!data)
+		return -1;
+
+	dprint(1, (debugfile, "nm: reading messages...[current count=%d]\n",
+				ctx->msgcount));
+
+	nm_progress_reset(ctx);
+
+	q = get_query(data, FALSE);
+	if (q) {
+		switch(get_query_type(data)) {
+		case NM_QUERY_TYPE_MESGS:
+			read_mesgs_query(ctx, q, 0);
+			break;
+		case NM_QUERY_TYPE_THREADS:
+			read_threads_query(ctx, q, 0, get_limit(data));
+			break;
+		}
+		notmuch_query_destroy(q);
+		rc = 0;
+
+	}
+
+	if (!is_longrun(data))
+		release_db(data);
+
+	ctx->mtime = time(NULL);
+
+	mx_update_context(ctx, ctx->msgcount);
+	data->oldmsgcount = 0;
+
+	dprint(1, (debugfile, "nm: reading messages... done [rc=%d, count=%d]\n",
+				rc, ctx->msgcount));
+	return rc;
+}
+
+int nm_read_entire_thread(CONTEXT *ctx, HEADER *h)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	const char *id;
+	char *qstr = NULL;
+	notmuch_query_t *q = NULL;
+	notmuch_database_t *db = NULL;
+	notmuch_message_t *msg = NULL;
+	int rc = -1;
+
+	if (!data)
+		return -1;
+	if (!(db = get_db(data, FALSE)) || !(msg = get_nm_message(db, h)))
+		goto done;
+
+	dprint(1, (debugfile, "nm: reading entire-thread messages...[current count=%d]\n",
+				ctx->msgcount));
+
+	nm_progress_reset(ctx);
+	id = notmuch_message_get_thread_id(msg);
+	if (!id)
+		goto done;
+	append_str_item(&qstr, "thread:", 0);
+	append_str_item(&qstr, id, 0);
+
+	q = notmuch_query_create(db, qstr);
+	FREE(&qstr);
+	if (!q)
+		goto done;
+	apply_exclude_tags(q);
+	notmuch_query_set_sort(q, NOTMUCH_SORT_NEWEST_FIRST);
+
+	read_threads_query(ctx, q, 1, 0);
+	ctx->mtime = time(NULL);
+	rc = 0;
+
+	if (ctx->msgcount > data->oldmsgcount)
+		mx_update_context(ctx, ctx->msgcount - data->oldmsgcount);
+done:
+	if (q)
+		notmuch_query_destroy(q);
+	if (!is_longrun(data))
+		release_db(data);
+
+	if (ctx->msgcount == data->oldmsgcount)
+		mutt_message _("No more messages in the thread.");
+
+	data->oldmsgcount = 0;
+	dprint(1, (debugfile, "nm: reading entire-thread messages... done [rc=%d, count=%d]\n",
+				rc, ctx->msgcount));
+	return rc;
+}
+
+char *nm_uri_from_query(CONTEXT *ctx, char *buf, size_t bufsz)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	char uri[_POSIX_PATH_MAX + LONG_STRING + 32];	/* path to DB + query + URI "decoration" */
+
+	if (data)
+		snprintf(uri, sizeof(uri), "notmuch://%s?query=%s",
+			 get_db_filename(data), buf);
+	else if (NotmuchDefaultUri)
+		snprintf(uri, sizeof(uri), "%s?query=%s", NotmuchDefaultUri, buf);
+	else if (Maildir)
+		snprintf(uri, sizeof(uri), "notmuch://%s?query=%s", Maildir, buf);
+	else
+		return NULL;
+
+	strncpy(buf, uri, bufsz);
+	buf[bufsz - 1] = '\0';
+
+	dprint(1, (debugfile, "nm: uri from query '%s'\n", buf));
+	return buf;
+}
+
+/*
+ * returns message from notmuch database
+ */
+static notmuch_message_t *get_nm_message(notmuch_database_t *db, HEADER *hdr)
+{
+	notmuch_message_t *msg = NULL;
+	char *id = nm_header_get_id(hdr);
+
+	dprint(2, (debugfile, "nm: find message (%s)\n", id));
+
+	if (id && db)
+		notmuch_database_find_message(db, id, &msg);
+
+	return msg;
+}
+
+static int update_tags(notmuch_message_t *msg, const char *tags)
+{
+	char *tag = NULL, *end = NULL, *p;
+	char *buf = safe_strdup(tags);
+
+	if (!buf)
+		return -1;
+
+	notmuch_message_freeze(msg);
+
+	for (p = buf; p && *p; p++) {
+		if (!tag && isspace(*p))
+			continue;
+		if (!tag)
+			tag = p;		/* begin of the tag */
+		if (*p == ',' || *p == ' ')
+			end = p;		/* terminate the tag */
+		else if (*(p + 1) == '\0')
+			end = p + 1;		/* end of optstr */
+		if (!tag || !end)
+			continue;
+		if (tag >= end)
+			break;
+
+		*end = '\0';
+
+		if (*tag == '-') {
+			dprint(1, (debugfile, "nm: remove tag: '%s'\n", tag + 1));
+			notmuch_message_remove_tag(msg, tag + 1);
+		} else {
+			dprint(1, (debugfile, "nm: add tag: '%s'\n", *tag == '+' ? tag + 1 : tag));
+			notmuch_message_add_tag(msg, *tag == '+' ? tag + 1 : tag);
+		}
+		end = tag = NULL;
+	}
+
+	notmuch_message_thaw(msg);
+	FREE(&buf);
+	return 0;
+}
+
+int nm_modify_message_tags(CONTEXT *ctx, HEADER *hdr, char *buf)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	notmuch_database_t *db = NULL;
+	notmuch_message_t *msg = NULL;
+	int rc = -1;
+
+	if (!buf || !*buf || !data)
+		return -1;
+
+	if (!(db = get_db(data, TRUE)) || !(msg = get_nm_message(db, hdr)))
+		goto done;
+
+	dprint(1, (debugfile, "nm: tags modify: '%s'\n", buf));
+
+	update_tags(msg, buf);
+	update_header_tags(hdr, msg);
+	mutt_set_header_color(ctx, hdr);
+
+	rc = 0;
+	hdr->changed = TRUE;
+done:
+	if (!is_longrun(data))
+		release_db(data);
+	if (hdr->changed)
+		ctx->mtime = time(NULL);
+	dprint(1, (debugfile, "nm: tags modify done [rc=%d]\n", rc));
+	return rc;
+}
+
+static int rename_maildir_filename(const char *old, char *newpath, size_t newsz, HEADER *h)
+{
+	char filename[_POSIX_PATH_MAX];
+	char suffix[_POSIX_PATH_MAX];
+	char folder[_POSIX_PATH_MAX];
+	char *p;
+
+	strfcpy(folder, old, sizeof(folder));
+	p = strrchr(folder, '/');
+	if (p)
+		*p = '\0';
+
+	p++;
+	strfcpy(filename, p, sizeof(filename));
+
+	/* remove (new,cur,...) from folder path */
+	p = strrchr(folder, '/');
+	if (p)
+		*p = '\0';
+
+	/* remove old flags from filename */
+	if ((p = strchr(filename, ':')))
+		*p = '\0';
+
+	/* compose new flags */
+	maildir_flags(suffix, sizeof(suffix), h);
+
+	snprintf(newpath, newsz, "%s/%s/%s%s",
+			folder,
+			(h->read || h->old) ? "cur" : "new",
+			filename,
+			suffix);
+
+	if (strcmp(old, newpath) == 0)
+		return 1;
+
+	if (rename(old, newpath) != 0) {
+		dprint(1, (debugfile, "nm: rename(2) failed %s -> %s\n", old, newpath));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int remove_filename(struct nm_ctxdata *data, const char *path)
+{
+	notmuch_status_t st;
+	notmuch_filenames_t *ls;
+	notmuch_message_t *msg = NULL;
+	notmuch_database_t *db = get_db(data, TRUE);
+	int trans;
+
+	dprint(2, (debugfile, "nm: remove filename '%s'\n", path));
+
+	if (!db)
+		return -1;
+	st = notmuch_database_find_message_by_filename(db, path, &msg);
+	if (st || !msg)
+		return -1;
+	trans = db_trans_begin(data);
+	if (trans < 0)
+		return -1;
+
+	/*
+	 * note that unlink() is probably unnecessary here, it's already removed
+	 * by mh_sync_mailbox_message(), but for sure...
+	 */
+	st = notmuch_database_remove_message(db, path);
+	switch (st) {
+	case NOTMUCH_STATUS_SUCCESS:
+		dprint(2, (debugfile, "nm: remove success, call unlink\n"));
+		unlink(path);
+		break;
+	case NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID:
+		dprint(2, (debugfile, "nm: remove success (duplicate), call unlink\n"));
+		unlink(path);
+		for (ls = notmuch_message_get_filenames(msg);
+		     ls && notmuch_filenames_valid(ls);
+		     notmuch_filenames_move_to_next(ls)) {
+
+			path = notmuch_filenames_get(ls);
+
+			dprint(2, (debugfile, "nm: remove duplicate: '%s'\n", path));
+			unlink(path);
+			notmuch_database_remove_message(db, path);
+		}
+		break;
+	default:
+		dprint(1, (debugfile, "nm: failed to remove '%s' [st=%d]\n", path, (int) st));
+		break;
+	}
+
+	notmuch_message_destroy(msg);
+	if (trans)
+		db_trans_end(data);
+	return 0;
+}
+
+static int rename_filename(struct nm_ctxdata *data,
+			const char *old, const char *new, HEADER *h)
+{
+	int rc = -1;
+	notmuch_status_t st;
+	notmuch_filenames_t *ls;
+	notmuch_message_t *msg;
+	notmuch_database_t *db = get_db(data, TRUE);
+	int trans;
+
+	if (!db || !new || !old || access(new, F_OK) != 0)
+		return -1;
+
+	dprint(1, (debugfile, "nm: rename filename, %s -> %s\n", old, new));
+	trans = db_trans_begin(data);
+	if (trans < 0)
+		return -1;
+
+	dprint(2, (debugfile, "nm: rename: add '%s'\n", new));
+	st = notmuch_database_add_message(db, new, &msg);
+
+	if (st != NOTMUCH_STATUS_SUCCESS &&
+	    st != NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID) {
+		dprint(1, (debugfile, "nm: failed to add '%s' [st=%d]\n", new, (int) st));
+		goto done;
+	}
+
+	dprint(2, (debugfile, "nm: rename: rem '%s'\n", old));
+	st = notmuch_database_remove_message(db, old);
+	switch (st) {
+	case NOTMUCH_STATUS_SUCCESS:
+		break;
+	case NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID:
+		dprint(2, (debugfile, "nm: rename: syncing duplicate filename\n"));
+		notmuch_message_destroy(msg);
+		msg = NULL;
+		notmuch_database_find_message_by_filename(db, new, &msg);
+
+		for (ls = notmuch_message_get_filenames(msg);
+		     msg && ls && notmuch_filenames_valid(ls);
+		     notmuch_filenames_move_to_next(ls)) {
+
+			const char *path = notmuch_filenames_get(ls);
+			char newpath[_POSIX_PATH_MAX];
+
+			if (strcmp(new, path) == 0)
+				continue;
+
+			dprint(2, (debugfile, "nm: rename: syncing duplicate: %s\n", path));
+
+			if (rename_maildir_filename(path, newpath, sizeof(newpath), h) == 0) {
+				dprint(2, (debugfile, "nm: rename dup %s -> %s\n", path, newpath));
+				notmuch_database_remove_message(db, path);
+				notmuch_database_add_message(db, newpath, NULL);
+			}
+		}
+		notmuch_message_destroy(msg);
+		msg = NULL;
+		notmuch_database_find_message_by_filename(db, new, &msg);
+		st = NOTMUCH_STATUS_SUCCESS;
+		break;
+	default:
+		dprint(1, (debugfile, "nm: failed to remove '%s' [st=%d]\n",
+					old, (int) st));
+		break;
+	}
+
+	if (st == NOTMUCH_STATUS_SUCCESS && h && msg) {
+		notmuch_message_maildir_flags_to_tags(msg);
+		update_header_tags(h, msg);
+		update_tags(msg, nm_header_get_tags(h));
+	}
+
+	rc = 0;
+done:
+	if (msg)
+		notmuch_message_destroy(msg);
+	if (trans)
+		db_trans_end(data);
+	return rc;
+}
+
+int nm_update_filename(CONTEXT *ctx, const char *old, const char *new, HEADER *h)
+{
+	char buf[PATH_MAX];
+	int rc;
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (!data || !new)
+		return -1;
+
+	if (!old && h && h->data) {
+		nm_header_get_fullpath(h, buf, sizeof(buf));
+		old = buf;
+	}
+
+	rc = rename_filename(data, old, new, h);
+
+	if (!is_longrun(data))
+		release_db(data);
+	ctx->mtime = time(NULL);
+	return rc;
+}
+
+int nm_sync(CONTEXT *ctx, int *index_hint)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	int i, rc = 0;
+	char msgbuf[STRING];
+	progress_t progress;
+	char *uri = ctx->path;
+	int changed = 0;
+
+	if (!data)
+		return -1;
+
+	dprint(1, (debugfile, "nm: sync start ...\n"));
+
+	if (!ctx->quiet) {
+		/* all is in this function so we don't use data->progress here */
+		snprintf(msgbuf, sizeof (msgbuf), _("Writing %s..."), ctx->path);
+		mutt_progress_init(&progress, msgbuf, M_PROGRESS_MSG,
+				   WriteInc, ctx->msgcount);
+	}
+
+	for (i = 0; i < ctx->msgcount; i++) {
+		char old[_POSIX_PATH_MAX], new[_POSIX_PATH_MAX];
+		HEADER *h = ctx->hdrs[i];
+		struct nm_hdrdata *hd = h->data;
+
+		if (!ctx->quiet)
+			mutt_progress_update(&progress, i, -1);
+
+		*old = *new = '\0';
+
+		if (hd->oldpath) {
+			strncpy(old, hd->oldpath, sizeof(old));
+			old[sizeof(old) - 1] = '\0';
+			dprint(2, (debugfile, "nm: fixing obsolete path '%s'\n", old));
+		} else
+			nm_header_get_fullpath(h, old, sizeof(old));
+
+		ctx->path = hd->folder;
+		ctx->magic = hd->magic;
+#if USE_HCACHE
+		rc = mh_sync_mailbox_message(ctx, i, NULL);
+#else
+		rc = mh_sync_mailbox_message(ctx, i);
+#endif
+		ctx->path = uri;
+		ctx->magic = M_NOTMUCH;
+
+		if (rc)
+			break;
+
+		if (!h->deleted)
+			nm_header_get_fullpath(h, new, sizeof(new));
+
+		if (h->deleted || strcmp(old, new) != 0) {
+			if (h->deleted && remove_filename(data, old) == 0)
+				changed = 1;
+			else if (*new && *old && rename_filename(data, old, new, h) == 0)
+				changed = 1;
+		}
+
+		FREE(&hd->oldpath);
+	}
+
+	ctx->path = uri;
+	ctx->magic = M_NOTMUCH;
+
+	if (!is_longrun(data))
+		release_db(data);
+	if (changed)
+		ctx->mtime = time(NULL);
+
+	dprint(1, (debugfile, "nm: .... sync done [rc=%d]\n", rc));
+	return rc;
+}
+
+static unsigned count_query(notmuch_database_t *db, const char *qstr)
+{
+	unsigned res = 0;
+	notmuch_query_t *q = notmuch_query_create(db, qstr);
+
+	if (q) {
+		apply_exclude_tags(q);
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+		if (notmuch_query_count_messages_st (q, &res) != NOTMUCH_STATUS_SUCCESS)
+			res = 0;	/* may not be defined on error */
+#else
+		res = notmuch_query_count_messages(q);
+#endif
+		notmuch_query_destroy(q);
+		dprint(1, (debugfile, "nm: count '%s', result=%d\n", qstr, res));
+	}
+	return res;
+}
+
+int nm_nonctx_get_count(char *path, int *all, int *new)
+{
+	struct uri_tag *query_items = NULL, *item;
+	char *db_filename = NULL, *db_query = NULL;
+	notmuch_database_t *db = NULL;
+	int rc = -1, dflt = 0;
+
+	dprint(1, (debugfile, "nm: count\n"));
+
+	if (url_parse_query(path, &db_filename, &query_items)) {
+		mutt_error(_("failed to parse notmuch uri: %s"), path);
+		goto done;
+	}
+	if (!query_items)
+		goto done;
+
+	for (item = query_items; item; item = item->next) {
+		if (item->value && strcmp(item->name, "query") == 0) {
+			db_query = item->value;
+			break;
+		}
+	}
+
+	if (!db_query)
+		goto done;
+
+	if (!db_filename) {
+		if (NotmuchDefaultUri) {
+			if (strncmp(NotmuchDefaultUri, "notmuch://", 10) == 0)
+				db_filename = NotmuchDefaultUri + 10;
+			else
+				db_filename = NotmuchDefaultUri;
+		} else if (Maildir)
+			db_filename = Maildir;
+		dflt = 1;
+	}
+
+	/* don't be verbose about connection, as we're called from
+	 * sidebar/buffy very often */
+	db = do_database_open(db_filename, FALSE, FALSE);
+	if (!db)
+		goto done;
+
+	/* all emails */
+	if (all)
+		*all = count_query(db, db_query);
+
+	/* new messages */
+	if (new) {
+		char *qstr;
+
+		safe_asprintf(&qstr, "( %s ) tag:%s",
+				db_query, NotmuchUnreadTag);
+		*new = count_query(db, qstr);
+		FREE(&qstr);
+	}
+
+	rc = 0;
+done:
+	if (db) {
+#ifdef NOTMUCH_API_3
+		notmuch_database_destroy(db);
+#else
+		notmuch_database_close(db);
+#endif
+		dprint(1, (debugfile, "nm: count close DB\n"));
+	}
+	if (!dflt)
+		FREE(&db_filename);
+	url_free_tags(query_items);
+
+	dprint(1, (debugfile, "nm: count done [rc=%d]\n", rc));
+	return rc;
+}
+
+char *nm_get_description(CONTEXT *ctx)
+{
+	BUFFY *p;
+
+	for (p = VirtIncoming; p; p = p->next)
+		if (p->desc && strcmp(p->path, ctx->path) == 0)
+			return p->desc;
+
+	return NULL;
+}
+
+int nm_description_to_path(const char *desc, char *buf, size_t bufsz)
+{
+	BUFFY *p;
+
+	if (!desc || !buf || !bufsz)
+		return -EINVAL;
+
+	for (p = VirtIncoming; p; p = p->next)
+		if (p->desc && strcmp(desc, p->desc) == 0) {
+			strncpy(buf, p->path, bufsz);
+			buf[bufsz - 1] = '\0';
+			return 0;
+		}
+
+	return -1;
+}
+
+/*
+ * returns header from mutt context
+ */
+static HEADER *get_mutt_header(CONTEXT *ctx, notmuch_message_t *msg)
+{
+	char *mid;
+	const char *id;
+	HEADER *h;
+
+	if (!ctx || !msg)
+		return NULL;
+
+	id = notmuch_message_get_message_id(msg);
+	if (!id)
+		return NULL;
+
+	dprint(2, (debugfile, "nm: mutt header, id='%s'\n", id));
+
+	if (!ctx->id_hash) {
+		dprint(2, (debugfile, "nm: init hash\n"));
+		ctx->id_hash = mutt_make_id_hash(ctx);
+		if (!ctx->id_hash)
+			return NULL;
+	}
+
+	mid = nm2mutt_message_id( id );
+	dprint(2, (debugfile, "nm: mutt id='%s'\n", mid));
+
+	h = hash_find(ctx->id_hash, mid);
+	FREE(&mid);
+	return h;
+}
+
+int nm_check_database(CONTEXT *ctx, int *index_hint)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	time_t mtime = 0;
+	notmuch_query_t *q;
+	notmuch_messages_t *msgs;
+	int i, limit, occult = 0, new_flags = 0;
+
+	if (!data || get_database_mtime(data, &mtime) != 0)
+		return -1;
+
+	if (ctx->mtime >= mtime) {
+		dprint(2, (debugfile, "nm: check unnecessary (db=%d ctx=%d)\n", mtime, ctx->mtime));
+		return 0;
+	}
+
+	dprint(1, (debugfile, "nm: checking (db=%d ctx=%d)\n", mtime, ctx->mtime));
+
+	q = get_query(data, FALSE);
+	if (!q)
+		goto done;
+
+	dprint(1, (debugfile, "nm: start checking (count=%d)\n", ctx->msgcount));
+	data->oldmsgcount = ctx->msgcount;
+	data->noprogress = 1;
+
+	for (i = 0; i < ctx->msgcount; i++)
+		ctx->hdrs[i]->active = 0;
+
+	limit = get_limit(data);
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+	if (notmuch_query_search_messages_st (q, &msgs) != NOTMUCH_STATUS_SUCCESS)
+		goto done;
+#else
+	msgs = notmuch_query_search_messages(q);
+#endif
+
+	for (i = 0;
+	     notmuch_messages_valid(msgs) && (limit == 0 || i < limit);
+	     notmuch_messages_move_to_next(msgs), i++) {
+
+		char old[_POSIX_PATH_MAX];
+		const char *new;
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		HEADER *h = get_mutt_header(ctx, m);
+
+		if (!h) {
+			/* new email */
+			append_message(ctx, NULL, m, 0);
+			notmuch_message_destroy(m);
+			continue;
+		}
+
+		/* message already exists, merge flags */
+		h->active = 1;
+
+		/* check to see if the message has moved to a different
+		 * subdirectory.  If so, update the associated filename.
+		 */
+		new = get_message_last_filename(m);
+		nm_header_get_fullpath(h, old, sizeof(old));
+
+		if (mutt_strcmp(old, new) != 0)
+			update_message_path(h, new);
+
+		if (!h->changed) {
+			/* if the user hasn't modified the flags on
+			 * this message, update the flags we just
+			 * detected.
+			 */
+			HEADER tmp;
+			memset(&tmp, 0, sizeof(tmp));
+			maildir_parse_flags(&tmp, new);
+			maildir_update_flags(ctx, h, &tmp);
+		}
+
+		if (update_header_tags(h, m) == 0)
+			new_flags++;
+
+		notmuch_message_destroy(m);
+	}
+
+	for (i = 0; i < ctx->msgcount; i++) {
+		if (ctx->hdrs[i]->active == 0) {
+			occult = 1;
+			break;
+		}
+	}
+
+	if (ctx->msgcount > data->oldmsgcount)
+		mx_update_context(ctx, ctx->msgcount - data->oldmsgcount);
+done:
+	if (q)
+		notmuch_query_destroy(q);
+
+	if (!is_longrun(data))
+		release_db(data);
+
+	ctx->mtime = time(NULL);
+
+	dprint(1, (debugfile, "nm: ... check done [count=%d, new_flags=%d, occult=%d]\n",
+				ctx->msgcount, new_flags, occult));
+
+	return occult ? M_REOPENED :
+	       ctx->msgcount > data->oldmsgcount ? M_NEW_MAIL :
+	       new_flags ? M_FLAGS : 0;
+}
+
+int nm_record_message(CONTEXT *ctx, char *path, HEADER *h)
+{
+	notmuch_database_t *db;
+	notmuch_status_t st;
+	notmuch_message_t *msg = NULL;
+	int rc = -1, trans;
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (!path || !data || access(path, F_OK) != 0)
+		return 0;
+	db = get_db(data, TRUE);
+	if (!db)
+		return -1;
+
+	dprint(1, (debugfile, "nm: record message: %s\n", path));
+	trans = db_trans_begin(data);
+	if (trans < 0)
+		goto done;
+
+	st = notmuch_database_add_message(db, path, &msg);
+
+	if (st != NOTMUCH_STATUS_SUCCESS &&
+	    st != NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID) {
+		dprint(1, (debugfile, "nm: failed to add '%s' [st=%d]\n", path, (int) st));
+		goto done;
+	}
+
+	if (st == NOTMUCH_STATUS_SUCCESS && msg) {
+		notmuch_message_maildir_flags_to_tags(msg);
+		if (h)
+			update_tags(msg, nm_header_get_tags(h));
+		if (NotmuchRecordTags)
+			update_tags(msg, NotmuchRecordTags);
+	}
+
+	rc = 0;
+done:
+	if (msg)
+		notmuch_message_destroy(msg);
+	if (trans == 1)
+		db_trans_end(data);
+	if (!is_longrun(data))
+		release_db(data);
+	return rc;
+}
+
+/*
+ * Fill a list with all notmuch tags.
+ *
+ * If tag_list is NULL, just count the tags.
+ */
+int nm_get_all_tags(CONTEXT *ctx, char **tag_list, int *tag_count)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	notmuch_database_t *db = NULL;
+	notmuch_tags_t *tags = NULL;
+	int rc = -1;
+
+	if (!data)
+		return -1;
+
+	if (!(db = get_db(data, FALSE)) ||
+			!(tags = notmuch_database_get_all_tags(db)))
+		goto done;
+
+	*tag_count = 0;
+	dprint(1, (debugfile, "nm: get all tags\n"));
+
+	while (notmuch_tags_valid(tags)) {
+		if (tag_list != NULL) {
+			tag_list[*tag_count] = safe_strdup(notmuch_tags_get(tags));
+		}
+		(*tag_count)++;
+		notmuch_tags_move_to_next(tags);
+	}
+
+	rc = 0;
+done:
+	if (tags)
+		notmuch_tags_destroy(tags);
+
+	if (!is_longrun(data))
+		release_db(data);
+
+	dprint(1, (debugfile, "nm: get all tags done [rc=%d tag_count=%u]\n", rc,
+						 *tag_count));
+	return rc;
+}
diff --git a/mutt_notmuch.h b/mutt_notmuch.h
new file mode 100644
index 0000000..df4baa2
--- /dev/null
+++ b/mutt_notmuch.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2011 Karel Zak <kzak@redhat.com>
+ */
+#ifndef _MUTT_NOTMUCH_H_
+#define _MUTT_NOTMUCH_H_ 1
+
+int nm_read_query(CONTEXT *ctx);
+int nm_read_entire_thread(CONTEXT *ctx, HEADER *h);
+
+int nm_sync(CONTEXT * ctx, int *index_hint);
+int nm_check_database(CONTEXT * ctx, int *index_hint);
+char *nm_header_get_folder(HEADER *h);
+int nm_header_get_magic(HEADER *h);
+char *nm_header_get_fullpath(HEADER *h, char *buf, size_t bufsz);
+int nm_update_filename(CONTEXT *ctx, const char *o, const char *n, HEADER *h);
+char *nm_uri_from_query(CONTEXT *ctx, char *buf, size_t bufsz);
+int nm_modify_message_tags(CONTEXT *ctx, HEADER *hdr, char *tags);
+
+void nm_longrun_init(CONTEXT *cxt, int writable);
+void nm_longrun_done(CONTEXT *cxt);
+
+char *nm_get_description(CONTEXT *ctx);
+int nm_description_to_path(const char *desc, char *buf, size_t bufsz);
+
+int nm_record_message(CONTEXT *ctx, char *path, HEADER *h);
+
+void nm_debug_check(CONTEXT *ctx);
+int nm_get_all_tags(CONTEXT *ctx, char **tag_list, int *tag_count);
+
+/*
+ * functions usable outside notmuch CONTEXT
+ */
+int nm_nonctx_get_count(char *path, int *all, int *new);
+
+char *nm_header_get_tag_transformed(char *tag, HEADER *h);
+char *nm_header_get_tags_transformed(HEADER *h);
+char *nm_header_get_tags(HEADER *h);
+
+#endif /* _MUTT_NOTMUCH_H_ */
diff --git a/muttlib.c b/muttlib.c
index 37e8adf..760851b 100644
--- a/muttlib.c
+++ b/muttlib.c
@@ -32,11 +32,18 @@
 #include "imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "mutt_crypt.h"
 
 #include <string.h>
 #include <ctype.h>
 #include <unistd.h>
+#ifdef HAVE_SYS_SYSCALL_H
+#include <sys/syscall.h>
+#endif
 #include <stdlib.h>
 #include <sys/wait.h>
 #include <errno.h>
@@ -329,7 +336,9 @@ void mutt_free_header (HEADER **h)
 #ifdef MIXMASTER
   mutt_free_list (&(*h)->chain);
 #endif
-#if defined USE_POP || defined USE_IMAP || defined USE_NNTP
+#if defined USE_POP || defined USE_IMAP || defined USE_NOTMUCH || defined USE_NNTP
+  if ((*h)->free_cb)
+    (*h)->free_cb(*h);
   FREE (&(*h)->data);
 #endif
   FREE (h);		/* __FREE_CHECKED__ */
@@ -440,6 +449,11 @@ char *_mutt_expand_path (char *s, size_t slen, int rx)
 	  strfcpy (p, NONULL (Maildir), sizeof (p));
 	else
 #endif
+#ifdef USE_NOTMUCH
+	if (mx_is_notmuch (NONULL (Maildir)))
+	  strfcpy (p, NONULL (Maildir), sizeof (p));
+	else
+#endif
 	if (Maildir && *Maildir && Maildir[strlen (Maildir) - 1] == '/')
 	  strfcpy (p, NONULL (Maildir), sizeof (p));
 	else
@@ -827,6 +841,11 @@ void mutt_pretty_mailbox (char *s, size_t buflen)
   }
 #endif
 
+#ifdef USE_NOTMUCH
+  if (scheme == U_NOTMUCH)
+    return;
+#endif
+
   /* if s is an url, only collapse path component */
   if (scheme != U_UNKNOWN)
   {
diff --git a/mx.c b/mx.c
index e813ca4..7a0f237 100644
--- a/mx.c
+++ b/mx.c
@@ -45,6 +45,10 @@
 #include "pop.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #ifdef USE_NNTP
 #include "nntp.h"
 #endif
@@ -68,6 +72,10 @@
 #include <ctype.h>
 #include <utime.h>
 
+#if USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 
 #define mutt_is_spool(s)  (mutt_strcmp (Spoolfile, s) == 0)
 
@@ -370,6 +378,24 @@ int mx_is_nntp (const char *p)
 }
 #endif
 
+#ifdef USE_NOTMUCH
+
+int mx_is_notmuch(const char *p)
+{
+  url_scheme_t scheme;
+
+  if (!p)
+    return 0;
+
+  scheme = url_check_scheme (p);
+  if (scheme == U_NOTMUCH)
+    return 1;
+
+  return 0;
+}
+
+#endif
+
 int mx_get_magic (const char *path)
 {
   struct stat st;
@@ -387,6 +413,11 @@ int mx_get_magic (const char *path)
     return M_POP;
 #endif /* USE_POP */
 
+#ifdef USE_NOTMUCH
+  if (mx_is_notmuch(path))
+    return M_NOTMUCH;
+#endif
+
 #ifdef USE_NNTP
   if (mx_is_nntp (path))
     return M_NNTP;
@@ -721,6 +752,12 @@ CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
       break;
 #endif /* USE_POP */
 
+#ifdef USE_NOTMUCH
+    case M_NOTMUCH:
+      rc = nm_read_query (ctx);
+      break;
+#endif /* USE_NOTMUCH */
+
 #ifdef USE_NNTP
     case M_NNTP:
       rc = nntp_open_mailbox (ctx);
@@ -838,6 +875,12 @@ static int sync_mailbox (CONTEXT *ctx, int *index_hint)
       break;
 #endif /* USE_POP */
 
+#ifdef USE_NOTMUCH
+    case M_NOTMUCH:
+      rc = nm_sync (ctx, index_hint);
+      break;
+#endif /* USE_NOTMUCH */
+
 #ifdef USE_NNTP
     case M_NNTP:
       rc = nntp_sync_mailbox (ctx);
@@ -1166,7 +1209,6 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
   if (ctx->compress_info && comp_slow_close (ctx))
     return (-1);
 #endif
-
 #ifdef USE_SIDEBAR
   ctx->msgcount -= ctx->deleted;
   mutt_sb_set_buffystats (ctx);
@@ -1553,6 +1595,11 @@ int mx_check_mailbox (CONTEXT *ctx, int *index_hint, int lock)
 	return (pop_check_mailbox (ctx, index_hint));
 #endif /* USE_POP */
 
+#ifdef USE_NOTMUCH
+      case M_NOTMUCH:
+	return nm_check_database(ctx, index_hint);
+#endif
+
 #ifdef USE_NNTP
       case M_NNTP:
 	return (nntp_check_mailbox (ctx, 0));
@@ -1568,7 +1615,7 @@ int mx_check_mailbox (CONTEXT *ctx, int *index_hint, int lock)
 MESSAGE *mx_open_message (CONTEXT *ctx, int msgno)
 {
   MESSAGE *msg;
-  
+
   msg = safe_calloc (1, sizeof (MESSAGE));
   switch (msg->magic = ctx->magic)
   {
@@ -1579,15 +1626,24 @@ MESSAGE *mx_open_message (CONTEXT *ctx, int msgno)
 
     case M_MH:
     case M_MAILDIR:
+#ifdef USE_NOTMUCH
+    case M_NOTMUCH:
+#endif
     {
       HEADER *cur = ctx->hdrs[msgno];
       char path[_POSIX_PATH_MAX];
-      
-      snprintf (path, sizeof (path), "%s/%s", ctx->path, cur->path);
-      
+      char *folder = ctx->path;
+#ifdef USE_NOTMUCH
+      if (ctx->magic == M_NOTMUCH) {
+	msg->magic = nm_header_get_magic(cur);
+	folder = nm_header_get_folder(cur);
+      }
+#endif
+      snprintf (path, sizeof (path), "%s/%s", folder, cur->path);
+
       if ((msg->fp = fopen (path, "r")) == NULL && errno == ENOENT &&
-	  ctx->magic == M_MAILDIR)
-	msg->fp = maildir_open_find_message (ctx->path, cur->path);
+	  (ctx->magic == M_MAILDIR || ctx->magic == M_NOTMUCH))
+	msg->fp = maildir_open_find_message (folder, cur->path, NULL);
       
       if (msg->fp == NULL)
       {
@@ -1671,13 +1727,17 @@ int mx_commit_message (MESSAGE *msg, CONTEXT *ctx)
       break;
     }
 #endif
-    
+
     case M_MAILDIR:
     {
       r = maildir_commit_message (ctx, msg, NULL);
       break;
     }
-    
+
+    case M_NOTMUCH:
+      mutt_perror _("Can't write to virtual folder.");
+      break;
+
     case M_MH:
     {
       r = mh_commit_message (ctx, msg, NULL);
@@ -1691,7 +1751,7 @@ int mx_commit_message (MESSAGE *msg, CONTEXT *ctx)
     mutt_perror _("Can't write message");
     r = -1;
   }
- 
+
   return r;
 }
 
@@ -1704,6 +1764,7 @@ int mx_close_message (MESSAGE **msg)
 #ifdef USE_NNTP
       || (*msg)->magic == M_NNTP
 #endif
+      || (*msg)->magic == M_NOTMUCH
       || (*msg)->magic == M_IMAP || (*msg)->magic == M_POP)
   {
     r = safe_fclose (&(*msg)->fp);
@@ -1711,7 +1772,10 @@ int mx_close_message (MESSAGE **msg)
   else
     (*msg)->fp = NULL;
 
-  if ((*msg)->path)
+  dprint (2, (debugfile, "mx_close_message (): close: path=%s, commited=%s\n",
+	(*msg)->path, (*msg)->commited_path));
+
+  if ((*msg)->path && (*msg)->magic != M_NOTMUCH)
   {
     dprint (1, (debugfile, "mx_close_message (): unlinking %s\n",
 		(*msg)->path));
@@ -1719,6 +1783,7 @@ int mx_close_message (MESSAGE **msg)
     FREE (&(*msg)->path);
   }
 
+  FREE (&(*msg)->commited_path);
   FREE (msg);		/* __FREE_CHECKED__ */
   return (r);
 }
diff --git a/mx.h b/mx.h
index dceacc7..5d65b52 100644
--- a/mx.h
+++ b/mx.h
@@ -39,6 +39,7 @@ enum
   M_NNTP,
 #endif
   M_IMAP,
+  M_NOTMUCH,
   M_POP
 #ifdef USE_COMPRESSED
   , M_COMPRESSED
@@ -70,13 +71,30 @@ int maildir_read_dir (CONTEXT *);
 int maildir_check_mailbox (CONTEXT *, int *);
 int maildir_check_empty (const char *);
 
+HEADER *maildir_parse_message (int magic, const char *fname, int is_old, HEADER * _h);
+HEADER *maildir_parse_stream (int magic, FILE *f, const char *fname, int is_old, HEADER * _h);
+void maildir_parse_flags (HEADER * h, const char *path);
+void maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n);
+void maildir_flags(char *dest, size_t destlen, HEADER * hdr);
+
+#if USE_HCACHE
+#include <hcache.h>
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno, header_cache_t *hc);
+#else
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno);
+#endif
+
+#ifdef USE_NOTMUCH
+int mx_is_notmuch(const char *p);
+#endif
+
 int maildir_commit_message (CONTEXT *, MESSAGE *, HEADER *);
 int mh_commit_message (CONTEXT *, MESSAGE *, HEADER *);
 
 int maildir_open_new_message (MESSAGE *, CONTEXT *, HEADER *);
 int mh_open_new_message (MESSAGE *, CONTEXT *, HEADER *);
 
-FILE *maildir_open_find_message (const char *, const char *);
+FILE *maildir_open_find_message (const char *, const char *, char **);
 
 int mbox_strict_cmp_headers (const HEADER *, const HEADER *);
 int mutt_reopen_mailbox (CONTEXT *, int *);
diff --git a/pattern.c b/pattern.c
index db0b5e8..5e6c87e 100644
--- a/pattern.c
+++ b/pattern.c
@@ -42,6 +42,10 @@
 #include "imap/imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 static int eat_regexp (pattern_t *pat, BUFFER *, BUFFER *);
 static int eat_date (pattern_t *pat, BUFFER *, BUFFER *);
 static int eat_range (pattern_t *pat, BUFFER *, BUFFER *);
@@ -98,6 +102,9 @@ Flags[] =
   { 'x', M_REFERENCE,		0,		eat_regexp },
   { 'X', M_MIMEATTACH,		0,		eat_range },
   { 'y', M_XLABEL,		0,		eat_regexp },
+#ifdef USE_NOTMUCH
+  { 'Y', M_NOTMUCH_LABEL,	0,		eat_regexp },
+#endif
   { 'z', M_SIZE,		0,		eat_range },
   { '=', M_DUPLICATED,		0,		NULL },
   { '$', M_UNREFERENCED,	0,		NULL },
@@ -1266,6 +1273,13 @@ mutt_pattern_exec (struct pattern_t *pat, pattern_exec_flag flags, CONTEXT *ctx,
         }
         return pat->not ^ result;
       }
+#ifdef USE_NOTMUCH
+    case M_NOTMUCH_LABEL:
+      {
+      char *tags = nm_header_get_tags(h);
+      return (pat->not ^ (tags && patmatch (pat, tags) == 0));
+      }
+#endif
     case M_HORMEL:
       return (pat->not ^ (h->env->spam && h->env->spam->data && patmatch (pat, h->env->spam->data) == 0));
     case M_DUPLICATED:
diff --git a/protos.h b/protos.h
index 9794760..bfe2ad0 100644
--- a/protos.h
+++ b/protos.h
@@ -79,6 +79,9 @@ void mutt_generate_boundary (PARAMETER **);
 void mutt_delete_parameter (const char *attribute, PARAMETER **p);
 void mutt_set_parameter (const char *, const char *, PARAMETER **);
 
+#ifdef USE_NOTMUCH
+int mutt_parse_virtual_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *err);
+#endif
 
 FILE *mutt_open_read (const char *, pid_t *);
 
@@ -293,6 +296,10 @@ int mutt_check_overwrite (const char *, const char *, char *, size_t, int *, cha
 int mutt_check_traditional_pgp (HEADER *, int *);
 int mutt_command_complete (char *, size_t, int, int);
 int mutt_var_value_complete (char *, size_t, int);
+#if USE_NOTMUCH
+int mutt_nm_query_complete (char *buffer, size_t len, int pos, int numtabs);
+int mutt_nm_tag_complete (char *buffer, size_t len, int pos, int numtabs);
+#endif
 int mutt_complete (char *, size_t);
 int mutt_compose_attachment (BODY *a);
 int mutt_copy_body (FILE *, BODY **, BODY *);
@@ -308,8 +315,10 @@ int mutt_chscmp (const char *s, const char *chs);
 int mutt_parent_message (CONTEXT *, HEADER *);
 int mutt_prepare_template(FILE*, CONTEXT *, HEADER *, HEADER *, short);
 int mutt_resend_message (FILE *, CONTEXT *, HEADER *);
-#define mutt_enter_fname(A,B,C,D,E) _mutt_enter_fname(A,B,C,D,E,0,NULL,NULL)
-int _mutt_enter_fname (const char *, char *, size_t, int *, int, int, char ***, int *);
+#define mutt_enter_fname(A,B,C,D,E) _mutt_enter_fname(A,B,C,D,E,0,NULL,NULL,0)
+#define mutt_enter_vfolder(A,B,C,D,E) _mutt_enter_fname(A,B,C,D,E,0,NULL,NULL,M_SEL_VFOLDER)
+
+int _mutt_enter_fname (const char *, char *, size_t, int *, int, int, char ***, int *, int);
 int  mutt_enter_string (char *buf, size_t buflen, int y, int x, int flags);
 int _mutt_enter_string (char *, size_t, int, int, int, int, char ***, int *, ENTER_STATE *);
 #define mutt_get_field(A,B,C,D) _mutt_get_field(A,B,C,D,0,NULL,NULL)
@@ -374,7 +383,7 @@ int mutt_user_is_recipient (HEADER *);
 void mutt_update_num_postponed (void);
 int mutt_wait_filter (pid_t);
 int mutt_which_case (const char *);
-int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int, char *);
+int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int, char *, char **);
 int mutt_write_mime_body (BODY *, FILE *);
 int mutt_write_mime_header (BODY *, FILE *);
 int mutt_write_one_header (FILE *fp, const char *tag, const char *value, const char *pfx, int wraplen, int flags);
diff --git a/send.c b/send.c
index 3f0e885..43c6476 100644
--- a/send.c
+++ b/send.c
@@ -53,6 +53,9 @@
 #include "remailer.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
 
 static void append_signature (FILE *f)
 {
@@ -1253,6 +1256,7 @@ ci_send_message (int flags,		/* send mode */
   char *smime_default_key = NULL;
   char *tag = NULL, *err = NULL;
   char *ctype;
+  char *finalpath = NULL;
 
   int rv = -1;
   
@@ -1769,7 +1773,9 @@ main_loop:
       mutt_prepare_envelope (msg->env, 0);
       mutt_env_to_intl (msg->env, NULL, NULL);	/* Handle bad IDNAs the next time. */
 
-      if (!Postponed || mutt_write_fcc (NONULL (Postponed), msg, (cur && (flags & SENDREPLY)) ? cur->env->message_id : NULL, 1, fcc) < 0)
+      if (!Postponed || mutt_write_fcc (NONULL (Postponed), msg,
+	                    (cur && (flags & SENDREPLY)) ?
+			             cur->env->message_id : NULL, 1, fcc, NULL) < 0)
       {
 	msg->content = mutt_remove_multipart (msg->content);
 	decode_descriptions (msg->content);
@@ -1969,7 +1975,7 @@ full_fcc:
        * message was first postponed.
        */
       msg->received = time (NULL);
-      if (mutt_write_fcc (fcc, msg, NULL, 0, NULL) == -1)
+      if (mutt_write_fcc (fcc, msg, NULL, 0, NULL, &finalpath) == -1)
       {
 	/*
 	 * Error writing FCC, we should abort sending.
@@ -2030,6 +2036,7 @@ full_fcc:
       msg->content = mutt_remove_multipart (msg->content);
       decode_descriptions (msg->content);
       mutt_unprepare_envelope (msg->env);
+      FREE(&finalpath);
       goto main_loop;
     }
     else
@@ -2038,13 +2045,18 @@ full_fcc:
       goto cleanup;
     }
   }
-  else if (!option (OPTNOCURSES) && ! (flags & SENDMAILX))
+  else if (!option (OPTNOCURSES) && ! (flags & SENDMAILX)) {
     mutt_message (i != 0 ? _("Sending in background.") :
 #ifdef USE_NNTP
 		  (flags & SENDNEWS) ? _("Article posted.") : _("Mail sent."));
 #else
 		  _("Mail sent."));
 #endif
+#ifdef USE_NOTMUCH
+    if (option(OPTNOTMUCHRECORD))
+      nm_record_message(ctx, finalpath, cur);
+#endif
+  }
 
   if (WithCrypto && (msg->security & ENCRYPT))
     FREE (&pgpkeylist);
@@ -2089,7 +2101,8 @@ cleanup:
   safe_fclose (&tempfp);
   if (! (flags & SENDNOFREEHEADER))
     mutt_free_header (&msg);
-  
+
+  FREE(&finalpath);
   return rv;
 }
 
diff --git a/sendlib.c b/sendlib.c
index bf86c4a..b661e71 100644
--- a/sendlib.c
+++ b/sendlib.c
@@ -2759,7 +2759,8 @@ static void set_noconv_flags (BODY *b, short flag)
   }
 }
 
-int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int post, char *fcc)
+int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid,
+		    int post, char *fcc, char **finalpath)
 {
   CONTEXT f;
   MESSAGE *msg;
@@ -2948,6 +2949,8 @@ int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int post,
 
   if (mx_commit_message (msg, &f) != 0)
     r = -1;
+  else if (finalpath)
+    *finalpath = safe_strdup(msg->commited_path);
   mx_close_message (&msg);
   mx_close_mailbox (&f, NULL);
 
diff --git a/sidebar.c b/sidebar.c
index 4cb2101..1cbdbfb 100644
--- a/sidebar.c
+++ b/sidebar.c
@@ -26,7 +26,9 @@
 #include "keymap.h"
 #include "mutt_curses.h"
 #include "mutt_menu.h"
+#include "mx.h"
 #include "sort.h"
+#include "sidebar.h"
 
 /* Previous values for some sidebar config */
 static short  OldVisible;	/* sidebar_visible */
@@ -52,6 +54,39 @@ static int OpnIndex = -1;    /* Current (open) mailbox */
 static int HilIndex = -1;    /* Highlighted mailbox */
 static int BotIndex = -1;    /* Last mailbox visible in sidebar */
 
+enum {
+	SB_SRC_NONE = 0,
+	SB_SRC_VIRT,
+	SB_SRC_INCOMING
+};
+static int sidebar_source = SB_SRC_NONE;
+
+static BUFFY *
+get_incoming (void)
+{
+	switch (sidebar_source) {
+	case SB_SRC_NONE:
+		sidebar_source = SB_SRC_INCOMING;
+
+#ifdef USE_NOTMUCH
+		if (option (OPTVIRTSPOOLFILE) && VirtIncoming) {
+			sidebar_source = SB_SRC_VIRT;
+			return VirtIncoming;
+		}
+		break;
+	case SB_SRC_VIRT:
+		if (VirtIncoming) {
+			return VirtIncoming;
+		}
+		break;
+#endif
+	case SB_SRC_INCOMING:
+		break;
+	}
+
+	return Incoming;	/* default */
+}
+
 /**
  * cb_format_str - Create the string to show in the sidebar
  * @dest:        Buffer in which to save string
@@ -263,6 +298,9 @@ static int cb_qsort_sbe (const void *a, const void *b)
     case SORT_COUNT_NEW:
       result = (b2->msg_unread - b1->msg_unread);
       break;
+    case SORT_DESC:
+      result = mutt_strcmp (b1->desc, b2->desc);
+      break;
     case SORT_FLAGGED:
       result = (b2->msg_flagged - b1->msg_flagged);
       break;
@@ -324,7 +362,7 @@ static void update_entries_visibility (void)
  */
 static void unsort_entries (void)
 {
-  BUFFY *cur = Incoming;
+  BUFFY *cur = get_incoming();
   int i = 0, j;
   SBENTRY *tmp;
 
@@ -435,7 +473,7 @@ static int prepare_sidebar (int page_size)
  * visible - Should we display the sidebar?
  *
  * After validating the config options "sidebar_visible" and "sidebar_width",
- * determine whether we should should display the sidebar.
+ * determine whether we should display the sidebar.
  *
  * When not visible, set the global SidebarWidth to 0.
  *
@@ -678,6 +716,12 @@ static void draw_sidebar (int first_row, int num_rows, int div_width)
         safe_strcat (sidebar_folder_name, sfn_len, tmp_folder_name);
       }
     }
+#ifdef USE_NOTMUCH
+    else if (b->magic == M_NOTMUCH)
+    {
+      sidebar_folder_name = b->desc;
+    }
+#endif
     char str[STRING];
     make_sidebar_entry (str, sizeof (str), w, sidebar_folder_name, entry);
     printw ("%s", str);
@@ -726,6 +770,11 @@ void mutt_sb_draw (void)
   /* if (OldVisible == 0) */
   /* 	mutt_buffy_check (1); we probably have bad or no numbers */
 
+  BUFFY *b;
+  if (Entries == NULL)
+    for (b = get_incoming(); b; b = b->next)
+      mutt_sb_notify_mailbox (b, 1);
+
 #ifdef USE_SLANG_CURSES
   int x = SLsmg_get_column();
   int y = SLsmg_get_row();
@@ -747,7 +796,7 @@ void mutt_sb_draw (void)
   if (div_width < 0)
     return;
 
-  if (!Incoming)
+  if (!get_incoming())
   {
     int w = MIN(COLS, (SidebarWidth - div_width));
     fill_empty_space (first_row, num_rows, w);
@@ -947,7 +996,7 @@ void mutt_sb_set_buffystats (const CONTEXT *ctx)
 {
   /* Even if the sidebar's hidden,
    * we should take note of the new data. */
-  BUFFY *b = Incoming;
+  BUFFY *b = get_incoming();
   if (!ctx || !b)
     return;
 
@@ -1024,6 +1073,9 @@ void mutt_sb_notify_mailbox (BUFFY *b, int created)
   if (!b)
     return;
 
+  if (sidebar_source == SB_SRC_NONE)
+    return;
+
   /* Any new/deleted mailboxes will cause a refresh.  As long as
    * they're valid, our pointers will be updated in prepare_sidebar() */
 
@@ -1076,3 +1128,35 @@ void mutt_sb_notify_mailbox (BUFFY *b, int created)
 
   SidebarNeedsRedraw = 1;
 }
+
+/**
+ * mutt_sb_toggle_virtual - Switch between regular and virtual folders
+ */
+void
+mutt_sb_toggle_virtual (void)
+{
+	if (sidebar_source == -1)
+		get_incoming();
+
+#ifdef USE_NOTMUCH
+	if ((sidebar_source == SB_SRC_INCOMING) && VirtIncoming)
+		sidebar_source = SB_SRC_VIRT;
+	else
+#endif
+		sidebar_source = SB_SRC_INCOMING;
+
+	TopIndex = -1;
+	OpnIndex = -1;
+	HilIndex = -1;
+	BotIndex = -1;
+
+	BUFFY *b;
+
+	EntryCount = 0;
+	FREE(Entries);
+	for (b = get_incoming(); b; b = b->next)
+		mutt_sb_notify_mailbox (b, 1);
+
+	SidebarNeedsRedraw = 1;
+}
+
diff --git a/sidebar.h b/sidebar.h
index 78ec436..f1ffcb1 100644
--- a/sidebar.h
+++ b/sidebar.h
@@ -30,5 +30,6 @@ void         mutt_sb_init (void);
 void         mutt_sb_notify_mailbox (BUFFY *b, int created);
 void         mutt_sb_set_buffystats (const CONTEXT *ctx);
 void         mutt_sb_set_open_buffy (void);
+void         mutt_sb_toggle_virtual (void);
 
 #endif /* SIDEBAR_H */
diff --git a/sort.h b/sort.h
index 3727835..c969c09 100644
--- a/sort.h
+++ b/sort.h
@@ -35,7 +35,8 @@
 #define SORT_COUNT_NEW	16
 #define SORT_FLAGGED	17
 #define SORT_PATH	18
-#define SORT_LABEL	19
+#define SORT_DESC	19
+#define SORT_LABEL	20
 
 /* dgc: Sort & SortAux are shorts, so I'm bumping these bitflags up from
  * bits 4 & 5 to bits 8 & 9 to make room for more sort keys in the future. */
diff --git a/status.c b/status.c
index 61dbf61..dd8cf04 100644
--- a/status.c
+++ b/status.c
@@ -27,6 +27,10 @@
 #include "mapping.h"
 #include "mx.h"
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include <string.h>
 #include <ctype.h>
 #include <unistd.h>
@@ -95,7 +99,14 @@ status_format_str (char *buf, size_t buflen, size_t col, int cols, char op, cons
       break;
 
     case 'f':
-      snprintf (fmt, sizeof(fmt), "%%%ss", prefix);
+    {
+#ifdef USE_NOTMUCH
+      char *p;
+      if (Context && Context->magic == M_NOTMUCH &&
+                   (p = nm_get_description(Context)))
+	  strfcpy(tmp, p, sizeof (tmp));
+      else
+#endif
 #ifdef USE_COMPRESSED
       if (Context && Context->compress_info && Context->realpath) {
 	 strfcpy (tmp, Context->realpath, sizeof (tmp));
@@ -109,9 +120,11 @@ status_format_str (char *buf, size_t buflen, size_t col, int cols, char op, cons
       }
       else
 	strfcpy (tmp, _("(no mailbox)"), sizeof (tmp));
+
+      snprintf (fmt, sizeof(fmt), "%%%ss", prefix);
       snprintf (buf, buflen, fmt, tmp);
       break;
-
+    }
     case 'F':
       if (!optional)
       {
diff --git a/url.c b/url.c
index 799e956..d11b8d7 100644
--- a/url.c
+++ b/url.c
@@ -42,12 +42,15 @@ static const struct mapping_t UrlMap[] =
   { "news",	U_NNTP },
   { "snews",	U_NNTPS },
   { "mailto",	U_MAILTO },
+#ifdef USE_NOTMUCH
+  { "notmuch",  U_NOTMUCH },
+#endif
   { "smtp",     U_SMTP },
   { "smtps",    U_SMTPS },
   { NULL,	U_UNKNOWN }
 };
 
-static int url_pct_decode (char *s)
+int url_pct_decode (char *s)
 {
   char *d;
 
diff --git a/url.h b/url.h
index 15ec9ce..d07150f 100644
--- a/url.h
+++ b/url.h
@@ -13,6 +13,9 @@ typedef enum url_scheme
   U_SMTP,
   U_SMTPS,
   U_MAILTO,
+#ifdef USE_NOTMUCH
+  U_NOTMUCH,
+#endif
   U_UNKNOWN
 }
 url_scheme_t;
@@ -36,5 +39,6 @@ int url_parse_file (char *d, const char *src, size_t dl);
 int url_parse_ciss (ciss_url_t *ciss, char *src);
 int url_ciss_tostring (ciss_url_t* ciss, char* dest, size_t len, int flags);
 int url_parse_mailto (ENVELOPE *e, char **body, const char *src);
+int url_pct_decode (char *s);
 
 #endif
diff --git a/version.c b/version.c
index 23a0926..61c51ef 100644
--- a/version.c
+++ b/version.c
@@ -276,6 +276,11 @@ static struct compile_options comp_opts[] = {
 #else
 	{ "USE_IMAP", 0 },
 #endif
+#ifdef USE_NOTMUCH
+	{ "USE_NOTMUCH", 1 },
+#else
+	{ "USE_NOTMUCH", 0 },
+#endif
 #ifdef USE_NNTP
 	{ "USE_NNTP", 1 },
 #else
-- 
2.7.4

